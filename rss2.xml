<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Taeyeon</title>
    <link>https://taeyeonkim93.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Taeyeon&#39;s dev blog</description>
    <pubDate>Fri, 25 Mar 2022 17:06:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[PineScript] PineScript (TradingView) Guide for Beginners (파인스크립트 배우기)</title>
      <link>https://taeyeonkim93.github.io/2022/03/26/Coin-PineScript-2022-03-26-pinescript-1/</link>
      <guid>https://taeyeonkim93.github.io/2022/03/26/Coin-PineScript-2022-03-26-pinescript-1/</guid>
      <pubDate>Fri, 25 Mar 2022 16:44:54 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;asdsdasdasdsad&lt;/p&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>asdsdasdasdsad</p>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2022/03/26/Coin-PineScript-2022-03-26-pinescript-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Android] 프레임워크 패턴 정리(MVC, MVP, MVVM, VIPER)</title>
      <link>https://taeyeonkim93.github.io/2019/12/02/Develop-Programming-kotlin-2019-12-02-android-framework-pattern/</link>
      <guid>https://taeyeonkim93.github.io/2019/12/02/Develop-Programming-kotlin-2019-12-02-android-framework-pattern/</guid>
      <pubDate>Mon, 02 Dec 2019 07:39:54 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;안드로이드-패턴&quot;&gt;&lt;a href=&quot;#안드로이드-패턴&quot; class=&quot;headerlink&quot; title=&quot;안드로이드 패턴&quot;&gt;&lt;/a&gt;안드로이드 패턴&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MVC, MVP, MVVM 이 가장 많이 쓰이는 패턴들이다.&lt;/li&gt;
&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="안드로이드-패턴"><a href="#안드로이드-패턴" class="headerlink" title="안드로이드 패턴"></a>안드로이드 패턴</h1><ul><li>MVC, MVP, MVVM 이 가장 많이 쓰이는 패턴들이다.</li><li>협업, 유지보수, 테스트가 용이해진다.</li><li>화면에 보여주는 로직과 실제 데이터가 처리 되는 로직을 분리하는게 목적</li></ul><ul><li>패턴을 적용하지 않고 하나의 Activity 에서 표현한다면 이와 같다.<ul><li>화면 제공</li><li>유저 이벤트</li><li>업무 로직</li><li>화면 업데이트</li></ul></li></ul><ul><li><p><strong>각 패턴의 재료</strong></p><ul><li><p>Data Object (자료 객체)</p><ul><li>기본이 되는 데이터의 순수 객체 표현</li></ul></li><li><p>Business Logic (비즈니스 로직)</p><ul><li>데이터를 생성/표시/저장/변경 하는 로직</li><li>대부분의 <code>Use Case</code> 가 구현될 부분</li></ul></li><li><p>Coordinator</p><ul><li>이벤트 핸들링이나 Business Logic을 제외한 기타 로직</li><li>외부 API 호출이나 DB 호출도 들어갈 수 있다.</li></ul></li><li><p>Converter</p><ul><li>로컬에 존재하는 Domain Data 를 표현 계층의 데이터 형태로 Formatting 하는 역할</li><li>복잡하지 않으면 Controller 나 Abstract View 안으로 들어갈 수 있음</li></ul></li><li><p>Abstract View</p><ul><li>실제 화면에 표시되기 전의 추상화된 데이터</li></ul></li><li><p>View Logic</p><ul><li>추상화되어있는 데이터가 화면에 어떻게 표현될지 구체적 로직을 구성함</li></ul></li><li><p>View</p><ul><li>Logic 이 존재하지 않는 디자인을 불러오기위한 역할</li></ul></li><li><p>Event Bundle</p><ul><li>사용자 입력이나 외부 요인에 의한 데이터 변경을 정의</li><li>View 또는 Data 쪽으로 흡수 될 수 있다</li></ul></li><li><p>External Interface</p><ul><li>DB 접근, API 호출 등 외부 시스템과의 연동 인터페이스.</li></ul></li></ul></li></ul><h2 id="MVC-Model-View-Controller"><a href="#MVC-Model-View-Controller" class="headerlink" title="MVC (Model + View + Controller)"></a>MVC (Model + View + Controller)</h2><p><img src="/images/android-pattern/mvc.png" alt><br><img src="/images/android-pattern/mvc2.png" alt></p><ul><li>Model<ul><li>실제 데이터 및 데이터 조작 로직을 처리하는 부분</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainModel</span></span>(<span class="keyword">val</span> context: Context) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getListDatas</span><span class="params">()</span></span>: ArrayList&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> datas: ArrayList&lt;String&gt; = ArrayList&lt;String&gt;()</span><br><span class="line">        <span class="comment">//dbms</span></span><br><span class="line">        <span class="keyword">val</span> helper=DBHelper(context)</span><br><span class="line">        <span class="keyword">val</span> db=helper.readableDatabase</span><br><span class="line">        <span class="keyword">val</span> cursor = db.rawQuery(<span class="string">"select * from tb_test"</span>, <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">            datas.add(cursor.getString(<span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        db.close()</span><br><span class="line">        <span class="keyword">return</span> datas</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addItem</span><span class="params">(item: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> helper=DBHelper(context)</span><br><span class="line">        <span class="keyword">val</span> db=helper.writableDatabase</span><br><span class="line">        db.execSQL(<span class="string">"insert into tb_test (todo) values (?)"</span>, arrayOf(item))</span><br><span class="line">        db.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>View<ul><li>사용자에게 제공되어 보여지는 UI 부분</li><li>layout(xml) 만을 View 로 정의한다.</li><li>Activity, Fragment 의 경우에는 Controller 로 정의</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/listView"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/editView"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"add"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Controller<ul><li>사용자의 입력을 받고 처리하는 부분</li><li>Activity, Fragment 가 이러한 역할을 대신함</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVCMainActivity</span> : <span class="type">AppCompatActivity</span></span>(), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> datas: ArrayList&lt;String&gt;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> adapter: ArrayAdapter&lt;String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> model=MainModel(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        datas=model.getListDatas()</span><br><span class="line">        adapter=ArrayAdapter(<span class="keyword">this</span>, android.R.layout.simple_list_item_1, datas)</span><br><span class="line">        listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span>: String = editView.text.toString()</span><br><span class="line">        model.addItem(<span class="keyword">data</span>)</span><br><span class="line">        datas.add(<span class="keyword">data</span>)</span><br><span class="line">        adapter.notifyDataSetChanged()</span><br><span class="line">        editView.setText(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>로직<ol><li>Controller 로 사용자의 입력을 받음</li><li>사용자의 입력으로 인해 Model 값을 변경해야하는지 검사한다. (T)</li><li>Controller 에서 Model 의 데이터를 가져오거나 갱신한다.</li><li>Controller 에서 UI 를 갱신한다. </li></ol></li></ul><h2 id="MVVM-Model-View-ViewModel"><a href="#MVVM-Model-View-ViewModel" class="headerlink" title="MVVM (Model + View + ViewModel)"></a>MVVM (Model + View + ViewModel)</h2><p><img src="/images/android-pattern/mvvm.png" alt><br><img src="/images/android-pattern/mvvm2.png" alt></p><ul><li>Model<ul><li>업무로직을 수행하고 결과에 대한 데이터를 표현한다.</li></ul></li></ul><ul><li>View<ul><li>화면 표시가 주 목적</li><li>Activity, FrameWork 역할</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVVMMainActivity</span> : <span class="type">AppCompatActivity</span></span>(), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> viewModel: MainViewModel= MainViewModel(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        viewModel.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span>: String = editView.text.toString()</span><br><span class="line">        editView.setText(<span class="string">""</span>)</span><br><span class="line">        viewModel.onClick(<span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ViewModel<ul><li>Model 과 View 를 분리 시키는게 목적</li><li>View 가 필요한 Data 와 Command 제공</li><li>Actiity 객체나 onCreate 등 LifeCycle 업무가 포함될 수 있다.</li><li>Model 결과에 의한 데이터 바인딩이 직접 될 수 있다.</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span></span>(<span class="keyword">val</span> activity: Activity)&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> datas: ArrayList&lt;String&gt;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> adapter: ArrayAdapter&lt;String&gt;</span><br><span class="line">    <span class="keyword">val</span> model=MainModel(activity)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        datas=model.getListDatas()</span><br><span class="line">        adapter= ArrayAdapter(activity, R.layout.simple_list_item_1, datas)</span><br><span class="line">        activity.listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        model.addItem(<span class="keyword">data</span>)</span><br><span class="line">        datas.add(<span class="keyword">data</span>)</span><br><span class="line">        adapter.notifyDataSetChanged()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MVP-Model-View-Presenter"><a href="#MVP-Model-View-Presenter" class="headerlink" title="MVP (Model + View + Presenter)"></a>MVP (Model + View + Presenter)</h2><p><img src="/images/android-pattern/mvp.png" alt><br><img src="/images/android-pattern/mvp2.png" alt></p><p><strong>MVP 패턴의 가장 큰 의의는 View와 Model을 완전하게 분리해서 사용 할 수 있어야 한다.</strong></p><ul><li>interface<ul><li>순수한 interface를 정의한다.</li><li>Constant를 정의할때도 interface를 활용한다.</li><li>Model, View, Presenter에서 사용할 function들을<br>interface 형태로 정의한다.</li></ul></li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMainPresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getListView</span><span class="params">()</span></span>: ArrayList&lt;String&gt;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addItem</span><span class="params">(item: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IView</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">updateListView</span><span class="params">(item: <span class="type">String</span>)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Model</p><ul><li>presenter에 정의된 함수들에 대한 내용을 작성한다.</li><li>data class 를 정의한다.</li></ul></li><li><p>View</p><ul><li>Presenter 에 이벤트 핸들링을 위임한다.<ul><li>Activity 가 View interface 를 구현해서 Presenter에서 코드를 만들 인터페이스를 갖도록 하면 된다.</li></ul></li><li>Activity / Fragment 에 속하는 분류는 전부 View에 속한다.</li><li>interface 폴더에서 만든 view의 interface를 가지고 있음.</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVPMainActivity</span> : <span class="type">AppCompatActivity</span></span>(), View.OnClickListener, IMainPresenter.IView&#123;</span><br><span class="line">    <span class="keyword">val</span> presenter: MainPresenter = MainPresenter(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> datas: ArrayList&lt;String&gt;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> adapter: ArrayAdapter&lt;String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        presenter.view=<span class="keyword">this</span></span><br><span class="line">        datas=presenter.getListView()</span><br><span class="line">        adapter= ArrayAdapter(<span class="keyword">this</span>, android.R.layout.simple_list_item_1, datas)</span><br><span class="line">        listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span>: String = editView.text.toString()</span><br><span class="line">        presenter.addItem(<span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateListView</span><span class="params">(item: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        datas.add(item)</span><br><span class="line">        adapter.notifyDataSetChanged()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Presenter</p><ul><li><p>model에서 사용할 interface를 선언하여 각자 할일을 정의해준다.<br>(view에서 직접 override 하기도 함)</p></li><li><p>interface를 가져와서 override한뒤 필요한 함수들을 넣어서 View 의<br>상호작용에 필요한 함수들을 정의한다.</p></li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span></span>(<span class="keyword">val</span> context: Context): IMainPresenter &#123;</span><br><span class="line">    <span class="keyword">var</span> model: MainModel= MainModel(context)</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> view: IMainPresenter.IView</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getListView</span><span class="params">()</span></span>: ArrayList&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> model.getListDatas()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addItem</span><span class="params">(item: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        model.addItem(item)</span><br><span class="line">        view.updateListView(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VIPER-View-Interactor-Presenter-Entity-Router"><a href="#VIPER-View-Interactor-Presenter-Entity-Router" class="headerlink" title="VIPER (View + Interactor + Presenter + Entity + Router)"></a>VIPER (View + Interactor + Presenter + Entity + Router)</h2><p><img src="/images/android-pattern/viper.png" alt><br><img src="/images/android-pattern/viper2.png" alt></p><ul><li>View<ul><li>사용자 입력을 Presenter 로 보내는 작업</li><li>UI View Controller 에 해당</li><li>View Life Cycle : Life Cycle 관련 함수가 호출되는것을 Presenter 에 알림</li><li>View Event : Event 관련 함수가 호출되는 것을 Presenter 에 알림</li><li>View Control : 뷰의 UI 생성,변경,삭제 등의 방법을 Presenter 에 제공</li></ul></li></ul><ul><li>Interactor<ul><li>API 로부터 data 를 받아 entity(model) 을 생성함</li></ul></li></ul><ul><li>Presenter<ul><li>Interactor 에서 data 를 요청하고 받음</li><li>view logic 을 갖고 있으며 Interactor 에서<br>data 를 받으면 View 에 어떻게 그릴지 알려줌</li><li>Life Cycle에 대한 처리</li></ul></li></ul><ul><li>Entity<ul><li>Interactor 에 의해 만들어지는 Model</li><li>네트워크, DB 등의 데이터 모델</li><li>Realm Object, NSUserDefaults, Json Data 등</li></ul></li></ul><ul><li>Router<ul><li>Navigation logic 을 담당하며 screen 에서 다른 screen 으로 화면이<br>변경되는 부분을 처리함</li><li>VIPER 컴포넌트들의 DI 를 담당함</li></ul></li></ul><ul><li>특징<ul><li>Distribution : 4개의 구조 중 제일 분배가 잘 되어있음</li><li>Testability : 테스트에 용이함</li><li>Hard to use : 코드 양이 제일 많음. 작은 기능에도 많은 클래스를 작성해야함</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/12/02/Develop-Programming-kotlin-2019-12-02-android-framework-pattern/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Android] 안드로이드 디자인 관련 이슈 정리</title>
      <link>https://taeyeonkim93.github.io/2019/11/21/Develop-Programming-kotlin-2019-11-21-android-design-issue/</link>
      <guid>https://taeyeonkim93.github.io/2019/11/21/Develop-Programming-kotlin-2019-11-21-android-design-issue/</guid>
      <pubDate>Thu, 21 Nov 2019 13:31:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;UI, layout 등 안드로이드 디자인 관련 기억하고 싶은 내용을 적는 곳&lt;/p&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#1-레이아웃-종류&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>UI, layout 등 안드로이드 디자인 관련 기억하고 싶은 내용을 적는 곳</p><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><p><a href="#1-레이아웃-종류">레이아웃 종류</a><br><a href="#2-디자인-용어-정리">디자인 용어 정리</a><br><a href="#3-뷰-종류">뷰 종류</a><br><a href="#4-디자인-함수-정리">디자인 함수 정리</a><br><a href="#5-디자인-관련-유용한-사이트-정리">디자인 관련 유용한 사이트 정리</a><br><a href="#6-UI-코딩-시-사용하는-구성요소">UI 코딩 시 사용하는 구성요소</a><br><a href="#7-xml-에서-사용하는-속성-정리">xml 에서 사용하는 속성 정리</a><br><a href="#8-res-폴더-정리">res 폴더 정리</a></p><h3 id="1-레이아웃-종류"><a href="#1-레이아웃-종류" class="headerlink" title="1. 레이아웃 종류"></a><a href="#목차">1. 레이아웃 종류</a></h3><ul><li>Frame Layout<ul><li>자식 뷰들을 겹쳐서 배치한다.</li><li>화면에 표시되는 View를 바꿔가면서 표현하고싶을때 사용</li><li>일반적으로는 하나의 자식 뷰를 보여주기 위함이다.</li></ul></li></ul><ul><li>Linear Layout<ul><li>선택된 방향(수직 또는 수평) 에 따라 일자로 자식 뷰들을 배치한다.</li><li>각 자식 뷰는 가중치(weight value)를 설정해서<br>얼마나 많은 레이아웃 공간을 차지할 것인지 정할 수 있다.</li></ul></li></ul><ul><li>Table Layout<ul><li>자식 뷰들을 격자 형태의 행과 열로 배치한다.</li><li>하나의 테이블에 있는 각 행은 TableRow 객체로 나타내며, 각 셀의 뷰 객체를 포함한다.</li><li>이것보단 Grid Layout 을 사용한다.</li></ul></li></ul><ul><li>Relative Layout<ul><li>다른 자식뷰들과 상대적으로 비교해서 배치한다.</li><li>다양한 화면 크기와 방향에서 동작하는 사용자 인터페이스를 구현할 수 있다.</li></ul></li></ul><ul><li>Absolute Layout<ul><li>자식 뷰들을 특정 XY좌표에 위치하게 배치한다.</li><li>화면 크기가 달라지는것에 유연하게 대처하기 힘들기때문에 하지 않는것이 좋다</li></ul></li></ul><ul><li>Grid Layout<ul><li>격자무늬(grid)를 구성하여 각 셀에 자식 뷰들을 배치한다.</li><li>컴포넌트들의 간격은 스페이스 뷰라는 특별한 타입의 뷰를 인접 셀에 두어서 구현하거나<br>마진 매개변수를 설정해서 구현할 수 있다.</li><li>테이블 레이아웃의 단점을 보완한 레이아웃이다.</li></ul></li></ul><ul><li><p>Coordinator Layout</p><ul><li>화면 위 앱 바(app bar)와 다른 자식 뷰들과 상호작용을 하기위한 레이아웃이다.</li><li>Frame Layout과 유사하다.</li><li>Behavior을 자식 뷰에 지정할 수 있다.</li><li>자식 뷰들은 anchor를 가진다.<ul><li>anchor는 일반적으로 다른 뷰를 가리키며, 뷰의 id값으로 표시된다.</li><li>anchor는 반드시 Coordinator layout 하위의 자손 뷰중 하나의 아이디여야 한다.</li><li>insetEdge를 이용해 자식 뷰들이 어떻게 배치될지 지정할 수 있다.</li></ul></li><li>레이아웃 구조<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ToolBar</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NestedScroolView</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FloatingActionButton</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>DrawerLayout</p><ul><li>서랍처럼 등장하는 레이아웃</li><li>모든 뷰보다 최상위에 있어야 함</li><li>레이아웃 구조<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DrawerLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">CoordinatorLayout</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SwipePlaceHolderView</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationView</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-디자인-용어-정리"><a href="#2-디자인-용어-정리" class="headerlink" title="2. 디자인 용어 정리"></a><a href="#목차">2. 디자인 용어 정리</a></h3><ul><li>뷰 (View)<ul><li>화면의 표시될 모든 클래스에 대한 모음집(패키지) 이다.</li><li>사용자가 보는 화면의 모든 인터페이스의 요소들은<br>View (android.view.View) 클래스의 서브 클래스다.</li><li>위젯을 자식으로 둔 부모클래스이다.</li></ul></li></ul><ul><li>위젯 (Widget)<ul><li>화면 상 UI 요소들에 대한 모음집(패키지) 이다.</li><li>ImageView, TextView, Button 등의 통칭이다.</li><li>이들은 View, ViewGroup의 클래스를 무조건 상속받는다.</li></ul></li></ul><ul><li>뷰 그룹(ViewGroup)<ul><li>Widget 들을 자식으로 가진 View 이다.</li><li>주로 Layout, AdapterView 등 하위 widget 들을<br>그룹핑 해야하는 Widget 클래스들의 모음집(패키지)이다.</li></ul></li></ul><ul><li>앱 위젯(AppWidget)<ul><li>다른 App 위에 올라가는 소형 View이다.</li></ul></li></ul><ul><li>네비게이션 드로어(Navigation Drawer) / 항법 서랍장<ul><li>왼쪽에서 출현하는 서랍장과 같은 기능</li><li>네비 바 라고도 부른다.</li></ul></li></ul><ul><li>앱 바(App bar)<ul><li>화면 최상단에 Bar 형식으로 들어가는 작업 표시줄</li><li>ActionBar 는 Activity 에 작업표시줄에 대한 개념</li><li>Toolbar 는 Widget 으로, Activity 의 앱 바로 설정할 수 있다.</li></ul></li></ul><ul><li>스타일(Style)<ul><li>View 또는 창의 모양과 형식을 지정하는 속성 모음</li><li>height, padding, font-color, font-size, background 등의 속성 지정 가능</li><li>Layout 내 xml 과 별개인 xml resource 에 정의됨</li></ul></li></ul><ul><li>테마(Theme)<ul><li>개별 View 가 아닌 전체 Activity 또는 Application 에 적용되는 Style</li></ul></li></ul><h3 id="3-뷰-종류"><a href="#3-뷰-종류" class="headerlink" title="3. 뷰 종류"></a><a href="#목차">3. 뷰 종류</a></h3><ul><li>Recycler View<ul><li>ListView 의 대체로 나온 View</li><li>사용자가 관리하는 많은 수의 데이터 집합(Data Set) 을 개별 Item 단위로<br>구성하여 화면에 출력하는 ViewGroup 이며, 한 화면에 표시되기 힘든<br>많은 수의 데이터를 Scroll 가능한 List 로 표시해주는 Widget</li><li>뷰 홀더를 필수로 구현해야 한다.</li></ul></li></ul><ul><li>Navigation View<ul><li>navigation 의 내부 내용을 작성할 수 있는 View</li><li>두가지의 레이아웃으로 나뉘어있다<ul><li>headerLayout : 상단 헤더부분 레이아웃</li><li>menu : 하단 메뉴부분 레이아웃</li></ul></li></ul></li></ul><h3 id="4-디자인-함수-정리"><a href="#4-디자인-함수-정리" class="headerlink" title="4. 디자인 함수 정리"></a><a href="#목차">4. 디자인 함수 정리</a></h3><h5 id="Recycler-View"><a href="#Recycler-View" class="headerlink" title="Recycler View"></a>Recycler View</h5><ul><li>onCreateViewHolder([ViewGroup], [viewType])<ul><li>viewType 형태의 ItemView 를 위한 ViewHolder 객체 생성</li></ul></li></ul><ul><li>onBindViewHolder([ViewHolder], [position])<ul><li>position 에 해당하는 데이터를 ViewHolder 의 ItemView 에 표시</li></ul></li></ul><ul><li>getItemCount()<ul><li>전체 아이템 갯수 리턴</li></ul></li></ul><ul><li>setLayoutManager([LayoutManager])<ul><li>레이아웃매니저를 지정한다.</li><li>new LinearLayoutManager(this) 와 같이 매개변수를 넣는다.</li><li>이외에 GridLayoutManager, StaggeredGridLayoutManager 가 있다</li></ul></li></ul><ul><li>setAdapter([adapter])<ul><li>어답터를 지정한다.</li></ul></li></ul><h5 id="액션바"><a href="#액션바" class="headerlink" title="액션바"></a>액션바</h5><ul><li>setSupportActionBar(Toolbar)<ul><li>화면 상단 액션바를 toolbar 위젯으로 사용하도록 설정가능</li><li>기본 액션바를 NoActionBar로 변경해야 한다</li><li>사용 예시<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setSupportActionBar(toolbar)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>ActionBarDrawerToggle(activity, drawerLayout, toolbar, openDrawerContentDescRes, closeDrawerContentDescRes)<ul><li>액션바에 Drawer 을 토글로 붙여 사용할 수 있도록 한다.</li><li>@param<ul><li>현재 Activity</li><li>Toolbar</li><li>drawer 레이아웃</li><li>열었을때 나올 String</li><li>닫았을때 나올 String</li></ul></li><li>사용 예시<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> toggle = ActionBarDrawerToggle(</span><br><span class="line">        <span class="keyword">this</span>, drawerLayout, toolbar,</span><br><span class="line">        R.string.navigation_drawer_open, R.string.navigation_drawer_close)</span><br><span class="line"></span><br><span class="line">drawerLayout.addDrawerListener(toggle)</span><br><span class="line"><span class="comment">// drawerLayout은 drawerLayout의 id</span></span><br><span class="line"></span><br><span class="line">toggle.syncState()</span><br><span class="line"><span class="comment">// 토글이 계속해서 동기화 될수 있도록 함</span></span><br><span class="line"></span><br><span class="line">navView.setNavigationItemSelectedListener(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">// navView 는 네비게이션 내 Item들을 담당하는 View id</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-디자인-관련-유용한-사이트-정리"><a href="#5-디자인-관련-유용한-사이트-정리" class="headerlink" title="5. 디자인 관련 유용한 사이트 정리"></a><a href="#목차">5. 디자인 관련 유용한 사이트 정리</a></h3><ul><li><a href="https://material.io/" rel="external nofollow noopener noreferrer" target="_blank">https://material.io/</a><ul><li>구글에서 표준으로 지정하는 material 디자인 가이드</li></ul></li></ul><h3 id="6-UI-코딩-시-사용하는-구성요소"><a href="#6-UI-코딩-시-사용하는-구성요소" class="headerlink" title="6. UI 코딩 시 사용하는 구성요소"></a><a href="#목차">6. UI 코딩 시 사용하는 구성요소</a></h3><ul><li>LayoutManager (레이아웃 매니저)<ul><li>아이템 뷰가 나열되는 형태를 관리하기 위한 요소</li></ul></li></ul><ul><li><p>Adapter (어댑터)</p><ul><li>사용자 Data Set 으로부터 Item View 를 만드는 역할</li></ul></li><li><p>ViewHolder (뷰홀더)</p><ul><li>화면에 표시될 Item View 를 저장하는 객체</li><li>어댑터 내부에서 생성됨</li></ul></li></ul><h3 id="7-xml-에서-사용하는-속성-정리"><a href="#7-xml-에서-사용하는-속성-정리" class="headerlink" title="7. xml 에서 사용하는 속성 정리"></a><a href="#목차">7. xml 에서 사용하는 속성 정리</a></h3><ul><li>android:id</li><li>android:layout_marginStart : 좌측에서부터 margin</li><li>android:layout_marginEnd : 우측에서부터 margin</li><li>android:layout_width</li><li>android:layout_height</li><li>android:layout_gravity : View 의 위치 (left,right,bottom,center,top)</li></ul><h3 id="8-res-폴더-정리"><a href="#8-res-폴더-정리" class="headerlink" title="8. res 폴더 정리"></a><a href="#목차">8. res 폴더 정리</a></h3><ul><li>anim</li><li>drawable</li><li>layout</li><li>menu</li><li>mipmap</li><li>values</li></ul>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/11/21/Develop-Programming-kotlin-2019-11-21-android-design-issue/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Android] Dagger2 정리</title>
      <link>https://taeyeonkim93.github.io/2019/11/20/Develop-Programming-kotlin-2019-11-20-android-dagger/</link>
      <guid>https://taeyeonkim93.github.io/2019/11/20/Develop-Programming-kotlin-2019-11-20-android-dagger/</guid>
      <pubDate>Wed, 20 Nov 2019 08:10:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;의존성&quot;&gt;&lt;a href=&quot;#의존성&quot; class=&quot;headerlink&quot; title=&quot;의존성?&quot;&gt;&lt;/a&gt;의존성?&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;의존성? &lt;ul&gt;
&lt;li&gt;코드에서 두 모듈간의 연결&lt;/li&gt;
&lt;li&gt;두 클래스 간의 관계&lt;/li&gt;
&lt;li
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="의존성"><a href="#의존성" class="headerlink" title="의존성?"></a>의존성?</h1><ul><li>의존성? <ul><li>코드에서 두 모듈간의 연결</li><li>두 클래스 간의 관계</li><li>의존성이 크다는 것은 Coupling(결합도)가 높다는 것</li></ul></li></ul><ul><li>의존성이 왜 중요한가?<ul><li>하나의 모듈이 변경됨에 따라 결합된 다른 모듈이 영향을 받게 된다.</li><li>두개의 모듈일때는 괜찮지만 최악의경우 모듈이 100개,1000개…n 개 일때 하나의 모듈변경으로 인해 n-1개의 모듈이 영향을 받는다고 생각해보자</li><li>나머지 모듈이 제대로 동작하는지에 대한 검증이 필요할 수도 있다. 그럼 시간과 비용도 n만큼??</li><li>결합도가 높으면 독립성이 떨어진다. 반대로 결합도가 낮으면 독립성이 높아진다.</li></ul></li></ul><ul><li><p>의존성 주입</p><ul><li><p>구성요소간의 의존 관계가 소스코드 내부가 아닌 <strong>외부의 설정파일</strong><br>등을 통해 정의되게 하는 디자인 패턴</p></li><li><p>외부에서 인스턴스 변수를 생성하여 넘겨주는(주입하는) 것</p></li><li><p>객체가 자신이 사용할 객체를 스스로 선택하지 않고<br>제 3의 객체에게 사용될 객체를 주입받는다.(의존 관계 역전)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">(DatabaseThingie useThisDatabaseInstead)</span> </span>&#123;</span><br><span class="line">    myDatabase = useThisDatabaseInstead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>useThisDatabaseInstead 라는 다른 클래스의 인스턴스를 사용하게 만듬</p></li><li><p>Example 클래스에 “의존성” 을 “주입” 했다</p></li></ul></li></ul><ul><li>의존성 주입의 목적<ul><li>독립된 모듈에 대한 테스트 코드 작성이 가능하다.</li><li>하나의 모듈이 변경되어도 다른 모듈들이 영향을 받지 않는다.</li><li>객체 생성을 외부에서 하므로 재사용성이 높아진다.</li></ul></li></ul><h1 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger?"></a>Dagger?</h1><ul><li>Dagger : Dependency Injection (의존성 주입) Framework</li></ul><ol><li>Provides 메소드로 이루어진 Module 을 작성한다.</li><li>Component 를 작성해서 Module 과 연결하고, 의존성 객체를 주입받을 객체를 만든다.</li></ol><ul><li><p>객체를 일단 만들고, 모듈로 객체를 사용하는 방법을 정의하고,<br>컴포넌트로 모듈을 메인으로 사용할 클래스에 전달한다.</p></li><li><p>Dagger 의 Inject 방법</p><ul><li>Constructor Injection (생성자 주입)</li><li>Method(Setter) Injection (메소드 주입)</li><li>Field Injection</li></ul></li></ul><ul><li>Provides<ul><li>어노테이션이 달린 메소드를 Dagger Pool 에 제공하겠다는 의미</li><li>모든 Provides 메소드는 @Module 클래스 안에 속해야 함   </li><li><code>Binds</code><ul><li>Provides 와 같지만 매개변수를 바로 return 한다</li><li>Provides 의 개선된 버전</li></ul></li><li><code>Multibinding</code><ul><li>Set 이나 Map 을 이용한 <code>Multibinding</code> 을 지원함</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="keyword">public</span> LoginContract.Presenter </span><br><span class="line">  provideLoginPresenter(LoginPresenter loginPresenter) &#123;</span><br><span class="line">    <span class="keyword">return</span> loginPresenter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">@Binds</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> LoginContract.Presenter</span><br><span class="line">  provideLoginPresenter(LoginPresenter loginPresenter);</span><br></pre></td></tr></table></figure><ul><li>Scope<ul><li>해당 클래스의 단일 인스턴스가 존재하는 범위</li><li><code>Singleton scope</code><ul><li>Application scope 를 가지는 annotation</li><li>싱글톤 scope 를 특정하게 지정해주면 아무 곳에서나 inject 할 수 있다.</li></ul></li></ul></li></ul><ul><li>Module<ul><li>의존성 객체를 생성함</li></ul></li></ul><ul><li>Inject<ul><li>의존성 주입을 요청하는 <code>Annotation</code></li><li>@Inject 를 사용하면, <code>Component</code> 가 <code>Module</code> 을 이용해 Generate 한 객체들이<br>Inject Annotation 이 달린 함수에 주입된다.</li></ul></li></ul><ul><li>Component<ul><li>구성요소 라는 뜻. Application Component 는 어플리케이션 구성요소이다.</li><li>이 annotation 이 달려있는 인터페이스는 의존성 주입 코드가 generate 된다</li><li>module class 에서 제공받은 객체를 어떤곳에 주입 할지 정하는 역할을 한다.<ul><li>Activity 에서 build 를 통해 받을 곳이라는 명시를 해야 한다</li></ul></li><li><code>Subcomponent</code><ul><li>부모 component 가 존재하는 component</li><li>코드 생성은 부모 component 에서 이루어진다</li><li>사용법은 interface 나 abstract class 에 @Subcomponent 를 달아줌</li></ul></li></ul></li></ul><ul><li>Qualifier<ul><li>같은 Return 값을 가질 때 구별하기 위한 annotation<ul><li>같은 값을 return 하는 경우 @other1 @other2 로 구분<br>이 때 Inject 할때도 @other1 @other2 를 붙여서 구분해서 inject 가능</li></ul></li></ul></li></ul><h1 id="안드로이드에서의-사용법"><a href="#안드로이드에서의-사용법" class="headerlink" title="안드로이드에서의 사용법"></a>안드로이드에서의 사용법</h1><ul><li>Dagger2 코딩하기<ol><li>Dagger2 를 빌드할 Activity 를 만들기</li><li>전체를 총괄할 AppComponent 만들기</li></ol></li></ul><h3 id="1-애플리케이션에서-Dagger-빌드하기"><a href="#1-애플리케이션에서-Dagger-빌드하기" class="headerlink" title="1. 애플리케이션에서 Dagger 빌드하기"></a>1. 애플리케이션에서 Dagger 빌드하기</h3><ul><li><p>우리가 첫 공부할때 Main 문에서 하듯 Dagger2 의 실행부터 역으로 살펴보기로 한다.</p></li><li><p>Activity 의 인스턴스를 Android OS 내에서 만들기 때문에 (new Activity 가 불가능)<br>Life Cycle 내에서 반드시 Constructor Injection 이 아닌 Field Injection 이 이루어져야 한다.</p></li><li><p>과거의 방식</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">((MyApplication) getApplication())</span><br><span class="line">        .getAppComponent()</span><br><span class="line">        .myActivity(new MyActivityModule(userId))</span><br><span class="line">        .build()</span><br><span class="line">        .inject(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li><li><p>최근 방식</p><ul><li>Class 가 어떤 방식으로 의존성 주입이 되는지 전혀 알 필요 없게 구성되었다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DaggerAppComponent</span><br><span class="line">        .builder()</span><br><span class="line">        .application(<span class="keyword">this</span>)</span><br><span class="line">        .build()</span><br><span class="line">        .inject(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-AppComponent-로-전체-모듈-구성하기"><a href="#2-AppComponent-로-전체-모듈-구성하기" class="headerlink" title="2. AppComponent 로 전체 모듈 구성하기"></a>2. AppComponent 로 전체 모듈 구성하기</h3><ul><li>빌드할 메인 에플리케이션을 만들었으면, 빌드에 필요한 재료를 만든다.</li></ul><ul><li>AppComponent interface 는 module 들을 Component 라는 영역에 가두고,<br>Builder 로 Component 영역에 접근 할 수 있게 만든다.</li></ul><ul><li>빌드 할 때 Component Annotation 에 기입된 모듈에 있는 모든 클래스는 인스턴스가 생성된다.</li></ul><ul><li><strong>@Component.Builder</strong><ul><li></li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component(modules = [</span></span><br><span class="line"><span class="meta">    (AndroidInjectionModule::class)</span>,</span><br><span class="line">    (AppModule::<span class="class"><span class="keyword">class</span>),<span class="type"></span></span></span><br><span class="line">    (ActivityBuilder::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">])</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span>.Builder</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BindsInstance</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">application</span><span class="params">(application: <span class="type">Application</span>)</span></span>: Builder</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: AppComponent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(app: <span class="type">MvpApp</span>)</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-AppModule-로-전체-객체-구성하기"><a href="#3-AppModule-로-전체-객체-구성하기" class="headerlink" title="3. AppModule 로 전체 객체 구성하기"></a>3. AppModule 로 전체 객체 구성하기</h3><h3 id="4-사용할-Activity-구성하기"><a href="#4-사용할-Activity-구성하기" class="headerlink" title="4. 사용할 Activity 구성하기"></a>4. 사용할 Activity 구성하기</h3><ul><li>MVP 구성<ul><li>interactor 폴더<ul><li>[Activity 이름]Interactor</li><li>[Activity 이름]MVPInteractor</li></ul></li><li>presenter 폴더<ul><li>[Activity 이름]Presenter</li><li>[Activity 이름]MVPPresenter</li></ul></li><li>view 폴더<ul><li>[Activity 이름]Activity</li><li>[Activity 이름]MVPView</li></ul></li><li>[Activity 이름]ActivityModule</li></ul></li></ul><ul><li>Module 에서 Model 역할인 Interactor 와 Presenter 을 Provides 함</li></ul><ul><li>activityDispatchingAndroidInjector: DispatchingAndroidInjector<activity><ul><li>제네릭 타입으로 클래스를 선언함으로써 객체를 선언할때 강한 TypeCheck 를 하고 객체 생성 시타입변환(Casting) 을 하지 않아도 된다.</li><li>@Inject Annotation 을 사용함으로써 Generate 되어있던 </li></ul></activity></li></ul><ul><li>Reflection 없이 사용하기<ul><li>Reflection : 자바 언어의 기능 중 하나로 프로그램 내부 속성을 조작 할 수 있게함</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrombulationActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> Frombulator frombulator;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">// 반드시 선행되어야 할 작업, 그렇지 않으면 frombulator는 null이 됩니다.</span></span><br><span class="line">    ((SomeApplicationBaseType) getContext().getApplicationContext())</span><br><span class="line">        .getApplicationComponent()</span><br><span class="line">        .newActivityComponentBuilder()</span><br><span class="line">        .activity(<span class="keyword">this</span>)</span><br><span class="line">        .build()</span><br><span class="line">        .inject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 인젝션이 끝났으므로 신나는 코딩 이예~</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>빌드 후 인젝션하는 단순 반복되는 보일러플레이트코드가 너무 많다.</li><li>종속성 주입의 원칙인 클래스가 주입되는 방식에 대해서 알지 않아도 되게 만들어야한다.</li></ul><ul><li>AndroidInjection<ul><li><code>AndroidInjection.inject()</code> 를 호출 하면 애플리케이션으로부터<br><code>DispatchingAndroidInjector&lt;Object&gt;</code> 를 얻게되고 해당 액티비티를 인자로 메소드 인젝션 하게된다.</li><li>@Binds 나 @Provider 을 설정하지 않아도 Activity 와 바인딩 할 수 있다.</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">performDI</span><span class="params">()</span></span> = AndroidInjection.inject(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><h3 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h3><ul><li>@ContributesAndroidInjector<ul><li>반환타입을 통해 AndroidInjector 를 생성시켜주는 인터페이스</li><li>Component 에서 Module 을 Activity 에 Inject 시켜주는 일을 간단히 하게 해준다.</li></ul></li></ul><ul><li>Dagger 에서는 항상 “객체” 를 Provide 하고, “객체” 를 Inject 해서 사용한다</li></ul>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/11/20/Develop-Programming-kotlin-2019-11-20-android-dagger/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Android] Retrofit 으로 서버-앱 통신 구현하기</title>
      <link>https://taeyeonkim93.github.io/2019/11/20/Develop-Programming-kotlin-2019-11-20-android-network/</link>
      <guid>https://taeyeonkim93.github.io/2019/11/20/Develop-Programming-kotlin-2019-11-20-android-network/</guid>
      <pubDate>Wed, 20 Nov 2019 04:57:47 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;안드로이드 앱에서 서버-앱 통신으로 가장 많이 쓰이고, 가장 편하게 사용할 수 있는 프레임워크가 Retrofit 이다.&lt;br&gt;사용법은 간단하지만 각자 사용하는 방식이 달라 깔끔하게 정의하고 사용할 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;클라이언트의 입장에
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>안드로이드 앱에서 서버-앱 통신으로 가장 많이 쓰이고, 가장 편하게 사용할 수 있는 프레임워크가 Retrofit 이다.<br>사용법은 간단하지만 각자 사용하는 방식이 달라 깔끔하게 정의하고 사용할 수 있도록 한다.</p><p>클라이언트의 입장에서만 기록한다.</p><h3 id="준비사항"><a href="#준비사항" class="headerlink" title="준비사항"></a>준비사항</h3><ul><li><p>\interface\Constant 에 들어갈 내용 :<br>BASE URL(연결할 사이트의 URL, 뒤에 꼭 “/“ 붙여야함), API KEY, USER KEY 등</p></li><li><p>manifest 에 Internet Permission 취득</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Rest API 에 사용되는 Request 함수 내용 정의</p></li></ul><h3 id="1-Retrofit-객체-생성"><a href="#1-Retrofit-객체-생성" class="headerlink" title="1. Retrofit 객체 생성"></a>1. Retrofit 객체 생성</h3><ul><li><p>Retrofit 의 각종 기능들을 사용하기 위해 Retrofit 객체를 생성한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* \model\ApiManager 폴더 생성</span></span><br><span class="line"><span class="comment">* \model\ApiService 인터페이스를 만들어서</span></span><br><span class="line"><span class="comment">  다른 model 함수에서 통신함수를 만들 뼈대를 만들어준다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ApiManager &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseURL(Constant.BASE_URL)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        <span class="comment">// Json 객체 &lt;-&gt; Java 객체 </span></span><br><span class="line">        <span class="comment">// 직렬화를 해주는 Gson Converter 라이브러리 추가</span></span><br><span class="line">        .build()</span><br><span class="line">        <span class="comment">// 빌더 패턴을 사용해서 각 인자들을 정의함</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Main Activity 사용 예시 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> client : ApiService? = ApiManager.retrofit.create(ApiService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="comment">// retrofit 객체 생성</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>추가사항으로 retrofit 객체 생성시 <code>.client(httpClient.build())</code> 를 붙여 로그를 확인 가능하다.</p></li><li><p>addHeader를 통해 api key 추가도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * API 통신 로그 확인 및 고정 헤더 추가용</span></span><br><span class="line"><span class="comment"> * 사용시 Retrofit builder에 .client(httpClient.build()) 추가</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HttpInterceptor</span><span class="params">()</span></span>: OkHttpClient.Builder &#123;</span><br><span class="line">    <span class="keyword">val</span> logging = HttpLoggingInterceptor()</span><br><span class="line">    logging.level = HttpLoggingInterceptor.Level.BODY</span><br><span class="line">    <span class="comment">// 로그 레벨 정의</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> httpClient = OkHttpClient.Builder()</span><br><span class="line">    httpClient.addInterceptor(Interceptor</span><br><span class="line">    &#123; chain -&gt;</span><br><span class="line">        <span class="keyword">val</span> original = chain.request()</span><br><span class="line">        <span class="keyword">val</span> request = original.newBuilder()</span><br><span class="line">            .addHeader(<span class="string">"x-api-key"</span>, Constant.API_KEY)</span><br><span class="line">            .build()</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@Interceptor</span> chain.proceed(request)</span><br><span class="line">    &#125;)</span><br><span class="line">        <span class="comment">// 매 신호 송수신마다 헤더 추가</span></span><br><span class="line">        .addInterceptor(logging)</span><br><span class="line">        <span class="comment">// 로그 인터셉터 추가</span></span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">return</span> httpClient</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-GET-POST-DELETE-등의-Rest-API-클래스-생성"><a href="#2-GET-POST-DELETE-등의-Rest-API-클래스-생성" class="headerlink" title="2. GET/POST/DELETE 등의 Rest API 클래스 생성"></a>2. GET/POST/DELETE 등의 Rest API 클래스 생성</h3><ul><li>Retrofit 객체를 가지고 통신을 하기위해 Rest API 가 정의되어있어야 한다.</li><li>ApiService 라는 Class를 만들어 내부 내용을 정의해준다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span></span>&#123;    </span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"lectures"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLectures</span><span class="params">()</span></span> : Call&lt;LecturesResponseModel&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BASE_URL/lectures&amp;code="" 형식으로 들어간다</span></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"lectures"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLectureByCode</span><span class="params">(<span class="meta">@Query(<span class="meta-string">"code"</span>)</span> code : <span class="type">String</span>)</span></span> : Call&lt;LecturesResponseModel&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(<span class="meta-string">"timetable"</span>)</span> </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addLecture</span><span class="params">(<span class="meta">@Body</span> addLectureBody: <span class="type">HashMap</span>&lt;<span class="type">String</span>,Any&gt;)</span></span> : Call&lt;JsonElement&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DELETE(<span class="meta-string">"timetable"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteLecture</span><span class="params">(<span class="meta">@Body</span> deleteLectureBody: <span class="type">HashMap</span>&lt;<span class="type">String</span>,Any&gt;)</span></span> : Call&lt;JsonElement&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"memo"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMemoByCode</span><span class="params">(<span class="meta">@Query(<span class="meta-string">"user_key"</span>)</span> userKey : <span class="type">String</span>?,<span class="meta">@Query(<span class="meta-string">"code"</span>)</span> code : <span class="type">String</span>?)</span></span> : Call&lt;MemoResponseModel&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-data-model-정의"><a href="#3-data-model-정의" class="headerlink" title="3. data model 정의"></a>3. data model 정의</h3><ul><li>Request 및 Response에 필요한 data model 을 정의해준다.</li><li>kotlin 에는 data class 를 사용한다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LecturesResponseModel</span></span>(</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName(<span class="meta-string">"Items"</span>)</span></span><br><span class="line">    <span class="keyword">val</span> lectures: List&lt;LecturesModel&gt;? = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName(<span class="meta-string">"Count"</span>)</span></span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span>? = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName(<span class="meta-string">"ScannedCount"</span>)</span></span><br><span class="line">    <span class="keyword">val</span> scannedCount: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/11/20/Develop-Programming-kotlin-2019-11-20-android-network/#disqus_thread</comments>
    </item>
    
    <item>
      <title>디자인 패턴 정리</title>
      <link>https://taeyeonkim93.github.io/2019/11/19/Develop-CS-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-2019-11-19-design-pattern/</link>
      <guid>https://taeyeonkim93.github.io/2019/11/19/Develop-CS-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-2019-11-19-design-pattern/</guid>
      <pubDate>Tue, 19 Nov 2019 11:15:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;디자인-패턴&quot;&gt;&lt;a href=&quot;#디자인-패턴&quot; class=&quot;headerlink&quot; title=&quot;디자인 패턴&quot;&gt;&lt;/a&gt;디자인 패턴&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;소프트웨어를 개발 할 때 특정 맥락에서 자주 발생하는 고질적인 문제들에&lt;br&gt;재사용 할
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="디자인-패턴"><a href="#디자인-패턴" class="headerlink" title="디자인 패턴"></a>디자인 패턴</h2><ul><li>소프트웨어를 개발 할 때 특정 맥락에서 자주 발생하는 고질적인 문제들에<br>재사용 할 수 있는 훌륭한 해결책</li><li>패턴?<ul><li>각기 다른 소프트웨어 모듈에는 서로 공통되는 설계 문제가 존재하며<br>이를 처리하는 해결책도 공통점이 있다. 이러한 유사점을 패턴이라 한다</li></ul></li></ul><h2 id="디자인-패턴-종류"><a href="#디자인-패턴-종류" class="headerlink" title="디자인 패턴 종류"></a>디자인 패턴 종류</h2><ul><li><p>GoF(Gang of Four) 디자인 패턴</p><ul><li>에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides)</li></ul><p><a href="http://blog.naver.com/PostView.nhn?blogId=2feelus&amp;logNo=220642212134&amp;redirect=Dlog&amp;widgetTypeCall=true" rel="external nofollow noopener noreferrer" target="_blank">http://blog.naver.com/PostView.nhn?blogId=2feelus&amp;logNo=220642212134&amp;redirect=Dlog&amp;widgetTypeCall=true</a></p></li><li><p>생성 패턴 </p><ul><li>객체 생성에 관련된 패턴</li><li>객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도<br>프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.<ul><li>추상 팩토리 패턴<ul><li>서로 연관되거나 의존적인 객체들을 합쳐서 하나의 객체로 만들 수 있게 해주는 패턴</li></ul></li><li>빌더 패턴  </li><li>팩토리 메서드 패턴 </li><li>싱글톤 패턴 <ul><li>생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴</li></ul></li></ul></li></ul></li></ul><ul><li>구조 패턴<ul><li>클래스나 객체를 조합해 더 큰 구조를 만드는 패턴<ul><li>어댑터 패턴  </li><li>브리지 패턴  </li><li>컴포지트 패턴  </li><li>데코레이터 패턴 </li><li>파사드 패턴   </li><li>프록시 패턴   </li><li>플라이웨이트 패턴</li></ul></li></ul></li></ul><ul><li>행위패턴 <ul><li>객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴</li><li>한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지,<br>객체 사이의 결합도를 어떻게 최소화하는지<ul><li>책임 연쇄 패턴  </li><li>반복자 패턴  </li><li>중재자 패턴  </li><li>전략 패턴  </li><li>커맨드 패턴  </li><li>방문자 패턴  </li><li>인터프리터 패턴  </li><li>메멘토 패턴  </li><li>옵저버 패턴  </li><li>상태 패턴  </li><li>템플릿 메소드 패턴  </li><li>널 오브젝트 패턴</li></ul></li></ul></li></ul><ul><li>동시성 패턴<ul><li>반응자 패턴(Reactor Pattern)</li></ul></li></ul><h2 id="디자인-패턴-상세"><a href="#디자인-패턴-상세" class="headerlink" title="디자인 패턴 상세"></a>디자인 패턴 상세</h2><ol><li>빌더 패턴</li></ol><p>객체를 생성할때 흔하게 사용하는 패턴이다.<br>자바로 코딩할 때 다음과 같은 스타일로 객체를 생성하는 코드가 있다면, 빌더 패턴을 사용했다고 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Member customer = Member.build()</span><br><span class="line">    .name(<span class="string">"홍길동"</span>)</span><br><span class="line">    .age(<span class="number">30</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>자바에서는 다음과 같이 매개변수를 받아 객체를 생성할 수 있다. (빌더패턴 미적용)</p><ul><li>점층적 생성자 패턴<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(a, b, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(a, b, c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.d = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>다만 이렇게 적용하면 너무 가독성이 떨어지므로 다음과 같이 패턴화한다.</p><ul><li>빌더 패턴<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setA</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            a = v;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setB</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            b = v;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setC</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            c = v;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setD</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            d = v;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Car(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Car 객체로 return 하기위한 Car 생성자를 생성함</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Car</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        a = builder.a;</span><br><span class="line">        b = builder.b;</span><br><span class="line">        c = builder.c;</span><br><span class="line">        d = builder.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car.Builder()</span><br><span class="line">        .setA(<span class="number">1</span>)</span><br><span class="line">        .setB(<span class="number">2</span>)</span><br><span class="line">        .setC(<span class="number">1</span>)</span><br><span class="line">        .setD(<span class="number">2</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>코틀린에선 클래스를 정의하면서 사용할 수 있는<br>data class가 있으므로 굳이 빌더패턴을 만들 필요가 없다.</p><ol start="2"><li>팩토리 패턴</li></ol><p>클래스의 인스턴스를 생성할때 바로 new 를 써서 생성하지 않고 new Instance() 를 써서 만든다.</p><ul><li>팩토리 메소드 패턴<ul><li>객체를 생성하기 위한 인터페이스를 정의할때, 어떤 클래스의 인터페이스를 만들지는 서브 클래스에서 결정한다.</li></ul></li></ul><ul><li>추상 팩토리 패턴<ul><li>인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다.</li><li>추상 팩토리 패턴에는 팩토리 메소드 패턴이 포함될 수 있다.</li></ul></li></ul><ul><li>추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하지 않도록 만든다 에 기안한 패턴이다.</li></ul><ul><li>필요한 것<ol><li>객체를 만들기위한 interface (없어도 됨)</li><li>위의 interface 를 기반으로 한 객체 클래스 </li><li>객체 클래스를 선택하기 위한 팩토리 클래스 (서브클래스)</li><li>메인 클래스 (서브클래스를 이용해 객체클래스를 선택하기위함)</li></ol></li></ul><ol start="3"><li>반응자패턴 (reactor pattern)</li></ol><p>이벤트 핸들 패턴의 전형적인 모습이다.</p><ul><li>이벤트 핸들링을 위한 객체들을 초기화(Initiate)하고,</li><li>여러 통로에서 들어오는 이벤트들을 수신(Receive)하고,</li><li>이벤트들을 대응할 객체별로 분할 (Demultiplex)하고,</li><li>객체에게 이벤트를 발송(dispatch)해서,</li><li>그 객체가 이벤트에 걸맞는 작업을 수행(process events) 한다. </li></ul>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/11/19/Develop-CS-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-2019-11-19-design-pattern/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Android] 안드로이드 이슈 정리</title>
      <link>https://taeyeonkim93.github.io/2019/11/04/Develop-Programming-kotlin-2019-11-04-android-issue/</link>
      <guid>https://taeyeonkim93.github.io/2019/11/04/Develop-Programming-kotlin-2019-11-04-android-issue/</guid>
      <pubDate>Mon, 04 Nov 2019 11:13:23 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;앱 개발 도중 기억하고 싶은 이슈를 적는 곳&lt;/p&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#안드로이드-용어-정리&quot;&gt;안드로이드 용어 정리&lt;/a&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>앱 개발 도중 기억하고 싶은 이슈를 적는 곳</p><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><p><a href="#안드로이드-용어-정리">안드로이드 용어 정리</a><br><a href="#안드로이드-생애주기">안드로이드 생애주기</a><br><a href="#Java와-Kotlin이-다른점">Java와 Kotlin이 다른점</a><br><a href="#정적-변수-및-메서드-사용하기">정적 변수 및 메서드 사용하기</a><br><a href="#함수-리턴형-숨기기">함수 리턴형 숨기기</a><br><a href="#Gradle-꿀팁">Gradle 꿀팁</a></p><h3 id="안드로이드-용어-정리"><a href="#안드로이드-용어-정리" class="headerlink" title="안드로이드 용어 정리"></a><a href="#목차">안드로이드 용어 정리</a></h3><p>어렴풋이 알고 있었던 안드로이드의 용어들을 정리한다.</p><ul><li><p>Activity (액티비티)</p><ul><li>애플리케이션 구성요소 중 “화면” 을 제공하는 단어</li><li>주로 화면에 보이는 UI와 상호작용할 수 있는 화면을 제공한다.</li></ul></li><li><p>Interface (인터페이스)</p><ul><li>함수들의 묶음을 정의해두기 위해 만든 개념</li><li>내부의 함수들은 다른 Class에서 정의한다.</li></ul></li><li><p>boilerplate code(보일러 플레이트 코드)</p><ul><li><p>표준 문안이라는 뜻의 단어</p></li><li><p>꼭 필요하지만 반복적이고 중복이 많아 코드가 길어져 불편하다.</p></li><li><p>최소한의 변경으로 재사용할 수 있는 것</p></li><li><p>적은 수정만으로 여러 곳에 활용 가능한 코드, 문구</p></li><li><p>각종 문서에서 반복적으로 인용되는 문서의 한 부분</p></li></ul></li><li><p>Annotation (애노테이션)</p><ul><li>메타데이터 클래스</li><li>@를 붙여 다른 클래스나 메소드, 필드, 다른 애노테이션과 결합되어 사용</li><li>추가적인 정보를 제공하는 대안이 됨</li><li>애노테이션을 활용하면 코드가 컴파일시간에 생성되므로<br>보일러 플레이트 코드를 줄일 수 있다.</li></ul></li></ul><ul><li>DAO (Data Access Object)<ul><li>Database 의 data 에 접근을 하기 위한 객체</li><li>DB에 접근을 하기위한 로직과, 비즈니스 로직을 분리하기 위해서 사용함</li></ul></li></ul><ul><li>DTO (Data Transfer Object)<ul><li>(Value Object 와 같음) 계층간 데이터 교환을 위한 Java Beans 를 말함</li><li>로직을 갖고 있지 않는 순수한 데이터 객체이며 속성과 그 속성에 접근하기위한 클래스</li><li>주로 getter, setter 이 적힌 클래스</li></ul></li></ul><h3 id="안드로이드-생애주기"><a href="#안드로이드-생애주기" class="headerlink" title="안드로이드 생애주기"></a><a href="#목차">안드로이드 생애주기</a></h3><p>어렴풋이 알고 있었던 안드로이드의 생애주기를 정리한다.</p><ul><li>안드로이드 시스템은 어느 특정한 main() 함수가 없다.</li><li>Activity 를 초기화하고, 여기에 있는 콜백 함수들이 호출되게 한다.<ul><li>맨 처음 앱을 누르면 Manifest 에 MAIN 으로 지정된 Activity 내의 onCreate() 함수가 실행된다.</li></ul></li></ul><p><img src="/images/android-issue/Lifecycle.png" alt></p><p>Lifecycle에 따른 기본적인 기능만 정리한다.</p><ol><li><p>onCreate()</p><ul><li>Activity 를 처음 실행할 때 딱 한번만 호출된다.</li><li>딱 한번만 발생하는 로직을 담아야 하므로 <code>변수초기화</code>, <code>클래스 인스턴스화</code> 등의 작업을 한다.</li></ul></li><li><p>onStart()</p><ul><li>onCreate()가 실행된 이후에 호출된다.</li><li>Activity 가 Foreground에 나오기 전에 수행되므로 UI를 관리하는 코드를 작성한다.</li></ul></li><li><p>onRestart()</p><ul><li>onStart()와는 달리 앱이 실행될때는 실행되지 않는다.</li><li>onStop() -&gt; onRestart() 일때만 실행된다.</li></ul></li><li><p>onResume()</p><ul><li>onStart()가 수행된 이후에 호출된다.</li><li>Activity에 포커스가 맞춰져있는동안 onResume()의 상태가 유지된다.</li><li>앱이 포커스를 되찾으면 onPause()를 거쳐 onResume()이 다시 수행될 수 있다.</li><li>대부분의 자주 사용하는 메소드(새로고침 후에 사용되는)를 적는다.</li></ul></li><li><p>onPause()</p><ul><li>Activity의 포커스가 다른곳으로 이동하면 호출된다.</li><li>앱을 종료하는것 뿐만아니라 일시적인 포커스 이동에도 수행된다.</li><li>메모리나 배터리 소모를 일으키는 자원을 해제하는 로직을 구현한다.</li><li>onResume()이 했던 작업들을 저장하거나 멈추게 한다.</li><li>Activity가 다시 재개되면 onResume()이 다시 수행된다.</li></ul></li><li><p>onStop()</p><ul><li>onPause() 이후 단계로 액티비티가 활동을 중지한 상태이다.</li><li>대부분의 자원을 해제해야한다.</li><li>이후에 Activity가 재개되면 onRestart()를 통해 onStart()를 실행한다.</li></ul></li><li><p>onDestroy()</p><ul><li>앱이 종료되는 최종단계로 모든 리소스를 해제한다.</li></ul></li></ol><h5 id="Activity-수행-예시"><a href="#Activity-수행-예시" class="headerlink" title="Activity 수행 예시"></a>Activity 수행 예시</h5><ol><li>앱을 실행했을때<ul><li>onCrate() -&gt; onStart() -&gt; onResume()</li></ul></li><li>Activity 1에서 Activity 2를 생성했을때<ul><li>Activity 1 : onPause() -&gt; onStop()</li><li>Activity 2 : onCreate() -&gt; onStart() -&gt; onResume()</li></ul></li><li>Activity 2를 종료하고 1로 돌아왔을때<ul><li>onRestart() -&gt; onStart() -&gt; onResume()</li></ul></li><li>홈키를 눌러서 백그라운드로 전환됐을 때<ul><li>onPause() -&gt; onStop()</li></ul></li><li>다시 돌아왔을 때<ul><li>onRestart() -&gt; onStart() -&gt; onResume()</li></ul></li><li>앱을 종료할 때<ul><li>onPause() -&gt; onStop() -&gt; onDestroy()</li></ul></li></ol><h3 id="5-Java와-Kotlin이-다른점"><a href="#5-Java와-Kotlin이-다른점" class="headerlink" title="5. Java와 Kotlin이 다른점"></a><a href="#목차">5. Java와 Kotlin이 다른점</a></h3><ul><li>상속<ul><li>생성자가 있는 class를 상속했을때는 무조건 생성자를 받아야 한다.</li><li>Extends <ul><li>부모 클래스에서 선언/정의를 모두 하고 자식은 그대로 사용만 할수 있게 상속하는 명령어</li><li>코틀린에선 Extends나 Implements나 콜론으로 통일함</li></ul></li><li>Implements<ul><li>부모 클래스에서 선언만 하며 정의는 자식 클래스에서 오버라이드하도록 상속시키는 명령어</li><li>코틀린에선 Extends나 Implements나 콜론으로 통일함</li></ul></li><li>Abstract<ul><li>extends로 사용하지만 abstract로 선언된 클래스는 interface도 가질 수 있음</li></ul></li><li>Super / this<ul><li>super은 상위 클래스에서 멤버변수/메소드를 가져옴</li><li>this는 현재 클래스에서 멤버변수/메소드를 가져옴</li></ul></li></ul></li></ul><ul><li><p>Java에서 생성자 사용하는 방법</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testClass</span> </span>&#123;</span><br><span class="line">    String example;</span><br><span class="line">    testClass(String example2)&#123;</span><br><span class="line">        <span class="keyword">this</span>.example = example2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>생성자를 따로 만들어서 내부변수를 this로 선언해서 매개변수를 받아야 한다.</li></ul></li></ul><ul><li><p>Kotlin에서 생성자 사용하는 방법</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span></span>(<span class="keyword">var</span> example: String)&#123;</span><br><span class="line">    println(<span class="string">"매개변수 : <span class="variable">$example</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 부를때</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass2</span></span>(example2 : String) : testClass(example2) &#123;</span><br><span class="line">    println(<span class="string">"example2 를 매개변수로 testClass를 상속받음"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span></span>(num : <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> example : String = <span class="string">""</span></span><br><span class="line">    <span class="keyword">constructor</span>(example2 : String, num : <span class="built_in">Int</span>) : <span class="keyword">this</span>(num)&#123; </span><br><span class="line">        <span class="comment">// 기본 생성자를 상속받아야 한다.</span></span><br><span class="line">        <span class="keyword">this</span>.example = example2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>생성자는 <code>(var example: String)</code> 이고, 따로 변수 선언없이 바로 사용 가능하다.</li><li><code>constructor()</code> 함수를 사용하면 추가적으로 매개변수를 받아서 사용할 수 있다.</li><li>인터페이스는 class로 상속받을경우 내부에 있는 모든 함수를 override 해야 한다.</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dagger2 + constructor 예시</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainInteractor</span></span></span><br><span class="line"><span class="meta">@Inject</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> questionRepoHelper: QuestionRepo,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> optionsRepoHelper: OptionsRepo,</span><br><span class="line">        preferenceHelper: PreferenceHelper,</span><br><span class="line">        apiHelper: ApiHelper</span><br><span class="line">)  : BaseInteractor(</span><br><span class="line">        preferenceHelper = preferenceHelper,</span><br><span class="line">        apiHelper = apiHelper</span><br><span class="line">), MainMVPInteractor &#123;</span><br></pre></td></tr></table></figure><ul><li>BaseInteractor 을 상속받기위해 인자인 preferenceHelper, apiHelper 를 생성자로 받아야함</li><li>MainMVPInteractor 는 interface 이므로 그냥 상속</li><li>questionRepoHelper 는 클래스 내부에서 사용하기 위한 객체이므로 선언</li><li>optionRepoHelper 는 클래스 내부에서 사용하기 위한 객체이므로 선언</li></ul><ul><li>Java에서는 매개변수자리에 … 을 사용하면 varargs, 가변인자가 된다.</li></ul><h3 id="정적-변수-및-메서드-사용하기"><a href="#정적-변수-및-메서드-사용하기" class="headerlink" title="정적 변수 및 메서드 사용하기"></a><a href="#목차">정적 변수 및 메서드 사용하기</a></h3><ul><li><p>정적 변수를 사용하면 <code>[클래스명].[함수명]</code>혹은 <code>[클래스명].[상수명]</code><br>등으로 활용 가능하다.</p></li><li><p>사용처</p><ul><li>액티비티/프래그먼트의 인텐트 Extra로 사용하는 키</li><li>로그 출력을 위한 태그(Tag) 이름 정의</li><li>뷰 내부에서 사용하는 고정된 길이 값 (너비, 높이 등)</li><li>각종 유틸리티 클래스 내 메서드</li></ul></li><li><p>사용법</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * object(오브젝트) 기본 정의</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Foo1 &#123;</span><br><span class="line">    <span class="keyword">val</span> BAR1 = <span class="string">"bar1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * companion object를 이용한 정의</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> BAR2 = <span class="string">"bar2"</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Main Activity에서 object 호출</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object 정의된 BAR1 호출</span></span><br><span class="line">    <span class="keyword">val</span> str = Foo1.BAR1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Foo.baz() 함수 호출</span></span><br><span class="line">    Foo2.baz()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>코틀린에서는 <code>object</code>를 이용해서 클래스를 정의함과 동시에<br>객체를 생성할 수 있다<ul><li><code>Foo1</code>라는 이름을 가진 객체를 생성한 싱글턴 패턴으로 봐도 무방하다</li></ul></li><li><code>companion object</code> 를 이용하면 class 내부에 선언된 private property에<br> 접근 가능하다</li><li>익명 클래스를 구현할때도 <code>object</code>를 이용한다.<ul><li>익명 클래스 설명은 <a href="https://yookeun.github.io/java/2017/01/24/java-anonymousclass/" rel="external nofollow noopener noreferrer" target="_blank">익명클래스 사용방법</a> 참조<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 익명 클래스 구현</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>)</span></span> &#123; </span><br><span class="line">    setClickAction(<span class="keyword">object</span> : ClickListener &#123;     </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> &#123; </span><br><span class="line">            println(<span class="string">"clicked!!!"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setClickAction</span><span class="params">(clickListener: <span class="type">ClickListener</span>)</span></span> &#123;</span><br><span class="line">    clickListener.onClick() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="Gradle-꿀팁"><a href="#Gradle-꿀팁" class="headerlink" title="Gradle 꿀팁"></a><a href="#목차">Gradle 꿀팁</a></h3><ul><li><p>Project 영역 gradle 에서 ext 를 선언하면 gradle 내에서 편하게 쓸 수 있다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Project 영역</span></span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    <span class="comment">// Sdk and tools</span></span><br><span class="line">    minSdkVersion = <span class="number">19</span></span><br><span class="line">    targetSdkVersion = <span class="number">29</span></span><br><span class="line">    compileSdkVersion = <span class="number">29</span></span><br><span class="line">    buildToolsVersion = <span class="string">"29.0.2"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// App dependencies</span></span><br><span class="line">    kotlinVersion = kotlinVersion</span><br><span class="line">    constraintLayoutVersion = <span class="string">"1.1.3"</span></span><br><span class="line">    appCompatVersion = <span class="string">"1.1.0"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="comment">// Module 영역</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// kotlin</span></span><br><span class="line">    implementation<span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlinVersion"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// android support libraries</span></span><br><span class="line">    implementation <span class="string">"androidx.appcompat:appcompat:$rootProject.ext.appCompatVersion"</span></span><br><span class="line">    implementation <span class="string">"androidx.constraintlayout:constraintlayout:$rootProject.ext.constraintLayoutVersion"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dependency injection</span></span><br><span class="line">    implementation <span class="string">"com.google.dagger:dagger:$rootProject.ext.daggerVersion"</span></span><br><span class="line">    implementation <span class="string">"com.google.dagger:dagger-android-support:$rootProject.ext.daggerVersion"</span></span><br><span class="line">    kapt <span class="string">"com.google.dagger:dagger-compiler:$rootProject.ext.daggerVersion"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Project 영역 내 android - buildType 에 통신관련 내용을 적으면 안전하게 build 할수 있다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">         debug &#123;</span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"BASE_URL"</span>, <span class="string">"\"http://www.mocky.io/v2\""</span>)</span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"API_KEY"</span>, <span class="string">"\"ABCXYZ123TEST\""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"BASE_URL"</span>, <span class="string">"\"http://www.mocky.io/v2\""</span>)</span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"API_KEY"</span>, <span class="string">"\"ABCXYZ123TEST\""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="함수-리턴형-숨기기"><a href="#함수-리턴형-숨기기" class="headerlink" title="함수 리턴형 숨기기"></a><a href="#목차">함수 리턴형 숨기기</a></h3><p>코틀린에서는 함수가 return 할때 간단하게 쓸 수 있는 방법이 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = content</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/11/04/Develop-Programming-kotlin-2019-11-04-android-issue/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Kotlin] 코틀린 함수 정리</title>
      <link>https://taeyeonkim93.github.io/2019/10/21/Develop-Programming-kotlin-2019-10-21-kotlin-function/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/21/Develop-Programming-kotlin-2019-10-21-kotlin-function/</guid>
      <pubDate>Mon, 21 Oct 2019 12:17:52 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;그때그때 모르는 함수 있으면 정리해서 올리는 용도&lt;/p&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#1-when&quot;&gt;when&lt;/a&gt;&lt;br&gt;&lt;a hr
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>그때그때 모르는 함수 있으면 정리해서 올리는 용도</p><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><p><a href="#1-when">when</a><br><a href="#2-callback">Callback</a><br><a href="#3-data-class">Data Class</a><br><a href="#4-lateinit-lazy">lateinit, lazy</a><br><a href="#5-public-private-internal-protected">public, private, internal, protected</a><br><a href="#6-generic-type">Generic Type</a><br><a href="#7-let">Let</a></p><h4 id="1-when"><a href="#1-when" class="headerlink" title="1. when"></a><a href="#목차">1. when</a></h4><ul><li>일반 C같은 곳에서 사용되던 Switch문을 대체함</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; </span><br><span class="line">        print(<span class="string">"x is neither 1 nor 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>보통 Switch의 default는 필수가 아니지만 Kotlin의 When은 else문이 필수로 들어가야 한다.</li><li>많은 경우가 동시에 처리되야하면 콤마를 사용한다</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>각 조건에 상수가 아닌 함수가 올 수도 있다</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    parseInt(s) -&gt; print(<span class="string">"s encodes x"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"s does not encode x"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>in을 사용하면 범위를 지정할 수 있다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">    <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">"x is valid"</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br></pre></td></tr></table></figure><ul><li>인수를 생략해서 사용도 가능하다. 이 경우 해당 조건이 참일 경우에만 분기문이 실행된다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">    x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-callback"><a href="#2-callback" class="headerlink" title="2. callback"></a><a href="#목차">2. callback</a></h4><p>콜백함수는 늘 봐도봐도 헷갈린다.</p><p>코틀린에서 콜백함수를 만들고 사용하는 법을 정리한다.</p><ul><li>사용법<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> [함수명] <span class="params">(callback: ([변수 자료형]) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    callback(변수명)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>콜백함수 문법은 특정 함수의 동작이 끝남과 동시에, 다른 여러 가지 함수를 호출해야 할 경우에 사용된다.</p><p>Unit 형으로 변수가 Return 되어 다시 위에 선언한 변수의 자료형으로 변환된다.<br>쓰다보면 다중으로 콜백을 해야하는 상황이 생기는데, 이런 경우를 없애는 방법을 찾고싶다.</p><h4 id="3-data-class"><a href="#3-data-class" class="headerlink" title="3. data class"></a><a href="#목차">3. data class</a></h4><p>코틀린에서 data Class를 이용하면 자바에서 만들어야했던</p><p> <code>GET, SET, ToString, Copy</code></p><p>등의 간단한 함수들을 자동으로 구현해준다.</p><ul><li>사용법<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LecturesResponseModel</span></span>(</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lectures: List&lt;LecturesModel&gt;? = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span>? = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> scannedCount: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>주로 Model들의 정의를 할 때 사용한다.<br>소괄호로 이루어져있으므로 쉼표를 붙이며 주의해서 사용해야 한다.</p><h4 id="4-lateinit-lazy"><a href="#4-lateinit-lazy" class="headerlink" title="4. lateinit, lazy"></a><a href="#목차">4. lateinit, lazy</a></h4><ul><li><p><strong>lateinit</strong></p></li><li><p>프로퍼티의 초기화를 나중에 하기 위한 키워드이다.</p></li><li><p>반드시 null이 아닌 변수가 생성당시가 아닌 나중에 초기화를 해야할 때 사용한다.</p></li><li><p>제약사항</p><ul><li>var(mutable) 프로퍼티만 사용 가능</li><li>non-null 프로퍼티만 사용 가능</li><li>커스텀 getter/setter가 없는 프로퍼티만 사용 가능</li><li>primitive type 프로퍼티는 사용 불가능</li><li>클래스 생성자에서 사용 불가능</li><li>로컬 변수로 사용 불가능</li></ul></li></ul><ul><li><p>DI에서 사용하는 경우</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> presenter: SimpleSignInPresenter</span><br></pre></td></tr></table></figure></li><li><p>DI를 통해 <code>SimpleSignInPresenter</code>를 외부에서 주입받기 때문에<br>별도로 해당 프로퍼티에 명시적으로 <code>null</code>을 대입하지 않는 이상<br><code>Non-null</code>이라고 확신할 수 있다.</p></li></ul><ul><li><p><strong>lazy</strong></p></li><li><p>프로퍼티의 초기화를 나중에 하기 위한 함수이다.</p></li><li><p><code>lateinit</code>은 <code>Modifier</code>이지만 <code>lazy</code>는<br>람다를 파라미터로 받고 <code>Lazy&lt;T&gt;</code> 인스턴스를 반환하는 함수다.</p></li><li><p>제약사항</p><ul><li>val(immutable) 프로퍼티만 사용 가능</li><li>primitive type 에도 사용 가능</li><li>커스텀 getter/setter가 없는 프로퍼티만 사용 가능</li><li>Non-null, Nullable 둘다 사용 가능</li><li>클래스 생성자에서 사용 불가능</li><li>로컬 변수에서 사용 가능</li></ul></li><li><p>사용법</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> toolbar <span class="keyword">by</span> lazy &#123; home_toolbar &#125;</span><br></pre></td></tr></table></figure></li><li><p>lazy 프로퍼티 연산은 기본적으로 동기화된다.</p><ul><li>Thread-safe 하다</li><li>기본적으로 UNINITIALIZED_VALUE 로 초기화되고 value 호출이 일어날 때 다시 초기화된다.</li></ul></li><li><p>lazy 를 사용하면 activity가 올라온 후에 초기화 할 수 있다.</p></li></ul><h4 id="5-public-private-internal-protected"><a href="#5-public-private-internal-protected" class="headerlink" title="5. public, private, internal, protected"></a><a href="#목차">5. public, private, internal, protected</a></h4><ul><li>가시성 제한자이다.</li><li>kotlin 은 명시적으로 제한자를 지정하지 않으면 public 가시성을 갖는다.</li></ul><ul><li>패키지 레벨에서 가시성 제한자에 따른 접근 범위<ul><li>public : 모든 곳에서 해당 선언에 접근할 수 있다.</li><li>private : 해당 선언을 포함한 파일 내에서만 접근할 수 있다.</li><li>internal : 같은 모듈 안에서 접근할 수 있다.</li><li>protected : 최상위 레벨 선언에서는 protected를 사용할 수 없다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// example.kt에서만 접근 가능 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bar: <span class="built_in">Int</span> = <span class="number">5</span> <span class="comment">// 프로퍼티는 모든 곳에서 접근 가능</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">// setter는 example.kt에서만 접근 가능 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> baz = <span class="number">6</span> <span class="comment">// 같은 모듈 안에서 접근 가능</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>클래스, 인터페이스 레벨에서 가시성 제한자에 따른 접근 범위<ul><li>public : 선언한 클래스에 접근할 수 있는 모든 클라이언트가 public 멤버에 접근 가능하다.</li><li>private : (클래스의 모든 멤버를 포함한) 클래스 안에서만 접근 가능하다.</li><li>internal : 선언한 클래스에 접근할 수 있는 모듈에 속한 클라이언트가 internal 멤버에 접근 가능하다.</li><li>protected : private과 동일하지만 + 하위 클래스에서 접근 가능하다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">val</span> b = <span class="number">2</span> </span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> c = <span class="number">3</span></span><br><span class="line">  <span class="keyword">val</span> d = <span class="number">4</span> <span class="comment">// 기본으로 public</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> e: <span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> : <span class="type">Outer</span></span>() &#123;</span><br><span class="line">  <span class="comment">// a에 접근 불가</span></span><br><span class="line">  <span class="comment">//b,c 그리고 d에 접근 가능</span></span><br><span class="line">  <span class="comment">// Nested와 e에 접근 가능 </span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unrelated</span></span>(o: Outer) &#123;</span><br><span class="line">  <span class="comment">// o.a, o.b에 접근 불가</span></span><br><span class="line">  <span class="comment">// o.c(같은 모듈)와 o.d에 접근 가능</span></span><br><span class="line">  <span class="comment">// Outer.Nested에 접근 불가, 그리고 Nested::e에도 접근 불가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-generic-type"><a href="#6-generic-type" class="headerlink" title="6. generic type"></a><a href="#목차">6. generic type</a></h4><ul><li>제네릭 타입은 <strong>Type 을 Parameter 로 가지는 Class 나 Interface 를 말함</strong></li><li>클래스 또는 인터페이스 이름 뒤에 &lt;&gt; 부호가 붙고 사이에 타입 파라미터가 위치함</li></ul><ul><li>제네릭을 왜 쓰는가?<ul><li>컴파일 시 강한 Type Check 를 할수 있다.</li><li>타입 변환 (Casting) 을 제거한다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">String str = (String) list.get(<span class="number">0</span>); <span class="comment">// 타입 변환이 필요</span></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list2.add(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">String str2 = list.get(<span class="number">0</span>); <span class="comment">// 불필요</span></span><br></pre></td></tr></table></figure><ul><li><p>타입 파라미터는 일반적으로 대문자 알파벳 한 글자로 표현한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 클래스&lt;<span class="title">T</span>&gt; </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 인터페이스&lt;<span class="title">T</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>제네릭 타입은 두 개 이상의 멀티 파라미터를 이용할 수 있다. 이 경우 각 타입 파라미터는 콤마로 구분한다.</p></li></ul><ul><li>제네릭 메소드<ul><li>제네릭 메소드는 매개변수와 반환자료형의 Type 이 Type Parameter 를 갖는 메소드를 뜻함</li><li><code>public &lt;T&gt; [리턴Type] [메소드명] () {}</code>  이와같이 선언함</li><li><code>객체.&lt;T&gt;함수명</code> 이와같이 사용도 가능함. 함수의 리턴 타입을 명시하는 용도</li></ul></li></ul><h4 id="7-Let"><a href="#7-Let" class="headerlink" title="7. Let"></a><a href="#목차">7. Let</a></h4><ul><li>Let 함수를 호출하는 객체를 block 부분의 인자로 넘긴다.</li><li>block 의 결과를 반환한다.</li></ul><p><code>inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R) : R</code></p><ul><li>사용 예시<ul><li>널 체크후 코드 실행하고 싶을 경우</li><li>블록 내의 결과물을 반환하고 싶을 경우</li><li>단일 지역 변수의 범위를 제한하고 싶을 경우</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">blockTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">"park"</span>, <span class="string">"jieun"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = person?.let &#123;</span><br><span class="line">        printPerson(it.lastName + it.firstName)</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertEquals(result, <span class="string">"parkjieun"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">printPerson</span><span class="params">(msg: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    println(msg)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/21/Develop-Programming-kotlin-2019-10-21-kotlin-function/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[프로젝트] 안드로이드 앱 개발 구상</title>
      <link>https://taeyeonkim93.github.io/2019/10/15/Develop-Project-Android-2019-10-15-app-develop-project-1/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/15/Develop-Project-Android-2019-10-15-app-develop-project-1/</guid>
      <pubDate>Tue, 15 Oct 2019 11:54:02 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;개발자로써 커리어를 App 개발로 정했고, 시작으로 간단한 프로젝트를 진행한다.&lt;br&gt;이전에 앱 개발을 해본 경험을 바탕으로 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>개발자로써 커리어를 App 개발로 정했고, 시작으로 간단한 프로젝트를 진행한다.<br>이전에 앱 개발을 해본 경험을 바탕으로 프로토타입용 앱을 개발하려고 한다.</p><p>기획과 디자인, 개발 모두 1인으로 진행한다.<br>짧은 시간과 1인 프로젝트인 만큼 toy 프로젝트 형식으로 간단하게 개발한다.</p><h3 id="1-어떤-개발을-할-것인가"><a href="#1-어떤-개발을-할-것인가" class="headerlink" title="1. 어떤 개발을 할 것인가?"></a>1. 어떤 개발을 할 것인가?</h3><p>짧은 시간제한과 의미있는 프로젝트를 위해 몇 가지 고려해야할 사항이 있다.</p><ul><li>어떤 개발환경으로 진행할 것인가? (language, DB, logger, error handling..)</li><li>어떤 어플을 만들것인가?</li></ul><p>수익구조나 타겟층같은 내용도 고려해야 하지만 toy 프로젝트이므로 그런점은 감안하고 진행한다.</p><h5 id="어떤-개발환경으로-진행할-것인가"><a href="#어떤-개발환경으로-진행할-것인가" class="headerlink" title="어떤 개발환경으로 진행할 것인가?"></a>어떤 개발환경으로 진행할 것인가?</h5><ol><li><p>개발언어 : Kotlin</p><ul><li>2017 Google이 선정한 Android 대표 개발언어. 객체지향 언어라 기존 JAVA 개발과 흡사하며 코드가 간결하다.</li></ul></li><li><p>DB : SQLite</p><ul><li>Android 개발시에 사용할 DB. 마지막 개발한지 몇년이 지나서 아직도 이걸 쓰는지 모르겠다</li><li>Realm 도 검토예정</li></ul></li><li><p>Server : AWS</p><ul><li>$0.88 매달 내면서 이용중인 개인서버가 있다. 유저가 로컬만 사용하는 어플이 아니어서 회원가입, 로그인 등에 이용가능할듯</li></ul></li></ol><p>기타 사항은 만들면서 추가 예정</p><h4 id="어떤-어플을-만들-것인가"><a href="#어떤-어플을-만들-것인가" class="headerlink" title="어떤 어플을 만들 것인가?"></a>어떤 어플을 만들 것인가?</h4><p>1인개발의 장점을 살리기 위해서는 화려한 기능보다는 적은 기능에 집중하는게 좋다.<br>아이디어를 고민하던 중 친구의 도움을 받아 일정 관리 어플을 만들어보기로 했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;챙겼나요?&gt;</span><br><span class="line"></span><br><span class="line">- 특정 날짜를 지정해서 한줄메모를 계속 추가할 수 있음</span><br><span class="line">- 위젯으로 각 날자에 써놓은 항목을 배경화면이나 잠금화면 위에 띄울수있음</span><br><span class="line">- 각 항목을 클릭하면 삭제선그어짐</span><br><span class="line"></span><br><span class="line">ex)</span><br><span class="line">10월 18일</span><br><span class="line">- 우산(삭제선)</span><br><span class="line">- 대강당 교육 오후 2시</span><br><span class="line">- xx한테 돈보냄?(삭제선)</span><br><span class="line"></span><br><span class="line">앱은 기능이 많으면 안되고 최대한 단촐하게. 추가한다면 알람정도</span><br></pre></td></tr></table></figure><p><strong>일정 관리 어플 장점</strong></p><ul><li>구글 Keep 메모, MS 원노트, 에버노트, 리마인더 등 먼저 있었던 앱들을 참고할수 있다.</li><li>유저마다 원하는 일정 관리의 형태가 달라 특정 사용자층을 노릴 수 있다</li><li>간단하다</li><li>실생활에 접목하기 쉽다</li></ul><p><strong>일정 관리 어플 단점</strong></p><ul><li>시장에 비슷한 어플이 너무 많아 굳이 쓸 이유가 없다</li><li>너무…많다…</li></ul><p>기존 앱들을 사용해보고 불편했던점을 종합해서 요구사항으로 반영해보기로 했다.</p><h3 id="2-어플-기능-정리"><a href="#2-어플-기능-정리" class="headerlink" title="2. 어플 기능 정리"></a>2. 어플 기능 정리</h3><ul><li><p>요구사항 정의</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 메모가 가능해야함</span><br><span class="line">  - 가독성이 용이해야함</span><br><span class="line">  - 수정이 용이해야함 / 채팅형 방식도 고민중</span><br><span class="line">- 다음날짜로 넘어갈경우(24:00 이후) 안에 내용도 모두 다음날짜 내용으로 바뀌어야함</span><br><span class="line">- 위젯이 가능해야함. 4x2 ~ 5x5 대응</span><br><span class="line">  - 이전 날짜에 있던 모든 일정은 보이지 않아야함(기본)</span><br><span class="line">  - [메모 유지] Flag 가 On 되어있을경우 다음날짜로 일정이 넘어감 (선택)</span><br><span class="line"></span><br><span class="line">- 검색창에 내 할일을 찾으면 찾을 수 있어야함 (추가기능)</span><br><span class="line">- 리마인더, 구글캘린더와 연동이 가능해야함 (추가기능)</span><br><span class="line">  - 스마트워치와 연동가능해야함 (추가기능)</span><br><span class="line">- 백업이 가능해야함 (추가기능)</span><br><span class="line">- 잠금화면 위에 위젯이 올라와야함 (추가기능)</span><br><span class="line">- AOD 위로 올라와야함 (추가기능)</span><br><span class="line">- 알림이 가능해야함 (추가기능)</span><br></pre></td></tr></table></figure></li><li><p>기능 정의</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- 메인 화면 구현</span><br><span class="line">  - 메인화면 상단 달력 바 구현</span><br><span class="line">    - 날짜 클릭 시 해당 날짜의 일정 출현 기능 구현</span><br><span class="line">    - 이전 주 / 다음 주 슬라이드 이동 기능 구현</span><br><span class="line">    - 월 누르면 월 선택할수있는 박스 기능 구현</span><br><span class="line">    - 해당 월의 가장 뒤 날짜로 이동 기능 구현(이번달은 오늘날짜)</span><br><span class="line">    - # 아래 bar 클릭시 달력 출현 기능 구현 (추가기능)</span><br><span class="line"></span><br><span class="line">  - 메인화면 하단 일정 관리 화면 구현</span><br><span class="line">    - 체크박스 기능 구현 (체크할시 취소선)</span><br><span class="line">    - 우측에 휴지통 버튼 구현 (클릭시 일정 삭제)</span><br><span class="line">    - 최하단 메모 추가 버튼 구현 (클릭시 일정추가화면으로 이동)</span><br><span class="line">    - 무한 기능이 들어간 일정의 경우 글자색이 바뀜</span><br><span class="line"></span><br><span class="line">- 위젯 화면 구현</span><br><span class="line">  - 위젯 화면 상단 소형 달력 화면 구현</span><br><span class="line">    - 이전 날 / 다음 날 버튼 기능 구현</span><br><span class="line">    - 오늘 날짜 표시 기능 구현 </span><br><span class="line">    - 오늘 날짜로 돌아가기 버튼 구현</span><br><span class="line">  - 일정 추가 버튼 구현</span><br><span class="line">  - 다양한 크기가 가능해야함</span><br><span class="line"></span><br><span class="line">  - 위젯 하단 일정 화면 구현</span><br><span class="line">    - 당일의 일정 리스트 가져오기 기능 구현</span><br><span class="line">    - 취소선이 그어진 일정은 가져오지 않음</span><br><span class="line">    - 체크박스 기능 구현</span><br><span class="line">      - 체크박스 클릭시 3초뒤에 위젯에서 삭제</span><br><span class="line"></span><br><span class="line">- 일정 추가 화면 구현</span><br><span class="line">  - 뒤로가기 버튼 구현</span><br><span class="line">  - 메모 작성칸 구현</span><br><span class="line">    - 화면 진입시 오토포커스</span><br><span class="line">    - 클릭시 키보드 출현, 내용 입력 가능</span><br><span class="line">  - 날짜 기능 구현</span><br><span class="line">    - 오늘 날짜 표시 기능 구현</span><br><span class="line">    - 이전 날 / 다음 날 버튼 기능 구현</span><br><span class="line">  - 하단에 취소 / 저장 버튼 구현</span><br><span class="line">  - 저장 기능 구현</span><br><span class="line">    - 저장시 해당된 날짜 기준으로 메모 내용 저장</span><br><span class="line">  - 무한 버튼 구현</span><br><span class="line">    - 무한 버튼이 활성화 되어있을경우 다음날로 넘어가면 다음날에 해당 일정이 추가됨</span><br></pre></td></tr></table></figure></li><li><p>디자인 정의<br><a href="https://ovenapp.io/view/FtMo0EjqM1EAdG6gLVrJHeTUPeW6bfOq/B4oxD" rel="external nofollow noopener noreferrer" target="_blank">앱 디자인화면</a><br>Oven.io 로 구현했다. 프로토타입 디자인하기에 최적의 사이트.</p><ol><li>메인화면</li><li>위젯화면</li><li>일정추가 화면</li></ol><p>크게 3개로 분류했고 [해당일정 관리화면]이 따로 필요할 경우 추가예정</p></li></ul>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/15/Develop-Project-Android-2019-10-15-app-develop-project-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[알고리즘] 완전탐색 알고리즘 정리</title>
      <link>https://taeyeonkim93.github.io/2019/10/15/Develop-CS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-2019-10-15-exhaustive-search-algorithm/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/15/Develop-CS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-2019-10-15-exhaustive-search-algorithm/</guid>
      <pubDate>Tue, 15 Oct 2019 09:28:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;* 19.09.19 작성중..&lt;/p&gt;
&lt;h3 id=&quot;완전탐색-알고리즘-이란&quot;&gt;&lt;a href=&quot;#완전탐색-알고리즘-이란&quot; class=&quot;headerlink&quot; title=&quot;완전탐색 알고리즘 이란?&quot;&gt;&lt;/a&gt;완전탐색 알고리즘 이란?&lt;/h3&gt;&lt;p&gt;어떤 해
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>* 19.09.19 작성중..</p><h3 id="완전탐색-알고리즘-이란"><a href="#완전탐색-알고리즘-이란" class="headerlink" title="완전탐색 알고리즘 이란?"></a>완전탐색 알고리즘 이란?</h3><p>어떤 해답에 도달하기까지의 과정을 전부 하나하나씩 검사한다는 의미이다.</p><p>가장 이상적인 방법이지만 해결까지에 드는 자원 소모가 많은게 단점이다.</p><h3 id="완전탐색-알고리즘의-사용처"><a href="#완전탐색-알고리즘의-사용처" class="headerlink" title="완전탐색 알고리즘의 사용처"></a>완전탐색 알고리즘의 사용처</h3><ul><li>무작위의 변수를 비교/탐색해야 할 때</li><li>최적화 문제(여러가지 경우를 만들 수 있을때, 가장 적합한 답을 구하는 문제)</li></ul><h3 id="완전탐색-알고리즘"><a href="#완전탐색-알고리즘" class="headerlink" title="완전탐색 알고리즘"></a>완전탐색 알고리즘</h3><p>완전탐색 알고리즘의 종류로는</p><ul><li><p>Brute Force (무작위 대입)</p></li><li><p>DFS (깊이 우선 탐색)</p></li><li><p>BFS (너비 우선 탐색)</p></li><li><p>백트래킹</p><p>네종류가 있다.</p></li></ul><h4 id="1-Brute-Force-무작위-대입-방식"><a href="#1-Brute-Force-무작위-대입-방식" class="headerlink" title="1. Brute Force (무작위 대입) 방식"></a>1. Brute Force (무작위 대입) 방식</h4><p> 가장 흔히 사용하는, <code>for문</code>으로 배열의 시작값부터 끝값까지 전부 체크하는 방식이다.</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">checkStr = <span class="string">'qwertyuiopasdfghjkl'</span> <span class="comment"># 원래값</span></span><br><span class="line">pattern = <span class="string">'asdf'</span> <span class="comment"># 찾을 값</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>, len(checkStr)):</span><br><span class="line">    <span class="keyword">if</span> checkStr[idx:idx + <span class="number">4</span>] == pattern:</span><br><span class="line">        print(<span class="string">"checkStr에서 patter이 시작되는 index :"</span>, idx)</span><br></pre></td></tr></table></figure><p>checkStr이 가진 <code>qwertyuiopasdfghjkl</code> 값을 q부터 4개씩 비교해가면서 무작위대입 방식으로 찾는다. </p><p>(위 예는 <code>checkStr.find(pattern)</code> 내장함수와 동일하다.)</p><ul><li><a href="https://taeyeonkim93.github.io/2019/09/18/programmers-coding-test-3/">예제 - [프로그래머스] 코딩테스트 풀이 - 모의고사</a></li></ul><h4 id="2-DFS-Depth-First-Search"><a href="#2-DFS-Depth-First-Search" class="headerlink" title="2. DFS (Depth First Search)"></a>2. DFS (Depth First Search)</h4><p>아래로 가면서 모든 경우의 수를 전부 탐색하는 방법이다.<br>BF에 비해 구현방식이 간단하다. 트리 그래프는 많은곳에서 볼수있으니 딱히 그리지는 않겠다.<br>보통 재귀함수로 많이 구현한다.</p><p><strong>DFS 재귀함수 구현조건</strong></p><ol><li>종료를 언제 할 것인가?</li><li>종료시에 어떤 값을 반환할 것인가?(T/F 두 가지 전부)</li><li>왼쪽 / 오른쪽 중 탐색할 방향의 결과값을 담는다</li><li>이전 단계에서 탐색하지 않은 방향으로 탐색하게 한다.</li><li>다시 원래지점으로 되돌아와서 반환한다.</li></ol>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/15/Develop-CS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-2019-10-15-exhaustive-search-algorithm/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[종만북] 책 내용 정리 2</title>
      <link>https://taeyeonkim93.github.io/2019/10/15/Develop-Algorithm-book-2019-10-15-jongman-book-study-2/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/15/Develop-Algorithm-book-2019-10-15-jongman-book-study-2/</guid>
      <pubDate>Tue, 15 Oct 2019 05:16:21 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;프로그래밍 대회에서 배우는 알고리즘 문제해결전략 책 정리용&lt;/p&gt;
&lt;h3 id=&quot;알고리즘-시간-복잡도-분석&quot;&gt;&lt;a href=&quot;#알고리즘-시간-복잡도-분석&quot; class=&quot;headerlink&quot; title=&quot;알고리즘 시간 복잡도 분석&quot;&gt;&lt;/a&gt;알고리즘
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 책 정리용</p><h3 id="알고리즘-시간-복잡도-분석"><a href="#알고리즘-시간-복잡도-분석" class="headerlink" title="알고리즘 시간 복잡도 분석"></a>알고리즘 시간 복잡도 분석</h3><ul><li>알고리즘의 수행 시간을 지배하는것은 반복문이다.</li><li>선형 시간 알고리즘 -&gt; O(n)<ul><li>선형 시간에 실행되는 알고리즘은 대개 가장 좋은 알고리즘인 경우가 많음</li></ul></li><li>선형 이하 시간 알고리즘<ul><li>로그함수가 대표적. 입력의 크기가 커지는 것보다 수행시간이 느리게 증가하는 알고리즘들을 선형 이하 시간 알고리즘이라 부름</li><li>이진탐색</li></ul></li><li>지수 시간 알고리즘<ul><li>N, N^2, N 거듭제곱들의 선형결합으로 이루어진 식들을 다항식이라고 부름</li><li>반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘들을 다항 시간 알고리즘이라 부름</li><li>N이 하나 증가할때마다 걸리는 시간이 배로 증가하는 알고리즘들을 지수 시간 알고리즘이라고 함</li></ul></li></ul><h3 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h3><ul><li>점근적 시간 표기 : O 표기<ul><li>주어진 함수에서 가장 빨리 증가하는 항만을 남긴채 나머지를 다 버리는 표기법</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/15/Develop-Algorithm-book-2019-10-15-jongman-book-study-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[종만북] 책 내용 정리</title>
      <link>https://taeyeonkim93.github.io/2019/10/09/Develop-Algorithm-book-2019-10-09-jongman-book-study-1/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/09/Develop-Algorithm-book-2019-10-09-jongman-book-study-1/</guid>
      <pubDate>Wed, 09 Oct 2019 08:50:08 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;프로그래밍 대회에서 배우는 알고리즘 문제해결전략 책 정리용&lt;/p&gt;
&lt;h3 id=&quot;알고리즘-문제를-푸는-방법&quot;&gt;&lt;a href=&quot;#알고리즘-문제를-푸는-방법&quot; class=&quot;headerlink&quot; title=&quot;알고리즘 문제를 푸는 방법&quot;&gt;&lt;/a&gt;알고리즘
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 책 정리용</p><h3 id="알고리즘-문제를-푸는-방법"><a href="#알고리즘-문제를-푸는-방법" class="headerlink" title="알고리즘 문제를 푸는 방법"></a>알고리즘 문제를 푸는 방법</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 문제를 읽고 이해한다</span><br><span class="line">2. 문제를 익숙한 용어로 재정의한다</span><br><span class="line">3. 어떻게 해결할지 계획을 세운다</span><br><span class="line">4. 계획을 검증한다</span><br><span class="line">5. 프로그램으로 구현한다</span><br><span class="line">6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.</span><br></pre></td></tr></table></figure><ol><li>문제를 읽고 이해한다<ul><li>초보~고수까지 문제를 잘못읽는 경우가 다반사</li><li>문제의 궁극적인 목적, 사소한 제약조건까지 완벽하게 이해해야함</li></ul></li></ol><ol start="2"><li>재정의와 추상화<ul><li>자신이 다루기 쉬운 개념을 이용해서 자신의 언어로 풀어쓰기</li><li>현실세계의 개념을 우리가 다루기 쉬운 수학적/전산학점 개념으로 옮겨 표현</li></ul></li></ol><ol start="3"><li>계획 세우기<ul><li>사용할 알고리즘, 자료구조 선택</li></ul></li></ol><ol start="4"><li>계획 검증하기<ul><li>설계한 알고리즘이 모든 경우에 요구조건을 정확히 수행하는지 증명</li><li>수행에 걸리는 시간과 메모리가 문제의 제한 내에 들어가는지 확인</li></ul></li></ol><ol start="5"><li>계획 수행하기<ul><li>정확히 구현하기</li></ul></li></ol><ol start="6"><li>회고하기<ul><li>자신이 문제를 해결한 과정을 돌이켜보고 개선하기</li><li>문제를 풀 때마다 코드와 함께 자신의 경험을 기록으로 남겨야 함</li><li>문제의 간단한 해법과, 어떤 방식으로 접근했는지, 문제의 해법을 찾는데 결정적이었던 깨달음</li><li>한번에 맞추지 못한 경우는 오답 원인도 적는게 좋음</li><li>다른 사람의 코드를 보면서 공부하는것도 좋음</li></ul></li></ol><h3 id="문제를-풀지-못할-때"><a href="#문제를-풀지-못할-때" class="headerlink" title="문제를 풀지 못할 때"></a>문제를 풀지 못할 때</h3><p><strong># 직관과 체계적인 접근</strong></p><ul><li>직관은 해당 문제를 해결하는 알고리즘이 대략 어떤 형태를 가질지 짐작하게 함</li><li>어려운 문제들은 체계적으로 접근해야 함</li></ul><ol><li>비슷한 문제를 풀어본 적이 있던가?<ul><li>비슷한 문제를 풀어봤으면 이전 방법과 비슷한 접근방법을 사용할 것임</li><li>기존 문제를 경험으로 만들려면 원리를 완전히 이해하고 변형할 수 있어야 함</li><li>형태가 비슷하지 않더라도 문제의 목표가 같은 경우 또한 이에 소함</li><li>어떤 사건의 발생확률/경우의 수를 계산하는 문제는 대부분 동적계획법으로 해결 가능</li></ul></li></ol><ol start="2"><li>단순한 방법에서 시작할 수 있을까?<ul><li>무식하게 풀 수 있을까?</li><li>시간과 공간 제약을 생각하지 않고 문제를 해결해봄</li><li>점진적인 개선을 통해 알고리즘의 효율성을 증가시킴</li></ul></li></ol><ol start="3"><li>내가 손으로 문제를 푸는 과정을 수식화 할 수 있을까?<ul><li>번뜩이는 영감이 필요한 문제를 만났을때는 다른 방법을 시도해봐야한다.</li><li>손으로 여러 간단한 입력(문제에 주어진 예제 입력)을 직접 해결</li><li>문제를 해결하는 방법을 공식화해서 답을 만드는 알고리즘을 만들수 있는 경우가 있음</li><li>이 과정에서 알고리즘이 어떤 점을 고려해야하는지를 알게됨</li></ul></li></ol><ol start="4"><li>문제를 단순화할 수 있을까?<ul><li>좀더 쉬운 변형판을 먼저 풀어보기.</li><li>제약조건을 없애거나, 계산해야하는 변수를 줄이거나, 다차원의 문제를 1차원으로 줄이기도 함</li></ul></li></ol><ol start="5"><li>그림으로 그려볼 수 있을까?<ul><li>관련된 그림을 그려보면 더 쉬움</li></ul></li></ol><ol start="6"><li>수식으로 표현할 수 있을까?<ul><li>평문으로 쓰여있는 문제를 수식으로 표현하는 것도 도움이 됨</li></ul></li></ol><ol start="7"><li>문제를 분해할 수 있을까?<ul><li>문제의 제약조건을 분해할 수 있음</li></ul></li></ol><ol start="8"><li>뒤에서 생각해서 문제를 풀 수 있을까?<ul><li>모든 선택지를 위에서 아래로 내려가 보는 대신에 아래에서 위로 딱 한번만 하면 해결 가능</li></ul></li></ol><ol start="9"><li>순서를 강제할 수 있을까?<ul><li>순서가 없는 문제에 순서를 강제함</li><li>경우의 수를 셀 때도 유용함. 특정 조건을 만족하는 답들의 수를 세는 경우</li></ul></li></ol><ol start="10"><li>특정 형태의 답만을 고려할 수 있을까?<ul><li>정규화 기법이 있음</li><li>정규화란 우리가 고려해야 할 답들 중 형태가 다르지만 결과적으로 똑같은것들을 그룹으로 묶은 뒤, 각 그룹의 대표만을 고려하는 방법</li></ul></li></ol><h3 id="좋은-코드를-짜기-위한-원칙"><a href="#좋은-코드를-짜기-위한-원칙" class="headerlink" title="좋은 코드를 짜기 위한 원칙"></a>좋은 코드를 짜기 위한 원칙</h3><ol><li>간결한 코드를 작성하기<ul><li>가장 간결한 코드를 작성해야 오타나 버그가 생길 가능성이 적다</li></ul></li></ol><ol start="2"><li>적극적으로 코드 재사용하기<ul><li>같은 코드가 세번 이상 등장한다면 해당 코드를 함수로 분리해 재사용한다</li></ul></li></ol><ol start="3"><li>표준 라이브러리 공부하기<ul><li>시간낭비를 줄일 수 있으나 표준적인 알고리즘 구현 사용법을 잘 알아두기</li></ul></li></ol><ol start="4"><li>항상 같은 형태로 프로그램을 작성하기<ul><li>여러 종류의 반복적인 코드들(BFS, 2차원 자료구조 등)은 항상 같은것으로 사용하기</li></ul></li></ol><ol start="5"><li>일관적이고 명료한 명명법 사용하기<ul><li>모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이기</li><li>사용하는 언어의 표준 라이브러리에서 사용하는 명명규약을 익히기</li></ul></li></ol><ol start="6"><li>모든 자료를 정규화해서 저장하기<ul><li>같은 자료를 두가지 형태로 저장하지 않기</li><li>정규화는 프로그램이 자료를 입력받거나 계산하자마자 곧장 이루어져야 함</li><li>이상적으로는 자료를 표현하는 클래스의 생성자에서 정규화를 수행하거나 외부에서 자료를 입력받자마자 정규화를 하는게 좋음</li></ul></li></ol><ol start="7"><li>코드와 데이터를 분리하기<ul><li>정적 데이터 내용을 함수로 따로 만드는 행위를 하지 않기</li></ul></li></ol><h3 id="자주-하는-실수"><a href="#자주-하는-실수" class="headerlink" title="자주 하는 실수"></a>자주 하는 실수</h3><ol><li>산술 오버플로<ul><li>계산 과정에서 변수의 표현범위를 벗어나는 값을 사용</li></ul></li></ol><ol start="2"><li>배열 범위 밖 원소에 접근<ul><li>배열 크기를 정할때 계산을 신중하게 하기</li><li>0 시작범위와 1 시작범위 혼동하지않기</li></ul></li></ol><ol start="3"><li>일관되지않은 범위표현방식 사용하기<ul><li>[2,12] -&gt; 2~12 까지 자연수 표현, (2,12) -&gt; 3~11까지 자연수 표현</li><li>절충안으로 [lo, hi)를 사용함</li></ul></li></ol><ol start="4"><li>Off-by-one 오류<ul><li>반복문을 한번 더 많이 순회하거나 열린구간과 닫힌구간을 혼용해서 쓴 경우 많이 발생</li><li>입력이 주어졌을 때 코드가 어떻게 동작할지 되새겨보면서 프로그램 짜야함</li></ul></li></ol><ol start="5"><li>컴파일러가 잡아주지 못하는 상수 오타<ul><li>상수를 잘못 입력해서 생기는 오류</li></ul></li></ol><ol start="6"><li>스택 오버플로<ul><li>call stack이 오버플로해서 프로그램이 강제종료 되는것</li><li>재귀호출의 깊이가 너무 깊어지는게 대개 원인</li><li>스택 메모리가 적을때는 힙에 메모리를 할당하는게 좋음</li></ul></li></ol><ol start="7"><li>다차원 배열 인덱스 순서 바꿔서 쓰기<ul><li>특정 배열에 접근하는 위치를 하나로 통일하는것이 좋음</li></ul></li></ol><ol start="8"><li>잘못된 비교 함수 작성</li></ol><ol start="9"><li>최소, 최대 예외 잘못 다루기<ul><li>예외를 잘 처리해야 한다</li></ul></li></ol><ol start="10"><li>연산자 우선순위 잘못 쓰기<ul><li>시프트 연산자나 비트 단위 연산자들은 종종 헷갈림</li></ul></li></ol><ol start="11"><li>너무 느린 입출력 방식 선택<ul><li>gets()로 한꺼번에 받거나 cin으로 고수준 입력방식을 받을수도 있지만 느릴수 있기때문에 잘 선택해야함</li></ul></li></ol><ol start="12"><li>변수 초기화 문제<ul><li>이전 입력에 사용한 전역변수값을 초기화하지않고 그대로 사용함</li></ul></li></ol><h3 id="디버깅과-테스팅"><a href="#디버깅과-테스팅" class="headerlink" title="디버깅과 테스팅"></a>디버깅과 테스팅</h3><ol><li>디버깅에 관하여<ul><li>프로그래밍 대회용 소스코드는 대부분 짧기때문에 눈으로 하는것이 훨씬 빠름</li><li>재귀호출이나 중복 반복문을 자주 쓰면 디버깅하기에 힘듬</li><li>디버거 사용 대신 해야할 단계</li></ul><ol><li>작은 입력에 대해 제대로 실행되나 확인하기<ul><li>오동작하는 가장 작은 입력을 먼저 찾아내면 디버깅하기 훨씬 용이함</li></ul></li><li>단정문을 쓴다<ul><li>주어진 조건이 거짓일때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문</li></ul></li><li>프로그램의 계산 중간겨로가를 출력한다<ul><li>중간과정 값들을 출력하고 자신이 예상하는 바와 맞아들어가는지 검사하기</li></ul></li></ol><ul><li>디버거를 사용하는 좋은 예는 프로그램이 런타임 오류를 내고 종료하는 경우</li></ul></li></ol><ol start="2"><li>테스트에 관하여<ul><li>제출 전에 예제 입력을 만들어 가능한 많이 프로그램을 테스트하는것이 좋음</li><li>스캐폴딩 방법을 이용해 검증한다.(다른 코드를 개발할때 뼈대를 잡기위해 임시로 사용하는 코드)</li></ul></li></ol><h4 id="변수-범위의-이해"><a href="#변수-범위의-이해" class="headerlink" title="변수 범위의 이해"></a>변수 범위의 이해</h4><ol><li>산술 오버플로<ul><li>어떤 식의 계산값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우</li></ul></li></ol><ol start="2"><li>너무 큰 결과<ul><li>프로그램이 출력해야할 결과가 너무 크면 안됨</li></ul></li></ol><ol start="3"><li>너무 큰 중간값<ul><li>계산식 도중에 값이 자료형의 크기를 넘는 경우가 있음</li></ul></li></ol><ol start="4"><li>너무 큰 무한대값<ul><li>무한대 값을 이용해 특수한값으로 사용할때는 무한대값들이 서로 더해지거나 곱해지는 경우가 없는지 잘 살펴봐야함.</li></ul></li></ol><ol start="5"><li>오버플로 피해가기<ul><li>자료형 큰거로 바꾸기</li><li>계산 순서 바꾸기</li><li>점화식 이용하기</li></ul></li></ol><ol start="6"><li>자료형의 프로모션<ul><li>자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러가 자동으로 변환하는것을 프로모션이라 함</li><li>자동으로 형변환되는 숫자들에 대한 주의가 필요함</li></ul></li></ol>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/09/Develop-Algorithm-book-2019-10-09-jongman-book-study-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[프로그래머스] 코딩테스트 풀이 - 큰 수 만들기</title>
      <link>https://taeyeonkim93.github.io/2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-9/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-9/</guid>
      <pubDate>Wed, 02 Oct 2019 08:42:30 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42883&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/courses/30/lessons/42883" rel="external nofollow noopener noreferrer" target="_blank">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.</p><p>예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.</p><p>문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.</li><li>k는 1 이상 number의 자릿수 미만인 자연수입니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">name</th><th align="left">k</th><th align="left">return</th></tr></thead><tbody><tr><td align="left">“1924”</td><td align="left">2</td><td align="left">“94”</td></tr><tr><td align="left">“1231234”</td><td align="left">3</td><td align="left">“3234”</td></tr><tr><td align="left">“4177252841”</td><td align="left">4</td><td align="left">“775841”</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">만들 수 있는 숫자 중 가장 큰 숫자의 [문자열]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. name 문자열</span><br><span class="line">2. 문자열에서 제거할 숫자의 갯수</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line">- 앞에서 뒤로 제거하는 방식</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 만들 문자열 길이(전체길이 - k) 만큼의 배열리스트 내에서 최대값을 찾는다.</span><br><span class="line">2. answer에 최대값을 저장하고 최대값과 그 이전의 값들을 다 없앤다.</span><br><span class="line">3. 만들 문자열 길이 -1 을 하고 다시 리스트 내에서 최대값을 찾는다.</span><br><span class="line">4. 만들 문자열 길이가 0이면 반환한다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>위와 같은 알고리즘으로 답은 나왔으나 테스트케이스 중 시간초과로 해결하지 못한 케이스가 있었다.<br>찾아보니 스택으로 처리해야 한다는데 생각보다 간단해서 김이 빠졌다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(number, k)</span>:</span></span><br><span class="line">    collected = []</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(number):</span><br><span class="line">        <span class="keyword">while</span> len(collected) &gt; <span class="number">0</span> <span class="keyword">and</span> collected[<span class="number">-1</span>] &lt; num <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            collected.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            collected += list(number[i:])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        collected.append(num)</span><br><span class="line">    collected = collected[:-k] <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">else</span> collected</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(collected)</span><br></pre></td></tr></table></figure><p>풀고 난 이후에 다른 사람들의 풀이를 봐도 매번 최대값을 찾는 풀이는 없었고 모두 스택으로 해결한것 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 알고리즘</span><br><span class="line"></span><br><span class="line">1. numbers 의 값들을 순회한다.</span><br><span class="line">  1. 스택에 값이 있는지 확인한다.</span><br><span class="line">    T : 제일 위 스택이 현재값보다 작은지 확인한다</span><br><span class="line">      T : k값이 0보다 큰지 확인한다.</span><br><span class="line">        T : 스택의 값을 제거하고 k = k - 1 해준다.</span><br><span class="line">  2. k값이 0인지 확인한다.</span><br><span class="line">    T : 남은 number 리스트의 값들을 모두 뒤에 추가하고 break 한다</span><br><span class="line">  3. 현재값보다 스택이 큰지 확인한다.</span><br><span class="line">    T : 스택에 현재값을 넣는다</span><br><span class="line"></span><br><span class="line">2. numbers 에서 k값이 0이 안됐을 경우 ([5,4,3,2,1] , [2])</span><br><span class="line">  T : 스택에서 뽑아야 할 문자열의 갯수만큼 뽑아낸다.</span><br><span class="line">  F : 스택 그대로 출력한다.</span><br></pre></td></tr></table></figure><p>스택을 활용한 방법이 O(n)이라 매우 빠르다.</p>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[프로그래머스] 코딩테스트 풀이 - 조이스틱</title>
      <link>https://taeyeonkim93.github.io/2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-8/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-8/</guid>
      <pubDate>Wed, 02 Oct 2019 05:58:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42860&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/courses/30/lessons/42860" rel="external nofollow noopener noreferrer" target="_blank">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.<br>ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA</p><p>조이스틱을 각 방향으로 움직이면 아래와 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">▲ - 다음 알파벳</span><br><span class="line">▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)</span><br><span class="line">◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)</span><br><span class="line">▶ - 커서를 오른쪽으로 이동</span><br></pre></td></tr></table></figure><p>예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.</span><br><span class="line">- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.</span><br><span class="line">- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.</span><br><span class="line">따라서 11번 이동시켜 &quot;JAZ&quot;를 만들 수 있고, 이때가 최소 이동입니다.</span><br></pre></td></tr></table></figure><p>만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>name은 알파벳 대문자로만 이루어져 있습니다.</li><li>name의 길이는 1 이상 20 이하입니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">name</th><th>return</th></tr></thead><tbody><tr><td align="left">“JEROEN”</td><td>56</td></tr><tr><td align="left">“JAN”</td><td>23</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">조이스틱 조작 횟수의 [최솟값]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 조이스틱 조작방식에 대한 정보</span><br><span class="line">2. 만들어야하는 이름의 정보</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line">- 알파벳 대문자로만 이루어져 있음</span><br><span class="line">- 길이가 1~20까지</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. Greedy 알고리즘을 사용해서 각 칸의 최적해를 찾아낸다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>매 Case 마다 최적값이 달라지므로 Greedy 알고리즘을 사용해서 푸는 문제이다.<br>그때그때 최적의 해를 찾아서 푸는 문제이므로 각 칸에서의 최적해를 구하는 방식을 찾는다.</p><ul><li><p>왼쪽/오른쪽 중 어떤 조작을 해야 알파벳을 빨리 찾을 수 있는지 조건을 넣는다.</p><ul><li>A가 아닌 알파벳에 가장 가까운 방향으로 진행시킨다.<ol><li>현재값이 A가 아니면 위아래 조작으로 넘어간다</li><li>현재값이 A일 경우 A가 아닌 값이 왼쪽으로 몇번째에 있는지 찾는다.</li><li>현재값이 A일 경우 A가 아닌 값이 오른쪽으로 몇번째에 있는지 찾는다.</li><li>두 값을 비교하고 이동횟수가 적은쪽으로 이동하고 A 갯수만큼 answer에 값을 추가한다.</li></ol></li></ul></li><li><p>위/아래 중 어떤 조작을 해야 알파벳을 빨리 찾을 수 있는지 조건을 넣는다.</p><ul><li>A~Z의 중간값인 N(위 13회, 아래 13회) 을 기준으로 나눈다.<ol><li>name 문자가 N보다 크거나 같으면 아래, 작으면 위 if문으로 들어간다.<ol><li>name 문자가 N보다 작을 때 아스키코드와 A의 아스키코드를 빼서 차 값을 answer에 넣는다</li><li>name 문자가 N보다 크거나 같을 때 아스키코드와 Z+1의 아스키코드를 빼서 차 값을 answer에 넣는다</li></ol></li></ol></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(name)</span>:</span></span><br><span class="line">     answer = <span class="number">0</span></span><br><span class="line">     name = list(name)</span><br><span class="line">     base = [<span class="string">"A"</span>] * len(name)</span><br><span class="line">     idx = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         rIndex = <span class="number">1</span></span><br><span class="line">         lIndex = <span class="number">1</span></span><br><span class="line">         <span class="keyword">if</span> name[idx] != <span class="string">"A"</span>:</span><br><span class="line">             <span class="keyword">if</span> name[idx] &lt; <span class="string">"N"</span>:</span><br><span class="line">                 answer += ord(name[idx]) - <span class="number">65</span></span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 answer += <span class="number">91</span> - ord(name[idx])</span><br><span class="line">             name[idx]=<span class="string">"A"</span></span><br><span class="line">         <span class="keyword">if</span> name == base:</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(name)):</span><br><span class="line">                 <span class="keyword">if</span> name[idx + i] == <span class="string">"A"</span>:</span><br><span class="line">                     rIndex += <span class="number">1</span></span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                 <span class="keyword">if</span> name[idx - i] == <span class="string">"A"</span>:</span><br><span class="line">                     lIndex += <span class="number">1</span></span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">             <span class="keyword">if</span> rIndex &gt; lIndex:</span><br><span class="line">                 answer += lIndex</span><br><span class="line">                 idx -= lIndex</span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 answer += rIndex</span><br><span class="line">                 idx += rIndex</span><br><span class="line">     <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[프로그래머스] 코딩테스트 풀이 - 쇠막대기</title>
      <link>https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-7/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-7/</guid>
      <pubDate>Tue, 01 Oct 2019 12:31:51 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42585&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/courses/30/lessons/42585" rel="external nofollow noopener noreferrer" target="_blank">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>문제 설명<br>여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다.</p><ul><li>쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.</li><li>쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.</li><li>각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.</li><li>레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.<br>아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다.</li></ul><p><img src="/images/coding-test/7-1.png" alt></p><p>이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 &apos;()&apos;으로 표현합니다. 또한 모든 &apos;()&apos;는 반드시 레이저를 표현합니다.</span><br><span class="line">(b) 쇠막대기의 왼쪽 끝은 여는 괄호 &apos;(&apos;로, 오른쪽 끝은 닫힌 괄호 &apos;)&apos;로 표현됩니다.</span><br></pre></td></tr></table></figure><p>위 예의 괄호 표현은 그림 위에 주어져 있습니다.<br>쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다.</p><p>쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>arrangement의 길이는 최대 100,000입니다.</li><li>arrangement의 여는 괄호와 닫는 괄호는 항상 쌍을 이룹니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">arrangement</th><th>return</th></tr></thead><tbody><tr><td align="left">“()(((()())(())()))(())”</td><td>17</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">잘린 쇠막대기 조각의 총 [개수]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 쇠막대기와 레이저의 배치를 표현한 arrangement</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line"></span><br><span class="line">- 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.</span><br><span class="line">- 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.</span><br><span class="line">- 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.</span><br><span class="line">- 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 레이저와 쇠막대기의 상관관계와 규칙을 찾아낸다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>스택을 활용해서 푸는 문제이다.<br>간단하게 규칙을 이용해서 공식을 찾아낼수도 있지만</p><ul><li>(쇠막대기 갯수 + 쇠막대기 갯수 * 레이저 갯수 = 조각 갯수)</li></ul><p>문제 의도에 맞게 스택으로 풀이한다.</p><p><strong>알고리즘</strong></p><ol><li><code>isLaser</code> 변수를 True 로 놓는다.</li><li>스택에 <code>arrangement</code> 의 내부 기호를 쌓는다.<ol><li>만약 <code>isLaser</code> 가 True 인데 ) 기호가 들어올 경우 <code>isLaser</code> 을 False 로 바꾸고 가장 위에있던 ( 기호를 제거하고 스택에 남아있던 ( 기호만큼 쇠막대기 갯수를 증가시킨다.</li><li>만약 <code>isLaser</code> 가 False 인데 ) 기호가 들어올 경우 가장 위에있던 ( 기호를 제거하고 쇠막대기 갯수를 1만큼 증가시킨다</li><li>만약 <code>isLaser</code> 가 True 인데 ( 기호가 들어올 경우 스택에 쌓는다.</li><li>만약 <code>isLaser</code> 가 False 인데 ( 기호가 들어올 경우 <code>isLaser</code> 을 True 로 변경하고 그대로 스택에 쌓는다.</li></ol></li><li>쌓인 쇠막대기 갯수를 return 한다. </li></ol><p>insert 와 pop 을 행할 시 결과값이 어떻게 바뀌는지 주의하면서 알고리즘을 짠다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(arrangement)</span>:</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    isLaser = <span class="literal">True</span></span><br><span class="line">    steel_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> bracket <span class="keyword">in</span> arrangement:</span><br><span class="line">        <span class="keyword">if</span> isLaser <span class="keyword">and</span> bracket == <span class="string">")"</span>:</span><br><span class="line">            isLaser = <span class="literal">False</span></span><br><span class="line">            steel_stack.pop()</span><br><span class="line">            answer += len(steel_stack)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> isLaser <span class="keyword">and</span> bracket == <span class="string">")"</span>:</span><br><span class="line">            answer += <span class="number">1</span></span><br><span class="line">            steel_stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> isLaser <span class="keyword">and</span> bracket == <span class="string">"("</span>:</span><br><span class="line">            steel_stack.append(bracket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            isLaser = <span class="literal">True</span></span><br><span class="line">            steel_stack.append(bracket)</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h2 id="다른-풀이"><a href="#다른-풀이" class="headerlink" title="다른 풀이"></a>다른 풀이</h2><p>스택을 활용한 방법과 replace를 이용해 레이저를 다른 변수로 바꿔버린 풀이가 있다.</p><p>레이저 부분을 P로 치환해서 해결한 사례. 그외에는 스택을 이용해서 비슷하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(arrangement)</span>:</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    stack = []</span><br><span class="line">    arrangement = arrangement.replace(<span class="string">"()"</span>,<span class="string">"P"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> arr <span class="keyword">in</span> arrangement:</span><br><span class="line">        <span class="keyword">if</span> arr == <span class="string">'('</span>:</span><br><span class="line">            stack.append(arr)</span><br><span class="line">            answer +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr == <span class="string">')'</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += len(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[프로그래머스] 코딩테스트 풀이 - 탑</title>
      <link>https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-6/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-6/</guid>
      <pubDate>Tue, 01 Oct 2019 11:48:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/challenges&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;프로그래머스 코딩 테스
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/challenges" rel="external nofollow noopener noreferrer" target="_blank">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다.</p><p>예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다.</p><table><thead><tr><th>송신 탑(높이)</th><th>수신 탑(높이)</th></tr></thead><tbody><tr><td>5(4)</td><td>4(7)</td></tr><tr><td>4(7)</td><td>2(9)</td></tr><tr><td>3(5)</td><td>2(9)</td></tr><tr><td>2(9)</td><td>-</td></tr><tr><td>1(6)</td><td>-</td></tr></tbody></table><p>맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return 하도록 solution 함수를 작성해주세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>heights는 길이 2 이상 100 이하인 정수 배열입니다.</li><li>모든 탑의 높이는 1 이상 100 이하입니다.</li><li>신호를 수신하는 탑이 없으면 0으로 표시합니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">heights</th><th>return</th></tr></thead><tbody><tr><td align="left">[6,9,5,7,4]</td><td>[0,0,2,2,4]</td></tr><tr><td align="left">[3,9,9,3,5,7,2]</td><td>[0,0,0,3,3,3,6]</td></tr><tr><td align="left">[1,5,3,6,7,6,5]</td><td>[0,0,2,0,0,5,6]</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 탑의 길이</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line"></span><br><span class="line">1. 신호를 수신하는 탑이 없으면 0으로 표시</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 0번째 탑은 항상 수신하지 못한다.</span><br><span class="line">2. 현재 탑의 왼쪽이 현재 탑의 높이보다 높은지 체크하고 높으면 배열에 넣는다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>간단하게 2중 for문을 사용해서 풀어주었다.<br>이번 예제를 통해 <code>for else</code>문을 알게되었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(heights)</span>:</span></span><br><span class="line">    answer = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(heights):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> heights[j] &gt; num:</span><br><span class="line">                answer.append(j + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h2 id="다른-풀이"><a href="#다른-풀이" class="headerlink" title="다른 풀이"></a>다른 풀이</h2><h4 id="1-2중-for문"><a href="#1-2중-for문" class="headerlink" title="1. 2중 for문"></a>1. 2중 for문</h4><p>0을 먼저 선언해준뒤에 비교했다는 사실을 빼면 차이 없음.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(h)</span>:</span></span><br><span class="line">    ans = [<span class="number">0</span>] * len(h)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> h[i] &lt; h[j]:</span><br><span class="line">                ans[i] = j+<span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="2-스택을-사용한-방법"><a href="#2-스택을-사용한-방법" class="headerlink" title="2. 스택을 사용한 방법"></a>2. 스택을 사용한 방법</h4><p>문제 의도가 스택인것같아 한번 더 봤다.<br>기본적으로는 비슷하지만 pop 을 이용해서 공간을 덜 먹는다는게 장점인듯</p><ol><li>스택을 만들어주고 LIFO 법칙에 따라 가장 마지막 배열을 현재의 탑으로 잡고 배열에서 없앤다.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(heights)</span>:</span></span><br><span class="line">    responses = []</span><br><span class="line">    <span class="keyword">while</span> heights:</span><br><span class="line">        top = heights.pop()</span><br></pre></td></tr></table></figure><ol start="2"><li>현재의 탑의 길이보다 -1부터 내려가면서 탐색한다. 있으면 answer에 append한다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> top &lt; heights[i]:</span><br><span class="line">            responses.append(i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        responses.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> responses[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[프로그래머스] 코딩테스트 풀이 - 124 나라의 숫자</title>
      <link>https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-5/</link>
      <guid>https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-5/</guid>
      <pubDate>Tue, 01 Oct 2019 07:29:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/challenges&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;프로그래머스 코딩 테스
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/challenges" rel="external nofollow noopener noreferrer" target="_blank">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.</p><ol><li>124 나라에는 자연수만 존재합니다.</li><li>124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다.</li></ol><p>예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다.</p><table><thead><tr><th align="center">10진법</th><th align="center">124나라</th><th align="center">10진법</th><th align="center">124나라</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">14</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">7</td><td align="center">21</td></tr><tr><td align="center">3</td><td align="center">4</td><td align="center">8</td><td align="center">22</td></tr><tr><td align="center">4</td><td align="center">11</td><td align="center">9</td><td align="center">24</td></tr><tr><td align="center">5</td><td align="center">12</td><td align="center">10</td><td align="center">41</td></tr></tbody></table><p>자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>n은 500,000,000이하의 자연수 입니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">n</th><th>result</th></tr></thead><tbody><tr><td align="left">1</td><td>1</td></tr><tr><td align="left">2</td><td>2</td></tr><tr><td align="left">3</td><td>4</td></tr><tr><td align="left">4</td><td>11</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">자연수 n을 124나라에서 사용하는 숫자로 변환한 [값]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 124 나라에서 사용된 10진법 데이터</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 124나라에서 10진법을 변환하는 규칙을 찾는다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>주먹구구로 규칙을 찾아서 풀었다.<br>머리가 문제인가 경험이 문제인가..</p><p>1,2,4 총 3개의 값으로 계속 순환되고 있으므로</p><table><thead><tr><th>10진법</th><th>124나라</th><th>몫</th></tr></thead><tbody><tr><td>0</td><td>x</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>2</td><td>2</td><td>0</td></tr><tr><td>3</td><td>4</td><td>1</td></tr><tr><td>4</td><td>11</td><td>1</td></tr><tr><td>5</td><td>12</td><td>1</td></tr><tr><td>6</td><td>14</td><td>2</td></tr><tr><td>7</td><td>21</td><td>2</td></tr><tr><td>8</td><td>22</td><td>2</td></tr><tr><td>9</td><td>24</td><td>3</td></tr><tr><td>10</td><td>41</td><td>3</td></tr><tr><td>11</td><td>42</td><td>3</td></tr><tr><td>12</td><td>44</td><td>4</td></tr><tr><td>13</td><td>111</td><td>4</td></tr><tr><td>14</td><td>112</td><td>4</td></tr><tr><td>15</td><td>114</td><td>5</td></tr></tbody></table><p>몫이 0일때까지 3으로 나눈다.</p><p>이때 3으로 나누기가 가능한 만큼 자릿수를 추가한다.</p><p>몫-1이 0이면 자릿수 1개<br>몫-1이 1~3이면 자릿수 2개<br>몫-1이 4~8이면 자릿수 3개</p><p>인 규칙을 발견할수 있다.</p><h4 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(n)</span>:</span></span><br><span class="line">    answer = <span class="string">''</span></span><br><span class="line">    pattern = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    chk = n</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    answer = str(pattern[(chk % <span class="number">3</span>)]) + answer</span><br><span class="line">    <span class="comment"># 나누고 남은 나머지값이 들어간다. chk는 1,2,0 순으로 순환된다.</span></span><br><span class="line">    chk = int((chk - <span class="number">1</span>)//<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 자릿수를 파악한다.</span></span><br><span class="line">    n = int(n // <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 나머지를 찾기위한 n의 값을 계산한다.</span></span><br><span class="line">    <span class="keyword">if</span> chk == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 더이상 계산할 자릿수가 없을때 break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h2 id="다른-풀이"><a href="#다른-풀이" class="headerlink" title="다른 풀이"></a>다른 풀이</h2><p>n에서 1을 뺄 경우 쉬운 규칙으로 변하는 부분을 잘 캐치하였다.<br>chk 라는 변수를 따로 선언해서 삽질하지 않은 부분이 가장 크게 다른 부분.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(n)</span>:</span></span><br><span class="line">    num = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>]</span><br><span class="line">    answer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        answer = num[n % <span class="number">3</span>] + answer</span><br><span class="line">        n = n // <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[프로그래머스] 코딩테스트 풀이 - 기능개발</title>
      <link>https://taeyeonkim93.github.io/2019/09/24/Develop-Algorithm-programmers-2019-09-24-programmers-coding-test-4/</link>
      <guid>https://taeyeonkim93.github.io/2019/09/24/Develop-Algorithm-programmers-2019-09-24-programmers-coding-test-4/</guid>
      <pubDate>Tue, 24 Sep 2019 10:20:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/challenges&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;프로그래머스 코딩 테스
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/challenges" rel="external nofollow noopener noreferrer" target="_blank">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.</p><p>또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.</p><p>먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.</li><li>작업 진도는 100 미만의 자연수입니다.</li><li>작업 속도는 100 이하의 자연수입니다.</li><li>배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">progresses</th><th align="left">speeds</th><th>return</th></tr></thead><tbody><tr><td align="left">[93,30,55]</td><td align="left">[1,30,5]</td><td>[2,1]</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">특정 순서로 이루어진, 작업이 끝나서 배포한 작업의 [갯수]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 작업의 배포순서가 적힌 리스트</span><br><span class="line">2. 작업의 개발 속도</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line"></span><br><span class="line">1. 배포는 하루에 한번만 가능</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 작업 리스트를 큐에 집어넣는다</span><br><span class="line">2. 각 작업별 스피드를 작업 진척도에 더하다가 </span><br><span class="line">   큐에서 제일 처음에 넣은 작업이 완료됐을경우 완료된 작업을 빼내고 카운트한다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>사용언어 : Python 3</p><p>전형적인 Queue의 가장 쉬운 예제로 볼 수 있다.<br>작업이 모두 완료됐을 때의 날짜를 가지고 끝난 작업의 개수를 계산하는 방법도 있다</p><h4 id="Queue를-사용하는-방법"><a href="#Queue를-사용하는-방법" class="headerlink" title="Queue를 사용하는 방법"></a>Queue를 사용하는 방법</h4><ol><li><p>작업 리스트를 큐에 집어넣는다 (이미 주어진 progresses 배열이 Queue 자료구조로 되어있는 상태)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(progresses, speeds)</span>:</span></span><br><span class="line">    answer = []</span><br></pre></td></tr></table></figure></li><li><p>각 작업별 진척도를 작업에 더한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> progresses:</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> progresses[<span class="number">0</span>] &lt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">for</span> idx, speed <span class="keyword">in</span> enumerate(speeds):</span><br><span class="line">            progresses[idx] += speed</span><br></pre></td></tr></table></figure></li><li><p>가장 앞의 작업의 진척도가 100이상일 경우, 작업의 진척도가 100인 자료들을 모두 꺼낸다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> progresses <span class="keyword">and</span> progresses[<span class="number">0</span>] &gt;= <span class="number">100</span>:</span><br><span class="line">            progresses.pop(<span class="number">0</span>)</span><br><span class="line">            speeds.pop(<span class="number">0</span>)</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        answer.append(result)</span><br><span class="line"><span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure></li></ol><h4 id="완료된-작업의-소요시간으로-계산하는-방법"><a href="#완료된-작업의-소요시간으로-계산하는-방법" class="headerlink" title="완료된 작업의 소요시간으로 계산하는 방법"></a>완료된 작업의 소요시간으로 계산하는 방법</h4><ol><li><p>마지막 작업이 걸린 소요시간을 계산한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(progresses, speeds)</span>:</span></span><br><span class="line">    Q = []</span><br><span class="line">    <span class="keyword">for</span> p, s <span class="keyword">in</span> zip(progresses, speeds): </span><br><span class="line">    <span class="comment"># p : progresses, s : speeds</span></span><br><span class="line">        <span class="keyword">if</span> len(Q) == <span class="number">0</span> <span class="keyword">or</span> Q[<span class="number">-1</span>][<span class="number">0</span>] &lt; -((p - <span class="number">100</span>) // s):</span><br><span class="line">        <span class="comment"># 배열이 하나도 없거나, 현재 작업이 마지막 작업보다 소요시간이 더 길 경우</span></span><br><span class="line">            Q.append([-((p - <span class="number">100</span>) // s), <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 큐에 추가한다.</span></span><br></pre></td></tr></table></figure></li><li><p>현재 작업이 마지막 작업보다 소요시간이 적은 작업일 경우, 마지막 작업이 배포될 날의 개수에 추가한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 현재 작업이 마지막 작업보다 소요시간이 더 작을경우</span></span><br><span class="line">        Q[<span class="number">-1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> [q[<span class="number">1</span>] <span class="keyword">for</span> q <span class="keyword">in</span> Q]</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/09/24/Develop-Algorithm-programmers-2019-09-24-programmers-coding-test-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[파이썬] 이슈 정리</title>
      <link>https://taeyeonkim93.github.io/2019/09/24/Develop-Programming-python-2019-09-24-python-issue/</link>
      <guid>https://taeyeonkim93.github.io/2019/09/24/Develop-Programming-python-2019-09-24-python-issue/</guid>
      <pubDate>Tue, 24 Sep 2019 06:18:23 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#1-foreach로-배열값을-꺼낼때&quot;&gt;foreach로 배열값을 꺼낼때&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2-문자
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><p><a href="#1-foreach로-배열값을-꺼낼때">foreach로 배열값을 꺼낼때</a><br><a href="#2-문자열-정렬-sort-방법">문자열 정렬(sort) 방법</a><br><a href="#3-문자열-분할-시-주의할점">문자열 분할 시 주의할점</a><br><a href="#4-파이썬-산술연산자">파이썬 산술연산자</a><br><a href="#5-리스트-내포-List-comprehension">리스트 내포(List comprehension)</a><br><a href="#6-리스트-out-of-range를-피하는-방법">리스트 out of range를 피하는 방법</a><br><a href="#7-반복문-중간에-break-여부-판단하기">반복문 중간에 break 여부 판단하기</a><br><a href="#8-문자열-내의-문자를-index-기반으로-다른-문자로-치환하기">문자열 내의 문자를 index 기반으로 다른 문자로 치환하기</a><br><a href="#9-배열-내-중복이-없게-만들기">배열 내 중복이 없게 만들기</a></p><h3 id="1-foreach로-배열값을-꺼낼때"><a href="#1-foreach로-배열값을-꺼낼때" class="headerlink" title="1. foreach로 배열값을 꺼낼때"></a><a href="#목차">1. foreach로 배열값을 꺼낼때</a></h3><ul><li>동작을 index 기반으로 하기때문에 copy를 해주거나 while로 돌리는게 편하다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lost = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">reserve = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> reserve</span><br><span class="line">    <span class="keyword">if</span> res <span class="keyword">in</span> lost:</span><br><span class="line">        lost.remove(res)</span><br><span class="line">        reserve.remove(res) </span><br><span class="line"><span class="comment"># 1을 비교후, 3이 아닌 5로 점프한다.</span></span><br></pre></td></tr></table></figure></li></ul><p>해결방법</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lost = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">reserve = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">_reserve = [r <span class="keyword">for</span> r <span class="keyword">in</span> reserve <span class="keyword">if</span> r <span class="keyword">not</span> <span class="keyword">in</span> lost]</span><br><span class="line">_lost = [l <span class="keyword">for</span> l <span class="keyword">in</span> lost <span class="keyword">if</span> l <span class="keyword">not</span> <span class="keyword">in</span> reserve]</span><br></pre></td></tr></table></figure><h3 id="2-문자열-정렬-sort-방법"><a href="#2-문자열-정렬-sort-방법" class="headerlink" title="2. 문자열 정렬(sort) 방법"></a><a href="#목차">2. 문자열 정렬(sort) 방법</a></h3><ul><li>list.sort() 혹은 sorted(list) 가 있다.</li><li>sort는 리스트 자체를 정렬하고, sorted는 정렬된 리스트를 반환한다.</li></ul><h3 id="3-문자열-분할-시-주의할점"><a href="#3-문자열-분할-시-주의할점" class="headerlink" title="3. 문자열 분할 시 주의할점"></a><a href="#목차">3. 문자열 분할 시 주의할점</a></h3><ul><li>list[1:3]은 list[2], list[3] 값을 반환한다.</li></ul><h3 id="4-파이썬-산술연산자"><a href="#4-파이썬-산술연산자" class="headerlink" title="4. 파이썬 산술연산자"></a><a href="#목차">4. 파이썬 산술연산자</a></h3><table><thead><tr><th>Operator</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>%</td><td>나머지</td><td>b % a = 0</td></tr><tr><td>**</td><td>제곱</td><td>a ** c = 1000</td></tr><tr><td>//</td><td>몫</td><td>a // c = 3</td></tr></tbody></table><h3 id="5-리스트-내포-List-comprehension"><a href="#5-리스트-내포-List-comprehension" class="headerlink" title="5. 리스트 내포(List comprehension)"></a><a href="#목차">5. 리스트 내포(List comprehension)</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = [num * <span class="number">3</span> <span class="keyword">for</span> num <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure><h3 id="6-리스트-out-of-range를-피하는-방법"><a href="#6-리스트-out-of-range를-피하는-방법" class="headerlink" title="6. 리스트 out of range를 피하는 방법"></a><a href="#목차">6. 리스트 out of range를 피하는 방법</a></h3><p>조건문 if 앞에 len(list)==0 or [조건] 을 붙여 내용이 없을때에도 진행 가능하게 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(Q)==<span class="number">0</span> <span class="keyword">or</span> Q[<span class="number">-1</span>][<span class="number">0</span>]&lt;-((p<span class="number">-100</span>)//s):</span><br></pre></td></tr></table></figure><h3 id="7-반복문-중간에-break-여부-판단하기"><a href="#7-반복문-중간에-break-여부-판단하기" class="headerlink" title="7. 반복문 중간에 break 여부 판단하기"></a><a href="#목차">7. 반복문 중간에 break 여부 판단하기</a></h3><p><code>for else</code> 문을 사용하면 반복중에 break 되었는지 아닌지 판단할 수 있다.</p><p>중간에 break 가 되었다면 else 문에 들어가지 않는다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'10 보다 큰 수는 없습니다.'</span>)</span><br></pre></td></tr></table></figure><h3 id="8-문자열-내의-문자를-index-기반으로-다른-문자로-치환하기"><a href="#8-문자열-내의-문자를-index-기반으로-다른-문자로-치환하기" class="headerlink" title="8. 문자열 내의 문자를 index 기반으로 다른 문자로 치환하기"></a><a href="#목차">8. 문자열 내의 문자를 index 기반으로 다른 문자로 치환하기</a></h3><p>파이썬은 문자열 내의 문자를 index 기반으로 치환하는 기능을 지원하지 않는다.</p><p>문자열을 list로 만들고 문자열을 치환한뒤에 다시 ‘’.join(name)으로 문자열로 변환한다.<br><code>list(name)</code><br><code>&#39;&#39;.join(name)</code></p><h3 id="9-배열-내-중복이-없게-만들기"><a href="#9-배열-내-중복이-없게-만들기" class="headerlink" title="9. 배열 내 중복이 없게 만들기"></a><a href="#목차">9. 배열 내 중복이 없게 만들기</a></h3><p>list에 11이라는 값을 3번 넣으면 [11,11,11]이 된다.</p><p>이때 [11] 만 남기고싶을때는 집합 자료형을 사용하면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/09/24/Develop-Programming-python-2019-09-24-python-issue/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 파이썬 함수 정리</title>
      <link>https://taeyeonkim93.github.io/2019/09/18/Develop-Programming-python-2019-09-18-python-function/</link>
      <guid>https://taeyeonkim93.github.io/2019/09/18/Develop-Programming-python-2019-09-18-python-function/</guid>
      <pubDate>Wed, 18 Sep 2019 11:59:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;그때그때 모르는 함수 있으면 정리해서 올리는 용도&lt;/p&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#1-enumerate&quot;&gt;enumerate&lt;/a
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>그때그때 모르는 함수 있으면 정리해서 올리는 용도</p><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><p><a href="#1-enumerate">enumerate</a><br><a href="#2-map">map</a><br><a href="#3-Queue">Queue</a><br><a href="#4-Index">Index</a><br><a href="#5-Zip">Zip</a><br><a href="#6-Sort">Sort</a><br><a href="#7-Heap">Heap</a><br><a href="#8-Permutation">Permutation</a><br><a href="#9-Deque">Deque</a></p><h2 id="파이썬-함수-정리"><a href="#파이썬-함수-정리" class="headerlink" title="파이썬 함수 정리"></a>파이썬 함수 정리</h2><h4 id="1-enumerate"><a href="#1-enumerate" class="headerlink" title="1. enumerate"></a><a href="#목차">1. enumerate</a></h4><ul><li>for문에서 현재 반복이 몇번째 반복인지 확인할 때 사용한다.</li></ul><p>주로 배열 내부를 순회하는 반복자를 선언하고 배열에서 연산자를 통해 값을 출력하는 경우</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(arr)):</span><br><span class="line">    print(i, arr[i])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>와 같이 사용할때, 간단히 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">    print(i, v)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>이와같이 사용할 수 있다.</p><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a><a href="#목차">2. map</a></h4><p>map<br>map(f, iterable)은 함수(f)와 반복 가능한(iterable) 자료형을 입력으로 받는다.<br>map은 입력받은 자료형의 각 요소를 함수 f가 수행한 결과를 묶어서 돌려주는 함수이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_times</span><span class="params">(x)</span>:</span> </span><br><span class="line">     <span class="keyword">return</span> x*<span class="number">2</span></span><br><span class="line">list(map(two_times, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">[2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>lambda를 활용하면 더 간략하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(map(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><h4 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a><a href="#목차">3. Queue</a></h4><p>기본적인 Queue 모듈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">data = [<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">q = queue.Queue()  <span class="comment"># 큐 선언</span></span><br><span class="line"></span><br><span class="line">q.put_nowait(data) <span class="comment"># 데이터 삽입</span></span><br><span class="line">print(q.queue[<span class="number">0</span>]) <span class="comment"># pop 없이 데이터 확인</span></span><br><span class="line"></span><br><span class="line">q.get_nowait() <span class="comment"># 데이터 확인</span></span><br><span class="line"></span><br><span class="line">print(q.qsize()) <span class="comment"># 큐 크기 확인</span></span><br></pre></td></tr></table></figure><h4 id="4-Index"><a href="#4-Index" class="headerlink" title="4. Index"></a><a href="#목차">4. Index</a></h4><p>위치 반환(index)<br>index(x) 함수는 리스트에 x 값이 있으면 x의 위치 값을 돌려준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.index(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="5-Zip"><a href="#5-Zip" class="headerlink" title="5. Zip"></a><a href="#목차">5. Zip</a></h4><p>동일한 갯수로 이루어진 자료형을 묶어주는 역할을 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(zip([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과 </span><br><span class="line">[(1, 4, 7), (2, 5, 8), (3, 6, 9)]</span><br></pre></td></tr></table></figure><p>사용처 : key/value 값이 각각 배열로 있을때, dictionary 를 사용하지 않아도 key-value 구조를 이용하도록 해준다.</p><p><strong>for문에서 사용 시</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p, s <span class="keyword">in</span> zip(a, b):</span><br><span class="line">    print(p,s)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure><h4 id="6-Sort"><a href="#6-Sort" class="headerlink" title="6. Sort"></a><a href="#목차">6. Sort</a></h4><p>리스트 내 자료들을 특정 기준으로 정렬해준다. (default : 오름차순)</p><p>key, reverse 를 매개변수로 갖고있다.</p><p><strong>매개변수 key 사용법</strong></p><p>다중 조건으로 정렬해야 할 경우</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># [0]번째 배열로 오름차순 비교후 [1]번째 배열로 내림차순으로 비교한다.</span></span><br><span class="line">numbers.sort(key=<span class="keyword">lambda</span> x : (x[<span class="number">0</span>],-x[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">[(1, 2), (4, 5), (4, 3)]</span><br></pre></td></tr></table></figure><p>1차원 배열 내 특정 조건으로 배열해야 할 경우</p><ul><li>functools라는 모듈을 가져와서 com_to_key 라는 함수를 사용해야 한다.(python 3 기준)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">numbers = list(map(str, numbers))</span><br><span class="line">numbers.sort(key=functools.cmp_to_key(<span class="keyword">lambda</span> x, y: int(x + y) - int(y + x)),reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 문자열로 변환했을때 두 배열을 더해서 나온 문자열값이 큰 값을 앞으로 배치한다.</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">[&apos;9&apos;, &apos;5&apos;, &apos;34&apos;, &apos;3&apos;, &apos;30&apos;]</span><br></pre></td></tr></table></figure><p><strong>매개변수 reverse 사용법</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">numbers.sort(reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">[6, 5, 3, 2, 1]</span><br></pre></td></tr></table></figure><h4 id="7-Heap"><a href="#7-Heap" class="headerlink" title="7. Heap"></a><a href="#목차">7. Heap</a></h4><p>파이썬 내 힙 자료구조를 사용법<br>heapq 라는 내장 모듈을 사용한다.<br>힙 자료구조를 사용할땐 보통 최소값만 있으면 다른건 아무것도 필요없을때 가장 빠른 속도를 위해서 사용한다.<br>push와 pop의 경우에는 매번 힙 구조로 정리까지 해주니 굳이 heapify 작업이 필요없다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">heapq.heapify(list) <span class="comment"># 리스트를 힙 구조로 바꿈 / 최소값이 0번째 index</span></span><br><span class="line">heapq.heappush(list, data) <span class="comment"># 힙 data 입력</span></span><br><span class="line">list_min = heapq.heappop(list) <span class="comment"># 힙 0번째 index 추출</span></span><br></pre></td></tr></table></figure><h4 id="8-Permutation"><a href="#8-Permutation" class="headerlink" title="8. Permutation"></a><a href="#목차">8. Permutation</a></h4><p>순열을 외부 모듈을 이용해서 구현한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">pool = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line">print(list(map(<span class="string">''</span>.join, itertools.permutations(pool)))) <span class="comment"># 3개의 원소로 수열 만들기</span></span><br><span class="line">print(list(map(<span class="string">''</span>.join, itertools.permutations(pool, <span class="number">2</span>)))) <span class="comment"># 2개의 원소로 수열 만들기</span></span><br></pre></td></tr></table></figure><h4 id="9-Deque"><a href="#9-Deque" class="headerlink" title="9. Deque"></a><a href="#목차">9. Deque</a></h4><p>양방향 큐 Deque 를 구현한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"> </span><br><span class="line">d = collections.deque([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</span><br><span class="line"> </span><br><span class="line">d.append(<span class="number">60</span>) <span class="comment"># 오른쪽에 추가 deque([10, 20, 30, 40, 50, 60])</span></span><br><span class="line"> </span><br><span class="line">d.appendleft(<span class="number">0</span>) <span class="comment"># 왼쪽에 추가 deque([0, 10, 20, 30, 40, 50, 60])</span></span><br><span class="line"> </span><br><span class="line">d.extend([<span class="number">70</span>, <span class="number">80</span>]) <span class="comment"># 입력값을 순환하면서 오른쪽에 추가(append) deque([0, 10, 20, 30, 40, 50, 60, 70, 80])</span></span><br><span class="line"> </span><br><span class="line">d.extendleft([<span class="number">-10</span>, <span class="number">-20</span>, <span class="number">-30</span>]) <span class="comment"># 입력값을 순환하면서 왼쪽에 추가(appendleft)</span></span><br><span class="line"><span class="comment"># deque([-30, -20, -10, 0, 10, 20, 30, 40, 50, 60, 70, 80])</span></span><br><span class="line"> </span><br><span class="line">d.remove(<span class="number">0</span>) <span class="comment"># 값 삭제</span></span><br><span class="line"><span class="comment"># deque([-30, -20, -10, 10, 20, 30, 40, 50, 60, 70, 80])</span></span><br><span class="line"> </span><br><span class="line">maxValue = d.pop() <span class="comment"># 오른쪽의 끝값 가져오면서 deque에서 제거</span></span><br><span class="line"><span class="comment"># maxValue: 80</span></span><br><span class="line"><span class="comment"># deque([-30, -20, -10, 10, 20, 30, 40, 50, 60, 70])</span></span><br><span class="line"> </span><br><span class="line">minValue = d.popleft() <span class="comment"># 왼쪽의 끝값 가져오면서 deque에서 제거</span></span><br><span class="line"><span class="comment"># minValue: -30</span></span><br><span class="line"><span class="comment"># deque([-20, -10, 10, 20, 30, 40, 50, 60, 70])</span></span><br><span class="line"> </span><br><span class="line">d = collections.deque(range(<span class="number">5</span>)) <span class="comment"># 값 회전(rotating)</span></span><br><span class="line"><span class="comment"># Deque:  deque([0, 1, 2, 3, 4])</span></span><br><span class="line"> </span><br><span class="line">d.rotate(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># Deque.rotate(1):  deque([4, 0, 1, 2, 3])</span></span><br><span class="line"> </span><br><span class="line">d.rotate(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># Deque.rotate(1):  deque([3, 4, 0, 1, 2])</span></span><br><span class="line"> </span><br><span class="line">d.rotate(<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># Deque.rotate(-1):  deque([4, 0, 1, 2, 3])</span></span><br><span class="line"> </span><br><span class="line">d.rotate(<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># Deque.rotate(-1):  deque([0, 1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://taeyeonkim93.github.io/2019/09/18/Develop-Programming-python-2019-09-18-python-function/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Taeyeon</title>
  
  <subtitle>Taeyeon&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://taeyeonkim93.github.io/"/>
  <updated>2019-10-20T13:47:51.708Z</updated>
  <id>https://taeyeonkim93.github.io/</id>
  
  <author>
    <name>Taeyeon Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[프로젝트] 안드로이드 앱 개발 구상</title>
    <link href="https://taeyeonkim93.github.io/2019/10/15/app-develop-project-1/"/>
    <id>https://taeyeonkim93.github.io/2019/10/15/app-develop-project-1/</id>
    <published>2019-10-15T11:54:02.000Z</published>
    <updated>2019-10-20T13:47:51.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>개발자로써 커리어를 App 개발로 정했고, 시작으로 간단한 프로젝트를 진행한다.<br>이전에 앱 개발을 해본 경험을 바탕으로 프로토타입용 앱을 개발하려고 한다.</p><p>기획과 디자인, 개발 모두 1인으로 진행한다.<br>짧은 시간과 1인 프로젝트인 만큼 toy 프로젝트 형식으로 간단하게 개발한다.</p><h3 id="1-어떤-개발을-할-것인가"><a href="#1-어떤-개발을-할-것인가" class="headerlink" title="1. 어떤 개발을 할 것인가?"></a>1. 어떤 개발을 할 것인가?</h3><p>짧은 시간제한과 의미있는 프로젝트를 위해 몇 가지 고려해야할 사항이 있다.</p><ul><li>어떤 개발환경으로 진행할 것인가? (language, DB, logger, error handling..)</li><li>어떤 어플을 만들것인가?</li></ul><p>수익구조나 타겟층같은 내용도 고려해야 하지만 toy 프로젝트이므로 그런점은 감안하고 진행한다.</p><h5 id="어떤-개발환경으로-진행할-것인가"><a href="#어떤-개발환경으로-진행할-것인가" class="headerlink" title="어떤 개발환경으로 진행할 것인가?"></a>어떤 개발환경으로 진행할 것인가?</h5><ol><li><p>개발언어 : Kotlin</p><ul><li>2017 Google이 선정한 Android 대표 개발언어. 객체지향 언어라 기존 JAVA 개발과 흡사하며 코드가 간결하다.</li></ul></li><li><p>DB : SQLite</p><ul><li>Android 개발시에 사용할 DB. 마지막 개발한지 몇년이 지나서 아직도 이걸 쓰는지 모르겠다</li><li>Realm 도 검토예정</li></ul></li><li><p>Server : AWS</p><ul><li>$0.88 매달 내면서 이용중인 개인서버가 있다. 유저가 로컬만 사용하는 어플이 아니어서 회원가입, 로그인 등에 이용가능할듯</li></ul></li></ol><p>기타 사항은 만들면서 추가 예정</p><h4 id="어떤-어플을-만들-것인가"><a href="#어떤-어플을-만들-것인가" class="headerlink" title="어떤 어플을 만들 것인가?"></a>어떤 어플을 만들 것인가?</h4><p>1인개발의 장점을 살리기 위해서는 화려한 기능보다는 적은 기능에 집중하는게 좋다.<br>아이디어를 고민하던 중 친구의 도움을 받아 일정 관리 어플을 만들어보기로 했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;챙겼나요?&gt;</span><br><span class="line"></span><br><span class="line">- 특정 날짜를 지정해서 한줄메모를 계속 추가할 수 있음</span><br><span class="line">- 위젯으로 각 날자에 써놓은 항목을 배경화면이나 잠금화면 위에 띄울수있음</span><br><span class="line">- 각 항목을 클릭하면 삭제선그어짐</span><br><span class="line"></span><br><span class="line">ex)</span><br><span class="line">10월 18일</span><br><span class="line">- 우산(삭제선)</span><br><span class="line">- 대강당 교육 오후 2시</span><br><span class="line">- xx한테 돈보냄?(삭제선)</span><br><span class="line"></span><br><span class="line">앱은 기능이 많으면 안되고 최대한 단촐하게. 추가한다면 알람정도</span><br></pre></td></tr></table></figure><p><strong>일정 관리 어플 장점</strong></p><ul><li>구글 Keep 메모, MS 원노트, 에버노트, 리마인더 등 먼저 있었던 앱들을 참고할수 있다.</li><li>유저마다 원하는 일정 관리의 형태가 달라 특정 사용자층을 노릴 수 있다</li><li>간단하다</li><li>실생활에 접목하기 쉽다</li></ul><p><strong>일정 관리 어플 단점</strong></p><ul><li>시장에 비슷한 어플이 너무 많아 굳이 쓸 이유가 없다</li><li>너무…많다…</li></ul><p>기존 앱들을 사용해보고 불편했던점을 종합해서 요구사항으로 반영해보기로 했다.</p><h3 id="2-어플-기능-정리"><a href="#2-어플-기능-정리" class="headerlink" title="2. 어플 기능 정리"></a>2. 어플 기능 정리</h3><ul><li><p>요구사항 정의</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 메모가 가능해야함</span><br><span class="line">  - 가독성이 용이해야함</span><br><span class="line">  - 수정이 용이해야함 / 채팅형 방식도 고민중</span><br><span class="line">- 다음날짜로 넘어갈경우(24:00 이후) 안에 내용도 모두 다음날짜 내용으로 바뀌어야함</span><br><span class="line">- 위젯이 가능해야함. 4x2 ~ 5x5 대응</span><br><span class="line">  - 이전 날짜에 있던 모든 일정은 보이지 않아야함(기본)</span><br><span class="line">  - [메모 유지] Flag 가 On 되어있을경우 다음날짜로 일정이 넘어감 (선택)</span><br><span class="line"></span><br><span class="line">- 검색창에 내 할일을 찾으면 찾을 수 있어야함 (추가기능)</span><br><span class="line">- 리마인더, 구글캘린더와 연동이 가능해야함 (추가기능)</span><br><span class="line">  - 스마트워치와 연동가능해야함 (추가기능)</span><br><span class="line">- 백업이 가능해야함 (추가기능)</span><br><span class="line">- 잠금화면 위에 위젯이 올라와야함 (추가기능)</span><br><span class="line">- AOD 위로 올라와야함 (추가기능)</span><br><span class="line">- 알림이 가능해야함 (추가기능)</span><br></pre></td></tr></table></figure></li><li><p>기능 정의</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- 메인 화면 구현</span><br><span class="line">  - 메인화면 상단 달력 바 구현</span><br><span class="line">    - 날짜 클릭 시 해당 날짜의 일정 출현 기능 구현</span><br><span class="line">    - 이전 주 / 다음 주 슬라이드 이동 기능 구현</span><br><span class="line">    - 월 누르면 월 선택할수있는 박스 기능 구현</span><br><span class="line">    - 해당 월의 가장 뒤 날짜로 이동 기능 구현(이번달은 오늘날짜)</span><br><span class="line">    - # 아래 bar 클릭시 달력 출현 기능 구현 (추가기능)</span><br><span class="line"></span><br><span class="line">  - 메인화면 하단 일정 관리 화면 구현</span><br><span class="line">    - 체크박스 기능 구현 (체크할시 취소선)</span><br><span class="line">    - 우측에 휴지통 버튼 구현 (클릭시 일정 삭제)</span><br><span class="line">    - 최하단 메모 추가 버튼 구현 (클릭시 일정추가화면으로 이동)</span><br><span class="line">    - 무한 기능이 들어간 일정의 경우 글자색이 바뀜</span><br><span class="line"></span><br><span class="line">- 위젯 화면 구현</span><br><span class="line">  - 위젯 화면 상단 소형 달력 화면 구현</span><br><span class="line">    - 이전 날 / 다음 날 버튼 기능 구현</span><br><span class="line">    - 오늘 날짜 표시 기능 구현 </span><br><span class="line">    - 오늘 날짜로 돌아가기 버튼 구현</span><br><span class="line">  - 일정 추가 버튼 구현</span><br><span class="line">  - 다양한 크기가 가능해야함</span><br><span class="line"></span><br><span class="line">  - 위젯 하단 일정 화면 구현</span><br><span class="line">    - 당일의 일정 리스트 가져오기 기능 구현</span><br><span class="line">    - 취소선이 그어진 일정은 가져오지 않음</span><br><span class="line">    - 체크박스 기능 구현</span><br><span class="line">      - 체크박스 클릭시 3초뒤에 위젯에서 삭제</span><br><span class="line"></span><br><span class="line">- 일정 추가 화면 구현</span><br><span class="line">  - 뒤로가기 버튼 구현</span><br><span class="line">  - 메모 작성칸 구현</span><br><span class="line">    - 화면 진입시 오토포커스</span><br><span class="line">    - 클릭시 키보드 출현, 내용 입력 가능</span><br><span class="line">  - 날짜 기능 구현</span><br><span class="line">    - 오늘 날짜 표시 기능 구현</span><br><span class="line">    - 이전 날 / 다음 날 버튼 기능 구현</span><br><span class="line">  - 하단에 취소 / 저장 버튼 구현</span><br><span class="line">  - 저장 기능 구현</span><br><span class="line">    - 저장시 해당된 날짜 기준으로 메모 내용 저장</span><br><span class="line">  - 무한 버튼 구현</span><br><span class="line">    - 무한 버튼이 활성화 되어있을경우 다음날로 넘어가면 다음날에 해당 일정이 추가됨</span><br></pre></td></tr></table></figure></li><li><p>디자인 정의<br><a href="https://ovenapp.io/view/FtMo0EjqM1EAdG6gLVrJHeTUPeW6bfOq/B4oxD" target="_blank" rel="noopener">앱 디자인화면</a><br>Oven.io 로 구현했다. 프로토타입 디자인하기에 최적의 사이트.</p><ol><li>메인화면</li><li>위젯화면</li><li>일정추가 화면</li></ol><p>크게 3개로 분류했고 [해당일정 관리화면]이 따로 필요할 경우 추가예정</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;개발자로써 커리어를 App 개발로 정했고, 시작으로 간단한 프로젝트를 진행한다.&lt;br&gt;이전에 앱 개발을 해본 경험을 바탕으로 
      
    
    </summary>
    
    
      <category term="Project" scheme="https://taeyeonkim93.github.io/categories/Project/"/>
    
      <category term="Android" scheme="https://taeyeonkim93.github.io/categories/Project/Android/"/>
    
    
      <category term="Android" scheme="https://taeyeonkim93.github.io/tags/Android/"/>
    
      <category term="App" scheme="https://taeyeonkim93.github.io/tags/App/"/>
    
      <category term="Kotlin" scheme="https://taeyeonkim93.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>[종만북] 책 내용 정리</title>
    <link href="https://taeyeonkim93.github.io/2019/10/09/etc-2019-10-09-jongman-book-study-1/"/>
    <id>https://taeyeonkim93.github.io/2019/10/09/etc-2019-10-09-jongman-book-study-1/</id>
    <published>2019-10-09T08:50:08.000Z</published>
    <updated>2019-10-10T13:20:10.039Z</updated>
    
    <content type="html"><![CDATA[<p>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 책 정리용</p><h3 id="알고리즘-문제를-푸는-방법"><a href="#알고리즘-문제를-푸는-방법" class="headerlink" title="알고리즘 문제를 푸는 방법"></a>알고리즘 문제를 푸는 방법</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 문제를 읽고 이해한다</span><br><span class="line">2. 문제를 익숙한 용어로 재정의한다</span><br><span class="line">3. 어떻게 해결할지 계획을 세운다</span><br><span class="line">4. 계획을 검증한다</span><br><span class="line">5. 프로그램으로 구현한다</span><br><span class="line">6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.</span><br></pre></td></tr></table></figure><ol><li>문제를 읽고 이해한다<ul><li>초보~고수까지 문제를 잘못읽는 경우가 다반사</li><li>문제의 궁극적인 목적, 사소한 제약조건까지 완벽하게 이해해야함</li></ul></li></ol><ol start="2"><li>재정의와 추상화<ul><li>자신이 다루기 쉬운 개념을 이용해서 자신의 언어로 풀어쓰기</li><li>현실세계의 개념을 우리가 다루기 쉬운 수학적/전산학점 개념으로 옮겨 표현</li></ul></li></ol><ol start="3"><li>계획 세우기<ul><li>사용할 알고리즘, 자료구조 선택</li></ul></li></ol><ol start="4"><li>계획 검증하기<ul><li>설계한 알고리즘이 모든 경우에 요구조건을 정확히 수행하는지 증명</li><li>수행에 걸리는 시간과 메모리가 문제의 제한 내에 들어가는지 확인</li></ul></li></ol><ol start="5"><li>계획 수행하기<ul><li>정확히 구현하기</li></ul></li></ol><ol start="6"><li>회고하기<ul><li>자신이 문제를 해결한 과정을 돌이켜보고 개선하기</li><li>문제를 풀 때마다 코드와 함께 자신의 경험을 기록으로 남겨야 함</li><li>문제의 간단한 해법과, 어떤 방식으로 접근했는지, 문제의 해법을 찾는데 결정적이었던 깨달음</li><li>한번에 맞추지 못한 경우는 오답 원인도 적는게 좋음</li><li>다른 사람의 코드를 보면서 공부하는것도 좋음</li></ul></li></ol><h3 id="문제를-풀지-못할-때"><a href="#문제를-풀지-못할-때" class="headerlink" title="문제를 풀지 못할 때"></a>문제를 풀지 못할 때</h3><p><strong># 직관과 체계적인 접근</strong></p><ul><li>직관은 해당 문제를 해결하는 알고리즘이 대략 어떤 형태를 가질지 짐작하게 함</li><li>어려운 문제들은 체계적으로 접근해야 함</li></ul><ol><li>비슷한 문제를 풀어본 적이 있던가?<ul><li>비슷한 문제를 풀어봤으면 이전 방법과 비슷한 접근방법을 사용할 것임</li><li>기존 문제를 경험으로 만들려면 원리를 완전히 이해하고 변형할 수 있어야 함</li><li>형태가 비슷하지 않더라도 문제의 목표가 같은 경우 또한 이에 소함</li><li>어떤 사건의 발생확률/경우의 수를 계산하는 문제는 대부분 동적계획법으로 해결 가능</li></ul></li></ol><ol start="2"><li>단순한 방법에서 시작할 수 있을까?<ul><li>무식하게 풀 수 있을까?</li><li>시간과 공간 제약을 생각하지 않고 문제를 해결해봄</li><li>점진적인 개선을 통해 알고리즘의 효율성을 증가시킴</li></ul></li></ol><ol start="3"><li>내가 손으로 문제를 푸는 과정을 수식화 할 수 있을까?<ul><li>번뜩이는 영감이 필요한 문제를 만났을때는 다른 방법을 시도해봐야한다.</li><li>손으로 여러 간단한 입력(문제에 주어진 예제 입력)을 직접 해결</li><li>문제를 해결하는 방법을 공식화해서 답을 만드는 알고리즘을 만들수 있는 경우가 있음</li><li>이 과정에서 알고리즘이 어떤 점을 고려해야하는지를 알게됨</li></ul></li></ol><ol start="4"><li>문제를 단순화할 수 있을까?<ul><li>좀더 쉬운 변형판을 먼저 풀어보기.</li><li>제약조건을 없애거나, 계산해야하는 변수를 줄이거나, 다차원의 문제를 1차원으로 줄이기도 함</li></ul></li></ol><ol start="5"><li>그림으로 그려볼 수 있을까?<ul><li>관련된 그림을 그려보면 더 쉬움</li></ul></li></ol><ol start="6"><li>수식으로 표현할 수 있을까?<ul><li>평문으로 쓰여있는 문제를 수식으로 표현하는 것도 도움이 됨</li></ul></li></ol><ol start="7"><li>문제를 분해할 수 있을까?<ul><li>문제의 제약조건을 분해할 수 있음</li></ul></li></ol><ol start="8"><li>뒤에서 생각해서 문제를 풀 수 있을까?<ul><li>모든 선택지를 위에서 아래로 내려가 보는 대신에 아래에서 위로 딱 한번만 하면 해결 가능</li></ul></li></ol><ol start="9"><li>순서를 강제할 수 있을까?<ul><li>순서가 없는 문제에 순서를 강제함</li><li>경우의 수를 셀 때도 유용함. 특정 조건을 만족하는 답들의 수를 세는 경우</li></ul></li></ol><ol start="10"><li>특정 형태의 답만을 고려할 수 있을까?<ul><li>정규화 기법이 있음</li><li>정규화란 우리가 고려해야 할 답들 중 형태가 다르지만 결과적으로 똑같은것들을 그룹으로 묶은 뒤, 각 그룹의 대표만을 고려하는 방법</li></ul></li></ol><h3 id="좋은-코드를-짜기-위한-원칙"><a href="#좋은-코드를-짜기-위한-원칙" class="headerlink" title="좋은 코드를 짜기 위한 원칙"></a>좋은 코드를 짜기 위한 원칙</h3><ol><li>간결한 코드를 작성하기<ul><li>가장 간결한 코드를 작성해야 오타나 버그가 생길 가능성이 적다</li></ul></li></ol><ol start="2"><li>적극적으로 코드 재사용하기<ul><li>같은 코드가 세번 이상 등장한다면 해당 코드를 함수로 분리해 재사용한다</li></ul></li></ol><ol start="3"><li>표준 라이브러리 공부하기<ul><li>시간낭비를 줄일 수 있으나 표준적인 알고리즘 구현 사용법을 잘 알아두기</li></ul></li></ol><ol start="4"><li>항상 같은 형태로 프로그램을 작성하기<ul><li>여러 종류의 반복적인 코드들(BFS, 2차원 자료구조 등)은 항상 같은것으로 사용하기</li></ul></li></ol><ol start="5"><li>일관적이고 명료한 명명법 사용하기<ul><li>모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이기</li><li>사용하는 언어의 표준 라이브러리에서 사용하는 명명규약을 익히기</li></ul></li></ol><ol start="6"><li>모든 자료를 정규화해서 저장하기<ul><li>같은 자료를 두가지 형태로 저장하지 않기</li><li>정규화는 프로그램이 자료를 입력받거나 계산하자마자 곧장 이루어져야 함</li><li>이상적으로는 자료를 표현하는 클래스의 생성자에서 정규화를 수행하거나 외부에서 자료를 입력받자마자 정규화를 하는게 좋음</li></ul></li></ol><ol start="7"><li>코드와 데이터를 분리하기<ul><li>정적 데이터 내용을 함수로 따로 만드는 행위를 하지 않기</li></ul></li></ol><h3 id="자주-하는-실수"><a href="#자주-하는-실수" class="headerlink" title="자주 하는 실수"></a>자주 하는 실수</h3><ol><li>산술 오버플로<ul><li>계산 과정에서 변수의 표현범위를 벗어나는 값을 사용</li></ul></li></ol><ol start="2"><li>배열 범위 밖 원소에 접근<ul><li>배열 크기를 정할때 계산을 신중하게 하기</li><li>0 시작범위와 1 시작범위 혼동하지않기</li></ul></li></ol><ol start="3"><li>일관되지않은 범위표현방식 사용하기<ul><li>[2,12] -&gt; 2~12 까지 자연수 표현, (2,12) -&gt; 3~11까지 자연수 표현</li><li>절충안으로 [lo, hi)를 사용함</li></ul></li></ol><ol start="4"><li>Off-by-one 오류<ul><li>반복문을 한번 더 많이 순회하거나 열린구간과 닫힌구간을 혼용해서 쓴 경우 많이 발생</li><li>입력이 주어졌을 때 코드가 어떻게 동작할지 되새겨보면서 프로그램 짜야함</li></ul></li></ol><ol start="5"><li>컴파일러가 잡아주지 못하는 상수 오타<ul><li>상수를 잘못 입력해서 생기는 오류</li></ul></li></ol><ol start="6"><li>스택 오버플로<ul><li>call stack이 오버플로해서 프로그램이 강제종료 되는것</li><li>재귀호출의 깊이가 너무 깊어지는게 대개 원인</li><li>스택 메모리가 적을때는 힙에 메모리를 할당하는게 좋음</li></ul></li></ol><ol start="7"><li>다차원 배열 인덱스 순서 바꿔서 쓰기<ul><li>특정 배열에 접근하는 위치를 하나로 통일하는것이 좋음</li></ul></li></ol><ol start="8"><li>잘못된 비교 함수 작성</li></ol><ol start="9"><li>최소, 최대 예외 잘못 다루기<ul><li>예외를 잘 처리해야 한다</li></ul></li></ol><ol start="10"><li>연산자 우선순위 잘못 쓰기<ul><li>시프트 연산자나 비트 단위 연산자들은 종종 헷갈림</li></ul></li></ol><ol start="11"><li>너무 느린 입출력 방식 선택<ul><li>gets()로 한꺼번에 받거나 cin으로 고수준 입력방식을 받을수도 있지만 느릴수 있기때문에 잘 선택해야함</li></ul></li></ol><ol start="12"><li>변수 초기화 문제<ul><li>이전 입력에 사용한 전역변수값을 초기화하지않고 그대로 사용함</li></ul></li></ol><h3 id="디버깅과-테스팅"><a href="#디버깅과-테스팅" class="headerlink" title="디버깅과 테스팅"></a>디버깅과 테스팅</h3><ol><li>디버깅에 관하여<ul><li>프로그래밍 대회용 소스코드는 대부분 짧기때문에 눈으로 하는것이 훨씬 빠름</li><li>재귀호출이나 중복 반복문을 자주 쓰면 디버깅하기에 힘듬</li><li>디버거 사용 대신 해야할 단계</li></ul><ol><li>작은 입력에 대해 제대로 실행되나 확인하기<ul><li>오동작하는 가장 작은 입력을 먼저 찾아내면 디버깅하기 훨씬 용이함</li></ul></li><li>단정문을 쓴다<ul><li>주어진 조건이 거짓일때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문</li></ul></li><li>프로그램의 계산 중간겨로가를 출력한다<ul><li>중간과정 값들을 출력하고 자신이 예상하는 바와 맞아들어가는지 검사하기</li></ul></li></ol><ul><li>디버거를 사용하는 좋은 예는 프로그램이 런타임 오류를 내고 종료하는 경우</li></ul></li></ol><ol start="2"><li>테스트에 관하여<ul><li>제출 전에 예제 입력을 만들어 가능한 많이 프로그램을 테스트하는것이 좋음</li><li>스캐폴딩 방법을 이용해 검증한다.(다른 코드를 개발할때 뼈대를 잡기위해 임시로 사용하는 코드)</li></ul></li></ol><h4 id="변수-범위의-이해"><a href="#변수-범위의-이해" class="headerlink" title="변수 범위의 이해"></a>변수 범위의 이해</h4><ol><li>산술 오버플로<ul><li>어떤 식의 계산값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우</li></ul></li></ol><ol start="2"><li>너무 큰 결과<ul><li>프로그램이 출력해야할 결과가 너무 크면 안됨</li></ul></li></ol><ol start="3"><li>너무 큰 중간값<ul><li>계산식 도중에 값이 자료형의 크기를 넘는 경우가 있음</li></ul></li></ol><ol start="4"><li>너무 큰 무한대값<ul><li>무한대 값을 이용해 특수한값으로 사용할때는 무한대값들이 서로 더해지거나 곱해지는 경우가 없는지 잘 살펴봐야함.</li></ul></li></ol><ol start="5"><li>오버플로 피해가기<ul><li>자료형 큰거로 바꾸기</li><li>계산 순서 바꾸기</li><li>점화식 이용하기</li></ul></li></ol><ol start="6"><li>자료형의 프로모션<ul><li>자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러가 자동으로 변환하는것을 프로모션이라 함</li><li>자동으로 형변환되는 숫자들에 대한 주의가 필요함</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;프로그래밍 대회에서 배우는 알고리즘 문제해결전략 책 정리용&lt;/p&gt;
&lt;h3 id=&quot;알고리즘-문제를-푸는-방법&quot;&gt;&lt;a href=&quot;#알고리즘-문제를-푸는-방법&quot; class=&quot;headerlink&quot; title=&quot;알고리즘 문제를 푸는 방법&quot;&gt;&lt;/a&gt;알고리즘
      
    
    </summary>
    
    
      <category term="etc" scheme="https://taeyeonkim93.github.io/categories/etc/"/>
    
      <category term="Private" scheme="https://taeyeonkim93.github.io/categories/etc/Private/"/>
    
    
      <category term="공부정리" scheme="https://taeyeonkim93.github.io/tags/%EA%B3%B5%EB%B6%80%EC%A0%95%EB%A6%AC/"/>
    
      <category term="종만북" scheme="https://taeyeonkim93.github.io/tags/%EC%A2%85%EB%A7%8C%EB%B6%81/"/>
    
  </entry>
  
  <entry>
    <title>[프로그래머스] 코딩테스트 풀이 - 큰 수 만들기</title>
    <link href="https://taeyeonkim93.github.io/2019/10/02/Algorithm-2019-10-02-programmers-coding-test-9/"/>
    <id>https://taeyeonkim93.github.io/2019/10/02/Algorithm-2019-10-02-programmers-coding-test-9/</id>
    <published>2019-10-02T08:42:30.000Z</published>
    <updated>2019-10-03T12:21:23.628Z</updated>
    
    <content type="html"><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/courses/30/lessons/42883" target="_blank" rel="noopener">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.</p><p>예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.</p><p>문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.</li><li>k는 1 이상 number의 자릿수 미만인 자연수입니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">name</th><th align="left">k</th><th align="left">return</th></tr></thead><tbody><tr><td align="left">“1924”</td><td align="left">2</td><td align="left">“94”</td></tr><tr><td align="left">“1231234”</td><td align="left">3</td><td align="left">“3234”</td></tr><tr><td align="left">“4177252841”</td><td align="left">4</td><td align="left">“775841”</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">만들 수 있는 숫자 중 가장 큰 숫자의 [문자열]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. name 문자열</span><br><span class="line">2. 문자열에서 제거할 숫자의 갯수</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line">- 앞에서 뒤로 제거하는 방식</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 만들 문자열 길이(전체길이 - k) 만큼의 배열리스트 내에서 최대값을 찾는다.</span><br><span class="line">2. answer에 최대값을 저장하고 최대값과 그 이전의 값들을 다 없앤다.</span><br><span class="line">3. 만들 문자열 길이 -1 을 하고 다시 리스트 내에서 최대값을 찾는다.</span><br><span class="line">4. 만들 문자열 길이가 0이면 반환한다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>위와 같은 알고리즘으로 답은 나왔으나 테스트케이스 중 시간초과로 해결하지 못한 케이스가 있었다.<br>찾아보니 스택으로 처리해야 한다는데 생각보다 간단해서 김이 빠졌다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(number, k)</span>:</span></span><br><span class="line">    collected = []</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(number):</span><br><span class="line">        <span class="keyword">while</span> len(collected) &gt; <span class="number">0</span> <span class="keyword">and</span> collected[<span class="number">-1</span>] &lt; num <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            collected.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            collected += list(number[i:])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        collected.append(num)</span><br><span class="line">    collected = collected[:-k] <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">else</span> collected</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(collected)</span><br></pre></td></tr></table></figure><p>풀고 난 이후에 다른 사람들의 풀이를 봐도 매번 최대값을 찾는 풀이는 없었고 모두 스택으로 해결한것 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 알고리즘</span><br><span class="line"></span><br><span class="line">1. numbers 의 값들을 순회한다.</span><br><span class="line">  1. 스택에 값이 있는지 확인한다.</span><br><span class="line">    T : 제일 위 스택이 현재값보다 작은지 확인한다</span><br><span class="line">      T : k값이 0보다 큰지 확인한다.</span><br><span class="line">        T : 스택의 값을 제거하고 k = k - 1 해준다.</span><br><span class="line">  2. k값이 0인지 확인한다.</span><br><span class="line">    T : 남은 number 리스트의 값들을 모두 뒤에 추가하고 break 한다</span><br><span class="line">  3. 현재값보다 스택이 큰지 확인한다.</span><br><span class="line">    T : 스택에 현재값을 넣는다</span><br><span class="line"></span><br><span class="line">2. numbers 에서 k값이 0이 안됐을 경우 ([5,4,3,2,1] , [2])</span><br><span class="line">  T : 스택에서 뽑아야 할 문자열의 갯수만큼 뽑아낸다.</span><br><span class="line">  F : 스택 그대로 출력한다.</span><br></pre></td></tr></table></figure><p>스택을 활용한 방법이 O(n)이라 매우 빠르다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42883&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프로그래머스 코딩 테스트 연습&lt;/a&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://taeyeonkim93.github.io/categories/Algorithm/"/>
    
      <category term="프로그래머스" scheme="https://taeyeonkim93.github.io/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
    
      <category term="ALGORITHM" scheme="https://taeyeonkim93.github.io/tags/ALGORITHM/"/>
    
      <category term="CODING TEST" scheme="https://taeyeonkim93.github.io/tags/CODING-TEST/"/>
    
      <category term="PYTHON" scheme="https://taeyeonkim93.github.io/tags/PYTHON/"/>
    
      <category term="STACK" scheme="https://taeyeonkim93.github.io/tags/STACK/"/>
    
  </entry>
  
  <entry>
    <title>[프로그래머스] 코딩테스트 풀이 - 조이스틱</title>
    <link href="https://taeyeonkim93.github.io/2019/10/02/Algorithm-2019-10-02-programmers-coding-test-8/"/>
    <id>https://taeyeonkim93.github.io/2019/10/02/Algorithm-2019-10-02-programmers-coding-test-8/</id>
    <published>2019-10-02T05:58:32.000Z</published>
    <updated>2019-10-03T12:21:23.620Z</updated>
    
    <content type="html"><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/courses/30/lessons/42860" target="_blank" rel="noopener">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.<br>ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA</p><p>조이스틱을 각 방향으로 움직이면 아래와 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">▲ - 다음 알파벳</span><br><span class="line">▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)</span><br><span class="line">◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)</span><br><span class="line">▶ - 커서를 오른쪽으로 이동</span><br></pre></td></tr></table></figure><p>예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.</span><br><span class="line">- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.</span><br><span class="line">- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.</span><br><span class="line">따라서 11번 이동시켜 &quot;JAZ&quot;를 만들 수 있고, 이때가 최소 이동입니다.</span><br></pre></td></tr></table></figure><p>만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>name은 알파벳 대문자로만 이루어져 있습니다.</li><li>name의 길이는 1 이상 20 이하입니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">name</th><th>return</th></tr></thead><tbody><tr><td align="left">“JEROEN”</td><td>56</td></tr><tr><td align="left">“JAN”</td><td>23</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">조이스틱 조작 횟수의 [최솟값]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 조이스틱 조작방식에 대한 정보</span><br><span class="line">2. 만들어야하는 이름의 정보</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line">- 알파벳 대문자로만 이루어져 있음</span><br><span class="line">- 길이가 1~20까지</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. Greedy 알고리즘을 사용해서 각 칸의 최적해를 찾아낸다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>매 Case 마다 최적값이 달라지므로 Greedy 알고리즘을 사용해서 푸는 문제이다.<br>그때그때 최적의 해를 찾아서 푸는 문제이므로 각 칸에서의 최적해를 구하는 방식을 찾는다.</p><ul><li><p>왼쪽/오른쪽 중 어떤 조작을 해야 알파벳을 빨리 찾을 수 있는지 조건을 넣는다.</p><ul><li>A가 아닌 알파벳에 가장 가까운 방향으로 진행시킨다.<ol><li>현재값이 A가 아니면 위아래 조작으로 넘어간다</li><li>현재값이 A일 경우 A가 아닌 값이 왼쪽으로 몇번째에 있는지 찾는다.</li><li>현재값이 A일 경우 A가 아닌 값이 오른쪽으로 몇번째에 있는지 찾는다.</li><li>두 값을 비교하고 이동횟수가 적은쪽으로 이동하고 A 갯수만큼 answer에 값을 추가한다.</li></ol></li></ul></li><li><p>위/아래 중 어떤 조작을 해야 알파벳을 빨리 찾을 수 있는지 조건을 넣는다.</p><ul><li>A~Z의 중간값인 N(위 13회, 아래 13회) 을 기준으로 나눈다.<ol><li>name 문자가 N보다 크거나 같으면 아래, 작으면 위 if문으로 들어간다.<ol><li>name 문자가 N보다 작을 때 아스키코드와 A의 아스키코드를 빼서 차 값을 answer에 넣는다</li><li>name 문자가 N보다 크거나 같을 때 아스키코드와 Z+1의 아스키코드를 빼서 차 값을 answer에 넣는다</li></ol></li></ol></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(name)</span>:</span></span><br><span class="line">     answer = <span class="number">0</span></span><br><span class="line">     name = list(name)</span><br><span class="line">     base = [<span class="string">"A"</span>] * len(name)</span><br><span class="line">     idx = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         rIndex = <span class="number">1</span></span><br><span class="line">         lIndex = <span class="number">1</span></span><br><span class="line">         <span class="keyword">if</span> name[idx] != <span class="string">"A"</span>:</span><br><span class="line">             <span class="keyword">if</span> name[idx] &lt; <span class="string">"N"</span>:</span><br><span class="line">                 answer += ord(name[idx]) - <span class="number">65</span></span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 answer += <span class="number">91</span> - ord(name[idx])</span><br><span class="line">             name[idx]=<span class="string">"A"</span></span><br><span class="line">         <span class="keyword">if</span> name == base:</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(name)):</span><br><span class="line">                 <span class="keyword">if</span> name[idx + i] == <span class="string">"A"</span>:</span><br><span class="line">                     rIndex += <span class="number">1</span></span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                 <span class="keyword">if</span> name[idx - i] == <span class="string">"A"</span>:</span><br><span class="line">                     lIndex += <span class="number">1</span></span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">             <span class="keyword">if</span> rIndex &gt; lIndex:</span><br><span class="line">                 answer += lIndex</span><br><span class="line">                 idx -= lIndex</span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 answer += rIndex</span><br><span class="line">                 idx += rIndex</span><br><span class="line">     <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42860&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프로그래머스 코딩 테스트 연습&lt;/a&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://taeyeonkim93.github.io/categories/Algorithm/"/>
    
      <category term="프로그래머스" scheme="https://taeyeonkim93.github.io/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
    
      <category term="ALGORITHM" scheme="https://taeyeonkim93.github.io/tags/ALGORITHM/"/>
    
      <category term="CODING TEST" scheme="https://taeyeonkim93.github.io/tags/CODING-TEST/"/>
    
      <category term="PYTHON" scheme="https://taeyeonkim93.github.io/tags/PYTHON/"/>
    
      <category term="GREEDY" scheme="https://taeyeonkim93.github.io/tags/GREEDY/"/>
    
  </entry>
  
  <entry>
    <title>[프로그래머스] 코딩테스트 풀이 - 쇠막대기</title>
    <link href="https://taeyeonkim93.github.io/2019/10/01/Algorithm-2019-10-01-programmers-coding-test-7/"/>
    <id>https://taeyeonkim93.github.io/2019/10/01/Algorithm-2019-10-01-programmers-coding-test-7/</id>
    <published>2019-10-01T12:31:51.000Z</published>
    <updated>2019-10-03T12:21:23.615Z</updated>
    
    <content type="html"><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/courses/30/lessons/42585" target="_blank" rel="noopener">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>문제 설명<br>여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다.</p><ul><li>쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.</li><li>쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.</li><li>각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.</li><li>레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.<br>아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다.</li></ul><p><img src="/images/coding-test/7-1.png" alt></p><p>이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 &apos;()&apos;으로 표현합니다. 또한 모든 &apos;()&apos;는 반드시 레이저를 표현합니다.</span><br><span class="line">(b) 쇠막대기의 왼쪽 끝은 여는 괄호 &apos;(&apos;로, 오른쪽 끝은 닫힌 괄호 &apos;)&apos;로 표현됩니다.</span><br></pre></td></tr></table></figure><p>위 예의 괄호 표현은 그림 위에 주어져 있습니다.<br>쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다.</p><p>쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>arrangement의 길이는 최대 100,000입니다.</li><li>arrangement의 여는 괄호와 닫는 괄호는 항상 쌍을 이룹니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">arrangement</th><th>return</th></tr></thead><tbody><tr><td align="left">“()(((()())(())()))(())”</td><td>17</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">잘린 쇠막대기 조각의 총 [개수]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 쇠막대기와 레이저의 배치를 표현한 arrangement</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line"></span><br><span class="line">- 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.</span><br><span class="line">- 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.</span><br><span class="line">- 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.</span><br><span class="line">- 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 레이저와 쇠막대기의 상관관계와 규칙을 찾아낸다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>스택을 활용해서 푸는 문제이다.<br>간단하게 규칙을 이용해서 공식을 찾아낼수도 있지만</p><ul><li>(쇠막대기 갯수 + 쇠막대기 갯수 * 레이저 갯수 = 조각 갯수)</li></ul><p>문제 의도에 맞게 스택으로 풀이한다.</p><p><strong>알고리즘</strong></p><ol><li><code>isLaser</code> 변수를 True 로 놓는다.</li><li>스택에 <code>arrangement</code> 의 내부 기호를 쌓는다.<ol><li>만약 <code>isLaser</code> 가 True 인데 ) 기호가 들어올 경우 <code>isLaser</code> 을 False 로 바꾸고 가장 위에있던 ( 기호를 제거하고 스택에 남아있던 ( 기호만큼 쇠막대기 갯수를 증가시킨다.</li><li>만약 <code>isLaser</code> 가 False 인데 ) 기호가 들어올 경우 가장 위에있던 ( 기호를 제거하고 쇠막대기 갯수를 1만큼 증가시킨다</li><li>만약 <code>isLaser</code> 가 True 인데 ( 기호가 들어올 경우 스택에 쌓는다.</li><li>만약 <code>isLaser</code> 가 False 인데 ( 기호가 들어올 경우 <code>isLaser</code> 을 True 로 변경하고 그대로 스택에 쌓는다.</li></ol></li><li>쌓인 쇠막대기 갯수를 return 한다. </li></ol><p>insert 와 pop 을 행할 시 결과값이 어떻게 바뀌는지 주의하면서 알고리즘을 짠다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(arrangement)</span>:</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    isLaser = <span class="literal">True</span></span><br><span class="line">    steel_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> bracket <span class="keyword">in</span> arrangement:</span><br><span class="line">        <span class="keyword">if</span> isLaser <span class="keyword">and</span> bracket == <span class="string">")"</span>:</span><br><span class="line">            isLaser = <span class="literal">False</span></span><br><span class="line">            steel_stack.pop()</span><br><span class="line">            answer += len(steel_stack)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> isLaser <span class="keyword">and</span> bracket == <span class="string">")"</span>:</span><br><span class="line">            answer += <span class="number">1</span></span><br><span class="line">            steel_stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> isLaser <span class="keyword">and</span> bracket == <span class="string">"("</span>:</span><br><span class="line">            steel_stack.append(bracket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            isLaser = <span class="literal">True</span></span><br><span class="line">            steel_stack.append(bracket)</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h2 id="다른-풀이"><a href="#다른-풀이" class="headerlink" title="다른 풀이"></a>다른 풀이</h2><p>스택을 활용한 방법과 replace를 이용해 레이저를 다른 변수로 바꿔버린 풀이가 있다.</p><p>레이저 부분을 P로 치환해서 해결한 사례. 그외에는 스택을 이용해서 비슷하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(arrangement)</span>:</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    stack = []</span><br><span class="line">    arrangement = arrangement.replace(<span class="string">"()"</span>,<span class="string">"P"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> arr <span class="keyword">in</span> arrangement:</span><br><span class="line">        <span class="keyword">if</span> arr == <span class="string">'('</span>:</span><br><span class="line">            stack.append(arr)</span><br><span class="line">            answer +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr == <span class="string">')'</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += len(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42585&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프로그래머스 코딩 테스트 연습&lt;/a&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://taeyeonkim93.github.io/categories/Algorithm/"/>
    
      <category term="프로그래머스" scheme="https://taeyeonkim93.github.io/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
    
      <category term="ALGORITHM" scheme="https://taeyeonkim93.github.io/tags/ALGORITHM/"/>
    
      <category term="CODING TEST" scheme="https://taeyeonkim93.github.io/tags/CODING-TEST/"/>
    
      <category term="PYTHON" scheme="https://taeyeonkim93.github.io/tags/PYTHON/"/>
    
      <category term="STACK" scheme="https://taeyeonkim93.github.io/tags/STACK/"/>
    
  </entry>
  
  <entry>
    <title>[프로그래머스] 코딩테스트 풀이 - 탑</title>
    <link href="https://taeyeonkim93.github.io/2019/10/01/Algorithm-2019-10-01-programmers-coding-test-6/"/>
    <id>https://taeyeonkim93.github.io/2019/10/01/Algorithm-2019-10-01-programmers-coding-test-6/</id>
    <published>2019-10-01T11:48:41.000Z</published>
    <updated>2019-10-03T12:21:23.624Z</updated>
    
    <content type="html"><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/challenges" target="_blank" rel="noopener">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다.</p><p>예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다.</p><table><thead><tr><th>송신 탑(높이)</th><th>수신 탑(높이)</th></tr></thead><tbody><tr><td>5(4)</td><td>4(7)</td></tr><tr><td>4(7)</td><td>2(9)</td></tr><tr><td>3(5)</td><td>2(9)</td></tr><tr><td>2(9)</td><td>-</td></tr><tr><td>1(6)</td><td>-</td></tr></tbody></table><p>맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return 하도록 solution 함수를 작성해주세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>heights는 길이 2 이상 100 이하인 정수 배열입니다.</li><li>모든 탑의 높이는 1 이상 100 이하입니다.</li><li>신호를 수신하는 탑이 없으면 0으로 표시합니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">heights</th><th>return</th></tr></thead><tbody><tr><td align="left">[6,9,5,7,4]</td><td>[0,0,2,2,4]</td></tr><tr><td align="left">[3,9,9,3,5,7,2]</td><td>[0,0,0,3,3,3,6]</td></tr><tr><td align="left">[1,5,3,6,7,6,5]</td><td>[0,0,2,0,0,5,6]</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 탑의 길이</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line"></span><br><span class="line">1. 신호를 수신하는 탑이 없으면 0으로 표시</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 0번째 탑은 항상 수신하지 못한다.</span><br><span class="line">2. 현재 탑의 왼쪽이 현재 탑의 높이보다 높은지 체크하고 높으면 배열에 넣는다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>간단하게 2중 for문을 사용해서 풀어주었다.<br>이번 예제를 통해 <code>for else</code>문을 알게되었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(heights)</span>:</span></span><br><span class="line">    answer = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(heights):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> heights[j] &gt; num:</span><br><span class="line">                answer.append(j + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h2 id="다른-풀이"><a href="#다른-풀이" class="headerlink" title="다른 풀이"></a>다른 풀이</h2><h4 id="1-2중-for문"><a href="#1-2중-for문" class="headerlink" title="1. 2중 for문"></a>1. 2중 for문</h4><p>0을 먼저 선언해준뒤에 비교했다는 사실을 빼면 차이 없음.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(h)</span>:</span></span><br><span class="line">    ans = [<span class="number">0</span>] * len(h)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> h[i] &lt; h[j]:</span><br><span class="line">                ans[i] = j+<span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="2-스택을-사용한-방법"><a href="#2-스택을-사용한-방법" class="headerlink" title="2. 스택을 사용한 방법"></a>2. 스택을 사용한 방법</h4><p>문제 의도가 스택인것같아 한번 더 봤다.<br>기본적으로는 비슷하지만 pop 을 이용해서 공간을 덜 먹는다는게 장점인듯</p><ol><li>스택을 만들어주고 LIFO 법칙에 따라 가장 마지막 배열을 현재의 탑으로 잡고 배열에서 없앤다.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(heights)</span>:</span></span><br><span class="line">    responses = []</span><br><span class="line">    <span class="keyword">while</span> heights:</span><br><span class="line">        top = heights.pop()</span><br></pre></td></tr></table></figure><ol start="2"><li>현재의 탑의 길이보다 -1부터 내려가면서 탐색한다. 있으면 answer에 append한다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> top &lt; heights[i]:</span><br><span class="line">            responses.append(i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        responses.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> responses[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프로그래머스 코딩 테스트 연습&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;문제-설명&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://taeyeonkim93.github.io/categories/Algorithm/"/>
    
      <category term="프로그래머스" scheme="https://taeyeonkim93.github.io/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
    
      <category term="ALGORITHM" scheme="https://taeyeonkim93.github.io/tags/ALGORITHM/"/>
    
      <category term="CODING TEST" scheme="https://taeyeonkim93.github.io/tags/CODING-TEST/"/>
    
      <category term="PYTHON" scheme="https://taeyeonkim93.github.io/tags/PYTHON/"/>
    
      <category term="STACK" scheme="https://taeyeonkim93.github.io/tags/STACK/"/>
    
  </entry>
  
  <entry>
    <title>[프로그래머스] 코딩테스트 풀이 - 124 나라의 숫자</title>
    <link href="https://taeyeonkim93.github.io/2019/10/01/Algorithm-2019-10-01-programmers-coding-test-5/"/>
    <id>https://taeyeonkim93.github.io/2019/10/01/Algorithm-2019-10-01-programmers-coding-test-5/</id>
    <published>2019-10-01T07:29:56.000Z</published>
    <updated>2019-10-01T10:18:55.623Z</updated>
    
    <content type="html"><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/challenges" target="_blank" rel="noopener">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.</p><ol><li>124 나라에는 자연수만 존재합니다.</li><li>124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다.</li></ol><p>예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다.</p><table><thead><tr><th align="center">10진법</th><th align="center">124나라</th><th align="center">10진법</th><th align="center">124나라</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">14</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">7</td><td align="center">21</td></tr><tr><td align="center">3</td><td align="center">4</td><td align="center">8</td><td align="center">22</td></tr><tr><td align="center">4</td><td align="center">11</td><td align="center">9</td><td align="center">24</td></tr><tr><td align="center">5</td><td align="center">12</td><td align="center">10</td><td align="center">41</td></tr></tbody></table><p>자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>n은 500,000,000이하의 자연수 입니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">n</th><th>result</th></tr></thead><tbody><tr><td align="left">1</td><td>1</td></tr><tr><td align="left">2</td><td>2</td></tr><tr><td align="left">3</td><td>4</td></tr><tr><td align="left">4</td><td>11</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">자연수 n을 124나라에서 사용하는 숫자로 변환한 [값]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 124 나라에서 사용된 10진법 데이터</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 124나라에서 10진법을 변환하는 규칙을 찾는다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>사용언어 : Python 3</p><p>주먹구구로 규칙을 찾아서 풀었다.<br>머리가 문제인가 경험이 문제인가..</p><p>1,2,4 총 3개의 값으로 계속 순환되고 있으므로</p><table><thead><tr><th>10진법</th><th>124나라</th><th>몫</th></tr></thead><tbody><tr><td>0</td><td>x</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>2</td><td>2</td><td>0</td></tr><tr><td>3</td><td>4</td><td>1</td></tr><tr><td>4</td><td>11</td><td>1</td></tr><tr><td>5</td><td>12</td><td>1</td></tr><tr><td>6</td><td>14</td><td>2</td></tr><tr><td>7</td><td>21</td><td>2</td></tr><tr><td>8</td><td>22</td><td>2</td></tr><tr><td>9</td><td>24</td><td>3</td></tr><tr><td>10</td><td>41</td><td>3</td></tr><tr><td>11</td><td>42</td><td>3</td></tr><tr><td>12</td><td>44</td><td>4</td></tr><tr><td>13</td><td>111</td><td>4</td></tr><tr><td>14</td><td>112</td><td>4</td></tr><tr><td>15</td><td>114</td><td>5</td></tr></tbody></table><p>몫이 0일때까지 3으로 나눈다.</p><p>이때 3으로 나누기가 가능한 만큼 자릿수를 추가한다.</p><p>몫-1이 0이면 자릿수 1개<br>몫-1이 1~3이면 자릿수 2개<br>몫-1이 4~8이면 자릿수 3개</p><p>인 규칙을 발견할수 있다.</p><h4 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(n)</span>:</span></span><br><span class="line">    answer = <span class="string">''</span></span><br><span class="line">    pattern = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    chk = n</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    answer = str(pattern[(chk % <span class="number">3</span>)]) + answer</span><br><span class="line">    <span class="comment"># 나누고 남은 나머지값이 들어간다. chk는 1,2,0 순으로 순환된다.</span></span><br><span class="line">    chk = int((chk - <span class="number">1</span>)//<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 자릿수를 파악한다.</span></span><br><span class="line">    n = int(n // <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 나머지를 찾기위한 n의 값을 계산한다.</span></span><br><span class="line">    <span class="keyword">if</span> chk == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 더이상 계산할 자릿수가 없을때 break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h2 id="다른-풀이"><a href="#다른-풀이" class="headerlink" title="다른 풀이"></a>다른 풀이</h2><p>n에서 1을 뺄 경우 쉬운 규칙으로 변하는 부분을 잘 캐치하였다.<br>chk 라는 변수를 따로 선언해서 삽질하지 않은 부분이 가장 크게 다른 부분.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(n)</span>:</span></span><br><span class="line">    num = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>]</span><br><span class="line">    answer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        answer = num[n % <span class="number">3</span>] + answer</span><br><span class="line">        n = n // <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프로그래머스 코딩 테스트 연습&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;문제-설명&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://taeyeonkim93.github.io/categories/Algorithm/"/>
    
      <category term="프로그래머스" scheme="https://taeyeonkim93.github.io/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
    
      <category term="ALGORITHM" scheme="https://taeyeonkim93.github.io/tags/ALGORITHM/"/>
    
      <category term="CODING TEST" scheme="https://taeyeonkim93.github.io/tags/CODING-TEST/"/>
    
      <category term="PYTHON" scheme="https://taeyeonkim93.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>[프로그래머스] 코딩테스트 풀이 - 기능개발</title>
    <link href="https://taeyeonkim93.github.io/2019/09/24/Algorithm-2019-09-24-programmers-coding-test-4/"/>
    <id>https://taeyeonkim93.github.io/2019/09/24/Algorithm-2019-09-24-programmers-coding-test-4/</id>
    <published>2019-09-24T10:20:02.000Z</published>
    <updated>2019-10-01T07:02:30.511Z</updated>
    
    <content type="html"><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/challenges" target="_blank" rel="noopener">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.</p><p>또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.</p><p>먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.</li><li>작업 진도는 100 미만의 자연수입니다.</li><li>작업 속도는 100 이하의 자연수입니다.</li><li>배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">progresses</th><th align="left">speeds</th><th>return</th></tr></thead><tbody><tr><td align="left">[93,30,55]</td><td align="left">[1,30,5]</td><td>[2,1]</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">특정 순서로 이루어진, 작업이 끝나서 배포한 작업의 [갯수]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 작업의 배포순서가 적힌 리스트</span><br><span class="line">2. 작업의 개발 속도</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line"></span><br><span class="line">1. 배포는 하루에 한번만 가능</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 작업 리스트를 큐에 집어넣는다</span><br><span class="line">2. 각 작업별 스피드를 작업 진척도에 더하다가 </span><br><span class="line">   큐에서 제일 처음에 넣은 작업이 완료됐을경우 완료된 작업을 빼내고 카운트한다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>사용언어 : Python 3</p><p>전형적인 Queue의 가장 쉬운 예제로 볼 수 있다.<br>작업이 모두 완료됐을 때의 날짜를 가지고 끝난 작업의 개수를 계산하는 방법도 있다</p><h4 id="Queue를-사용하는-방법"><a href="#Queue를-사용하는-방법" class="headerlink" title="Queue를 사용하는 방법"></a>Queue를 사용하는 방법</h4><ol><li><p>작업 리스트를 큐에 집어넣는다 (이미 주어진 progresses 배열이 Queue 자료구조로 되어있는 상태)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(progresses, speeds)</span>:</span></span><br><span class="line">    answer = []</span><br></pre></td></tr></table></figure></li><li><p>각 작업별 진척도를 작업에 더한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> progresses:</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> progresses[<span class="number">0</span>] &lt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">for</span> idx, speed <span class="keyword">in</span> enumerate(speeds):</span><br><span class="line">            progresses[idx] += speed</span><br></pre></td></tr></table></figure></li><li><p>가장 앞의 작업의 진척도가 100이상일 경우, 작업의 진척도가 100인 자료들을 모두 꺼낸다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> progresses <span class="keyword">and</span> progresses[<span class="number">0</span>] &gt;= <span class="number">100</span>:</span><br><span class="line">            progresses.pop(<span class="number">0</span>)</span><br><span class="line">            speeds.pop(<span class="number">0</span>)</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        answer.append(result)</span><br><span class="line"><span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure></li></ol><h4 id="완료된-작업의-소요시간으로-계산하는-방법"><a href="#완료된-작업의-소요시간으로-계산하는-방법" class="headerlink" title="완료된 작업의 소요시간으로 계산하는 방법"></a>완료된 작업의 소요시간으로 계산하는 방법</h4><ol><li><p>마지막 작업이 걸린 소요시간을 계산한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(progresses, speeds)</span>:</span></span><br><span class="line">    Q = []</span><br><span class="line">    <span class="keyword">for</span> p, s <span class="keyword">in</span> zip(progresses, speeds): </span><br><span class="line">    <span class="comment"># p : progresses, s : speeds</span></span><br><span class="line">        <span class="keyword">if</span> len(Q) == <span class="number">0</span> <span class="keyword">or</span> Q[<span class="number">-1</span>][<span class="number">0</span>] &lt; -((p - <span class="number">100</span>) // s):</span><br><span class="line">        <span class="comment"># 배열이 하나도 없거나, 현재 작업이 마지막 작업보다 소요시간이 더 길 경우</span></span><br><span class="line">            Q.append([-((p - <span class="number">100</span>) // s), <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 큐에 추가한다.</span></span><br></pre></td></tr></table></figure></li><li><p>현재 작업이 마지막 작업보다 소요시간이 적은 작업일 경우, 마지막 작업이 배포될 날의 개수에 추가한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 현재 작업이 마지막 작업보다 소요시간이 더 작을경우</span></span><br><span class="line">        Q[<span class="number">-1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> [q[<span class="number">1</span>] <span class="keyword">for</span> q <span class="keyword">in</span> Q]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프로그래머스 코딩 테스트 연습&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;문제-설명&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://taeyeonkim93.github.io/categories/Algorithm/"/>
    
      <category term="프로그래머스" scheme="https://taeyeonkim93.github.io/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
    
      <category term="ALGORITHM" scheme="https://taeyeonkim93.github.io/tags/ALGORITHM/"/>
    
      <category term="CODING TEST" scheme="https://taeyeonkim93.github.io/tags/CODING-TEST/"/>
    
      <category term="PYTHON" scheme="https://taeyeonkim93.github.io/tags/PYTHON/"/>
    
      <category term="QUEUE" scheme="https://taeyeonkim93.github.io/tags/QUEUE/"/>
    
  </entry>
  
  <entry>
    <title>[프로그래머스] 코딩테스트 풀이 - 모의고사</title>
    <link href="https://taeyeonkim93.github.io/2019/09/18/Algorithm-2019-09-18-programmers-coding-test-3/"/>
    <id>https://taeyeonkim93.github.io/2019/09/18/Algorithm-2019-09-18-programmers-coding-test-3/</id>
    <published>2019-09-18T07:06:05.000Z</published>
    <updated>2019-10-03T12:21:23.612Z</updated>
    
    <content type="html"><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/challenges" target="_blank" rel="noopener">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.</p><p>1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …<br>2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …<br>3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, …</p><p>1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>시험은 최대 10,000 문제로 구성되어있습니다.</li><li>문제의 정답은 1, 2, 3, 4, 5중 하나입니다.</li><li>가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">answers</th><th align="left">return</th></tr></thead><tbody><tr><td align="left">[1,2,3,4,5]</td><td align="left">[1]</td></tr><tr><td align="left">[1,3,2,4,2]</td><td align="left">[1,2,3]</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">가장 높은 점수를 받은 [사람 번호]</span><br><span class="line">동점일경우 오름차순 정렬</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 3명의 수포자의 찍는 방식</span><br><span class="line"> - 1번 : 1~5까지 반복</span><br><span class="line"> - 2번 : 홀수번째는 2, 짝수번째는 2를 제외한 1~5 반복</span><br><span class="line"> - 3번 : 3,1,2,4,5를 각 2번씩 반복</span><br><span class="line"></span><br><span class="line">2. 정답 데이터</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line"></span><br><span class="line">1. 최대 문제 갯수(1만문제)</span><br><span class="line">2. 문제 정답 제한 (1~5)</span><br><span class="line">3. 동점자가 있을경우 오름차순 정렬</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 정답마다 각 인원의 배열을 비교한다</span><br></pre></td></tr></table></figure></li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>사용언어 : Python 3</p><p>answers 리스트를 수포자의 답과 비교해야되는데 answers의 값이 무작위로 들어있으므로 완전탐색으로 풀어야 한다.</p><p>완전탐색이 카테고리인 문제를 푸는 방법은</p><ul><li>Brute Force (무작위 대입)</li><li>DFS (깊이 우선 탐색)</li><li>BFS (너비 우선 탐색)</li><li>백트래킹</li></ul><p>정도가 있다. 자세한건 타 포스팅 참조</p><ul><li><a href="https://taeyeonkim93.github.io/2019/09/18/exhaustive-search-algorithm/">완전탐색 알고리즘 정리</a></li></ul><p>변수자체가 한개밖에 없으므로 단순하게 무작위대입으로 푸는것이 좋다.</p><p>1~3번까지의 반복되는 숫자의 패턴자체가 정해져있으므로 먼저 패턴을 정의한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(answers)</span>:</span></span><br><span class="line">    pattern1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    pattern2 = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">    pattern3 = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>그 뒤는 알고리즘에 따라 변수를 정의한다.</p><ol><li>answers[0]과 parttern1~3의 첫번째 배열을 비교한다.</li><li>같을경우 각 패턴에 1점씩 부여한다.</li><li>위 과정을 반복한다.</li><li>끝나고 가장 높은 배열을 출력한다.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 각 패턴별 점수판 변수 선언</span></span><br><span class="line">    score = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    result = []</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># answers[0]과 parttern1~3의 첫번째 배열을 비교한다.</span></span><br><span class="line">    <span class="keyword">for</span> idx, answer <span class="keyword">in</span> enumerate(answers):</span><br><span class="line">        <span class="keyword">if</span> answer == pattern1[idx%len(pattern1)]:</span><br><span class="line"><span class="comment"># 길이만큼 순환한다</span></span><br><span class="line">            score[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> answer == pattern2[idx%len(pattern2)]:</span><br><span class="line">            score[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> answer == pattern3[idx%len(pattern3)]:</span><br><span class="line">            score[<span class="number">2</span>] += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, s <span class="keyword">in</span> enumerate(score):</span><br><span class="line">    <span class="keyword">if</span> s == max(score): <span class="comment"># 최대값 결과값 배열에 넣는다.</span></span><br><span class="line">        result.append(idx+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프로그래머스 코딩 테스트 연습&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;문제-설명&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://taeyeonkim93.github.io/categories/Algorithm/"/>
    
      <category term="프로그래머스" scheme="https://taeyeonkim93.github.io/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
    
      <category term="완전탐색" scheme="https://taeyeonkim93.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
      <category term="BRUTE FORCE" scheme="https://taeyeonkim93.github.io/tags/BRUTE-FORCE/"/>
    
      <category term="ALGORITHM" scheme="https://taeyeonkim93.github.io/tags/ALGORITHM/"/>
    
      <category term="CODING TEST" scheme="https://taeyeonkim93.github.io/tags/CODING-TEST/"/>
    
      <category term="PYTHON" scheme="https://taeyeonkim93.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>[프로그래머스] 코딩테스트 풀이 - 완주하지 못한 선수</title>
    <link href="https://taeyeonkim93.github.io/2019/09/17/Algorithm-2019-09-17-programmers-coding-test-2/"/>
    <id>https://taeyeonkim93.github.io/2019/09/17/Algorithm-2019-09-17-programmers-coding-test-2/</id>
    <published>2019-09-17T12:07:30.000Z</published>
    <updated>2019-09-24T08:29:43.875Z</updated>
    
    <content type="html"><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/challenges" target="_blank" rel="noopener">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.</p><p>마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때,<br>완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.</li><li>completion의 길이는 participant의 길이보다 1 작습니다.</li><li>참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.</li><li>참가자 중에는 동명이인이 있을 수 있습니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">participant</th><th align="left">completion</th><th align="left">return</th></tr></thead><tbody><tr><td align="left">[leo, kiki, eden]</td><td align="left">[eden, kiki]</td><td align="left">leo</td></tr><tr><td align="left">[marina, josipa, nikola, vinko, filipa]</td><td align="left">[josipa, filipa, marina, nikola]</td><td align="left">vinko</td></tr><tr><td align="left">[mislav, stanko, mislav, ana]</td><td align="left">[stanko, ana, mislav]</td><td align="left">mislav</td></tr></tbody></table><h2 id="조건-분석"><a href="#조건-분석" class="headerlink" title="조건 분석"></a>조건 분석</h2><ul><li><p>나와야 하는 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">완주하지 못한 선수의 [이름]</span><br></pre></td></tr></table></figure></li><li><p>문제를 풀기위해 주어진 데이터</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 문제 해결에 필요한 데이터</span><br><span class="line"></span><br><span class="line">1. 이름</span><br><span class="line">  - 참여한 선수들의 이름 리스트 (completion arr)</span><br><span class="line">  - 완주한 선수들의 이름 리스트 (participant arr)</span><br><span class="line">2. 완주하지 못한 인원 수 (1명)</span><br><span class="line"></span><br><span class="line"># 제한조건</span><br><span class="line"></span><br><span class="line">1. 전체 배열 갯수 (1~10만)</span><br><span class="line">2. 이름 길이 (max 20 byte)</span><br><span class="line">3. 참가자의 동명이인 여부 (Yes)</span><br></pre></td></tr></table></figure></li><li><p>간단 알고리즘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 완주한 선수들의 리스트 중에서 참여한 선수들을 제거하고 남은 선수를 반환한다.</span><br></pre></td></tr></table></figure></li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>사용언어 : Python 3</p><p>알고리즘은 간결하지만 2가지의 풀이방법이 있다.</p><ul><li>문자열을 직접 비교하는 방법</li><li>해시 테이블을 이용한 방법</li></ul><p>문자열을 직접 비교하면 for문을 2개 활용해서 <code>O(n^2)</code>의 시간복잡도로 구할 수 있다.<br>다만 문제자체에서 <code>O(n)</code>의 시간복잡도가 나오지 않으면 문제풀이로 인정해주지 않기 때문에 <code>해쉬</code>를 이용한다.</p><p><code>해쉬(Hash)</code>에 대한 자세한 설명은 타 포스팅 참조</p><ul><li><a href="https://taeyeonkim93.github.io/2019/09/17/hash-algorithm/">해시 알고리즘 정리</a></li></ul><p>세부 알고리즘은</p><ol><li>참여한 선수들의 이름을 특정 <code>해쉬 함수</code>를 통해 <code>해쉬값</code>으로 만든다.</li><li>“색인을 통한 검색”을 위해 위의<code>해쉬값</code>을 <code>색인(index)</code>으로 하는 <code>해쉬 테이블</code>을 만든다.</li><li>완주한 선수들의 이름을 <code>해쉬값</code>으로 만들어서 참여한 선수들의<code>해쉬 테이블</code>에서 제거한다.</li><li>마지막에 남은 <code>해쉬 테이블</code>의 리스트를 반환한다.</li></ol><p>파이썬에서는 <code>딕셔너리</code>라는 key-value 매핑구조를 지원한다.<br>이때 key를 해쉬함수를 통해 나온값을 색인으로 쓰는 해쉬 테이블을 만들어주므로 편하게 사용하면 되겠다.<br>직접 해쉬테이블을 만들고싶으면 <code>hash()</code>를 사용해 만들어주면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(participant, completion)</span>:</span></span><br><span class="line">    dic = &#123;&#125; <span class="comment"># 딕셔너리 선언</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> parName <span class="keyword">in</span> participant:</span><br><span class="line">        dic[parName] = <span class="number">0</span> </span><br><span class="line">        <span class="comment"># key는 참여자 이름, value는 0으로 통일하는 dic 해쉬 테이블을 만든다.</span></span><br><span class="line">             </span><br><span class="line">    <span class="keyword">for</span> comName <span class="keyword">in</span> completion:</span><br><span class="line">        <span class="keyword">if</span> comName <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">del</span> dic[comName] </span><br><span class="line">        <span class="comment"># 해쉬 테이블에서 완주자의 이름을 가진 key를 전부 제거</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> list(dic.keys())[<span class="number">0</span>] <span class="comment"># 마지막 남은 key 반환</span></span><br><span class="line"></span><br><span class="line">participant = [<span class="string">"leo"</span>, <span class="string">"kiki"</span>, <span class="string">"eden"</span>]</span><br><span class="line">completion = [<span class="string">"eden"</span>, <span class="string">"kiki"</span>]</span><br><span class="line"></span><br><span class="line">print(solution(participant,completion))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">leo</span><br></pre></td></tr></table></figure><p>가장 기본적인 문제는 해결되었으니 제한조건을 살펴볼 차례이다.<br>전체 배열갯수나 이름길이는 문제가 없지만 동명이인일때가 문제다.<br>테스트값을<br><code>participant = [&quot;leo&quot;,&quot;leo&quot;, &quot;kiki&quot;, &quot;eden&quot;]</code><br><code>completion = [&quot;leo&quot;,&quot;eden&quot;, &quot;kiki&quot;]</code></p><p>이렇게 변경하면 딕셔너리 구조상 <code>leo</code>라는 키값이 2개가 아닌 1개로 저장된다.<br>이때 <code>leo</code>라는 키를 제거하면 결국 미완주자가 0명이 된다.</p><p>같은 key를 저장할때는 value값에 값을 누적시키는 방법으로 해결이 가능하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(participant, completion)</span>:</span></span><br><span class="line">    dic = &#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> parName <span class="keyword">in</span> participant:</span><br><span class="line">        <span class="keyword">if</span> parName <span class="keyword">in</span> dic: <span class="comment"># 딕셔너리 내부에 동명이인이 있으면</span></span><br><span class="line">            dic[parName] = dic.get(parName) + <span class="number">1</span> <span class="comment"># value에 1을 추가</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dic[parName] = <span class="number">1</span> <span class="comment"># 동명이인이 없으면 1로 통일</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> comName <span class="keyword">in</span> completion:</span><br><span class="line">        <span class="keyword">if</span> comName <span class="keyword">in</span> dic:</span><br><span class="line">            dic[comName] = dic.get(comName) <span class="number">-1</span> <span class="comment"># 완주한 사람은 value값에 -1</span></span><br><span class="line">        <span class="keyword">if</span> dic[comName] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">del</span> dic[comName] <span class="comment"># 0인 완주자는 테이블에서 제외</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> list(dic.keys())[<span class="number">0</span>] <span class="comment"># value값이 1인 참여자만 남아서 반환</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">participant = [<span class="string">"leo"</span>,<span class="string">"leo"</span>, <span class="string">"kiki"</span>, <span class="string">"eden"</span>]</span><br><span class="line">completion = [<span class="string">"leo"</span>,<span class="string">"eden"</span>, <span class="string">"kiki"</span>]</span><br><span class="line"></span><br><span class="line">print(solution(participant,completion))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">leo</span><br></pre></td></tr></table></figure><p>이외에 참여자와 완주자의 리스트를 알파벳순으로 정렬해 비교하는 도중 같지않으면 반환하는 방법과 Counter 클래스를 사용하는 방법도 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프로그래머스 코딩 테스트 연습&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;문제-설명&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://taeyeonkim93.github.io/categories/Algorithm/"/>
    
      <category term="프로그래머스" scheme="https://taeyeonkim93.github.io/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
    
      <category term="ALGORITHM" scheme="https://taeyeonkim93.github.io/tags/ALGORITHM/"/>
    
      <category term="CODING TEST" scheme="https://taeyeonkim93.github.io/tags/CODING-TEST/"/>
    
      <category term="PYTHON" scheme="https://taeyeonkim93.github.io/tags/PYTHON/"/>
    
      <category term="HASH" scheme="https://taeyeonkim93.github.io/tags/HASH/"/>
    
      <category term="HASH TABLE" scheme="https://taeyeonkim93.github.io/tags/HASH-TABLE/"/>
    
  </entry>
  
  <entry>
    <title>[자료구조] HASH 정리</title>
    <link href="https://taeyeonkim93.github.io/2019/09/17/CS-2019-09-17-hash-algorithm/"/>
    <id>https://taeyeonkim93.github.io/2019/09/17/CS-2019-09-17-hash-algorithm/</id>
    <published>2019-09-17T11:14:21.000Z</published>
    <updated>2019-09-24T08:29:00.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h2><p><strong>특정한 값을, 수많은 값들 사이에서 찾아야 할 때</strong> 사용한다.</p><p>물론 탐색은 여러가지 방법이 있다. 그중에서 HASH를 사용하는 장단점을 추려보면</p><p>장점</p><ul><li>평균 case에서 O(1)의 시간복잡도를 가진다</li></ul><p>단점</p><ul><li>메모리 영역을 일정부분 차지한다</li><li>충돌이 발생할 수 있다.</li></ul><blockquote><p>보안적 측면이나 Collision 및 세부내용은 <a href="https://meylady.tistory.com/20" target="_blank" rel="noopener">타 블로그</a>를 참조하고<br>여기서는 탐색 알고리즘 문제를 풀기위한 기본개념만 잡는다.</p></blockquote><h2 id="HASH란"><a href="#HASH란" class="headerlink" title="HASH란?"></a>HASH란?</h2><p><code>HASH</code> 란 용어 자체는 [고기와 감자를 잘게 다져 섞어 요리하여 따뜻하게 차려 낸 것] 이란 영단어 뜻에서 시작하면 된다.</p><p>어떤 내용물들을 잘 섞어서 특정한 형태로 만든다는 것이다.</p><p>짜장면을 두그릇 사서 <code>&#39;똑같은 위치와 힘으로&#39;</code> <code>&#39;왼손으로 5번&#39;</code> <code>&#39;오른손으로 6번&#39;</code> 비비면 두그릇은 완벽히 똑같은 짜장면이 나온다.<br>이때 오른손으로 8번을 비비면 다른 짜장면의 모양새가 된다.</p><ul><li>면+소스<code>(입력값)</code> 를</li><li>같은 방법으로 섞으면<code>(해시함수)</code> </li><li>완전히 같은 짜장면<code>(해시값)</code>이 된다.</li></ul><p>문제가 [가장 맛있는 짜장면] 을 탐색하는 것이라면, 면과 소스를 특정한 방법으로(5번,6번) 섞기만 하면 된다.</p><p>굳이 왼손으로 1번~5번, 오른손으로 1번~6번을 전부 다 탐색해볼 필요가 없게 된것이다.</p><h2 id="HASH-사용법"><a href="#HASH-사용법" class="headerlink" title="HASH 사용법"></a>HASH 사용법</h2><p>HASH 자료구조는 몇가지 용어가 나온다.</p><ul><li>Hash Function(해시함수)</li><li>Hash Table(해시 테이블)</li><li>Hash Value, Hash Code, Hash Checksum… (해시값)</li></ul><p>우리가 알고싶은 탐색은 <code>해시테이블</code>을 보면 된다.</p><table><thead><tr><th>name</th><th>phone number</th></tr></thead><tbody><tr><td>John Smith</td><td>521-1234</td></tr><tr><td>Lisa Smith</td><td>521-8976</td></tr><tr><td>Sandra Dee</td><td>521-9655</td></tr></tbody></table><p>이런 입력값을 주고 “Sandra Dee”의 전화번호를 찾으라고 하면, Hash를 사용하지 않을경우 “John Smith”부터 하나하나 찾아가는수밖에 없다.</p><p>하지만 이런식으로 테이블을 만들어두면<br><img src="/images/hash-algorithm/1.png" alt></p><p><code>keys(입력값)</code>이 <code>hash function(해시함수)</code>를 통해 <code>Hash Value(해시값)</code>으로 변환되어 해시값의<code>index(색인)</code> 을 가진 해시테이블이 완성된다.</p><ul><li>해시테이블<table><thead><tr><th align="right">index(Hash Value)</th><th align="left">Data</th></tr></thead><tbody><tr><td align="right">01</td><td align="left">(Lisa Smith, 521-8976)</td></tr><tr><td align="right">02</td><td align="left">(John Smith, 521-1234)</td></tr><tr><td align="right">…</td><td align="left">…</td></tr><tr><td align="right">14</td><td align="left">(Sandra Dee, 521-9655)</td></tr></tbody></table></li></ul><p>이렇게 모두 저장해두면 나중에 ‘Sandra Dee’ 라는 입력값을 찾기위해서는</p><ol><li>Sandra Dee를 해시함수에 넣는다</li><li>Sandra Dee가 14인 해시값으로 변환된다.</li><li>0번주소값에서 14만큼 떨어진 주소로 바로 넘어가서 값을 가져온다</li></ol><p>결국 탐색을 단 한번에 끝낼수 있으므로 시간복잡도는 O(1)이다.</p><ul><li>예시 : <a href="https://taeyeonkim93.github.io/2019/09/17/programmers-coding-test-2/">[프로그래머스] 코딩테스트 풀이 - 완주하지 못한 선수</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HASH&quot;&gt;&lt;a href=&quot;#HASH&quot; class=&quot;headerlink&quot; title=&quot;HASH&quot;&gt;&lt;/a&gt;HASH&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;특정한 값을, 수많은 값들 사이에서 찾아야 할 때&lt;/strong&gt; 사용한다.&lt;/p&gt;
&lt;p&gt;물론 탐
      
    
    </summary>
    
    
      <category term="CS" scheme="https://taeyeonkim93.github.io/categories/CS/"/>
    
      <category term="자료구조" scheme="https://taeyeonkim93.github.io/categories/CS/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
    
      <category term="DATA STRUCTURE" scheme="https://taeyeonkim93.github.io/tags/DATA-STRUCTURE/"/>
    
      <category term="HASH" scheme="https://taeyeonkim93.github.io/tags/HASH/"/>
    
      <category term="HASH TABLE" scheme="https://taeyeonkim93.github.io/tags/HASH-TABLE/"/>
    
  </entry>
  
  <entry>
    <title>[Kotlin] 코틀린 날짜 함수 정리</title>
    <link href="https://taeyeonkim93.github.io/2019/09/17/Programming-kotlin-2019-09-17-kotlin-calendar-function/"/>
    <id>https://taeyeonkim93.github.io/2019/09/17/Programming-kotlin-2019-09-17-kotlin-calendar-function/</id>
    <published>2019-09-17T06:59:06.000Z</published>
    <updated>2019-09-18T09:56:55.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="코틀린-날짜-함수"><a href="#코틀린-날짜-함수" class="headerlink" title="코틀린 날짜 함수"></a>코틀린 날짜 함수</h1><p><a href="https://taeyeonkim93.github.io/2019/09/17/programmers-codingtest-1/">프로그래머스 문제</a>를 풀다가 java에서는 <code>Date</code>가 Deprecate 되고 <code>Calendar</code>를 사용한다고 해서 정리해봤다.</p><p>전체적으로 정리하기보단 실제로 사용하는 부분에만 중점을 뒀다. 전체 Document는 <a href="https://hyeonstorage.tistory.com/205" target="_blank" rel="noopener">이곳</a> 참조</p><p>java에서는 날짜를 계산하는 내장라이브러리로 <code>Calendar</code>클래스나 <code>java.time</code> 패키지를 주로 사용하지만 일단 사용하기 편한 Calendar 클래스를 보면</p><ul><li>Calendar 인스턴스 생성<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> calendar:Calendar = Calendar.getInstance()</span><br></pre></td></tr></table></figure></li></ul><p>Calendar 클래스는 추상클래스이기 때문에 객체를 직접 생성할 수 없고 <code>getInstance()</code> 함수를 통해 완전히 구현된 클래스의 인스턴스를 얻어야 한다.<br>이 인스턴스를 통해 Calendar 클래스 내부 함수들을 사용할 수 있다.</p><p>인스턴스의 내부에는 현재 날짜와 시간정보가 들어있다.</p><ul><li>현재 날짜정보 가져오기<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> year = calendar.<span class="keyword">get</span>(Calendar.YEAR)  </span><br><span class="line"><span class="keyword">val</span> mon = calendar.<span class="keyword">get</span>(Calendar.MONTH)  </span><br><span class="line"><span class="keyword">val</span> day = calendar.<span class="keyword">get</span>(Calendar.DAY_OF_MONTH)  </span><br><span class="line"><span class="keyword">val</span> hour = calendar.<span class="keyword">get</span>(Calendar.HOUR_OF_DAY)  </span><br><span class="line"><span class="keyword">val</span> min = calendar.<span class="keyword">get</span>(Calendar.MINUTE)  </span><br><span class="line"><span class="keyword">val</span> sec = calendar.<span class="keyword">get</span>(Calendar.SECOND)</span><br></pre></td></tr></table></figure></li></ul><p><strong>주의할 점은</strong> <code>calendar.get(Calendar.MONTH)</code> 로 가져오는 월이 1~12이 아니라 0~11 이다.<br>그래서 0이 1월, 11이 12월을 의미한다.</p><ul><li><p>날짜 설정하기</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calendar.<span class="keyword">set</span>(year,month,date,hour,minute,second)</span><br></pre></td></tr></table></figure></li><li><p>날짜 일수 계산하기</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calendar.timeInMillis  </span><br><span class="line"><span class="comment">//설정된 시간을 밀리초로 변경</span></span><br></pre></td></tr></table></figure></li></ul><p>시간을 밀리초로 변환시킨 후<code>SimpleDateFormat()</code>함수를 통해 원하는 Date Format으로 변경한다.<br>자세한 포맷은 <a href="https://developer.android.com/reference/kotlin/java/text/SimpleDateFormat" target="_blank" rel="noopener">정식문서</a> 참조</p><p>결과값이 한글로 나올경우 뒤에 <code>Locale.ENGLISH</code>을 붙여 영어로 만든다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat(<span class="string">"yyyy.MM.dd G 'at' HH:mm:ss z"</span>,Locale.ENGLISH).format(calendar.timeInMillis)  </span><br><span class="line"><span class="comment">//2001.07.04 AD at 12:08:56 PDT</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;코틀린-날짜-함수&quot;&gt;&lt;a href=&quot;#코틀린-날짜-함수&quot; class=&quot;headerlink&quot; title=&quot;코틀린 날짜 함수&quot;&gt;&lt;/a&gt;코틀린 날짜 함수&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://taeyeonkim93.github.io/20
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://taeyeonkim93.github.io/categories/Programming/"/>
    
      <category term="Kotlin" scheme="https://taeyeonkim93.github.io/categories/Programming/Kotlin/"/>
    
    
      <category term="KOTLIN" scheme="https://taeyeonkim93.github.io/tags/KOTLIN/"/>
    
      <category term="CALENDAR" scheme="https://taeyeonkim93.github.io/tags/CALENDAR/"/>
    
      <category term="LIBRARY" scheme="https://taeyeonkim93.github.io/tags/LIBRARY/"/>
    
      <category term="JAVA" scheme="https://taeyeonkim93.github.io/tags/JAVA/"/>
    
      <category term="날짜 함수" scheme="https://taeyeonkim93.github.io/tags/%EB%82%A0%EC%A7%9C-%ED%95%A8%EC%88%98/"/>
    
      <category term="내장라이브러리" scheme="https://taeyeonkim93.github.io/tags/%EB%82%B4%EC%9E%A5%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>[프로그래머스] 코딩테스트 풀이 - 2016년</title>
    <link href="https://taeyeonkim93.github.io/2019/09/17/Algorithm-2019-09-17-programmers-coding-test-1/"/>
    <id>https://taeyeonkim93.github.io/2019/09/17/Algorithm-2019-09-17-programmers-coding-test-1/</id>
    <published>2019-09-17T06:34:03.000Z</published>
    <updated>2019-09-18T09:55:14.765Z</updated>
    
    <content type="html"><![CDATA[<p>Reference : <a href="https://programmers.co.kr/learn/challenges" target="_blank" rel="noopener">프로그래머스 코딩 테스트 연습</a></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>2016년 1월 1일은 금요일입니다. <strong>2016년 a월 b일은 무슨 요일</strong>일까요?<br>두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요.<br>요일의 이름은 일요일부터 토요일까지 각각 <code>SUN,MON,TUE,WED,THU,FRI,SAT</code>입니다.<br>예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><p>2016년은 윤년입니다.<br>2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)</p><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">a</th><th align="left">b</th><th align="left">result</th></tr></thead><tbody><tr><td align="left">5</td><td align="left">24</td><td align="left">TUE</td></tr></tbody></table><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p><strong>사용언어 : Kotlin</strong></p><h5 id="날짜-구하는-함수를-직접-만들경우"><a href="#날짜-구하는-함수를-직접-만들경우" class="headerlink" title="날짜 구하는 함수를 직접 만들경우"></a>날짜 구하는 함수를 직접 만들경우</h5><ol><li><p>2016년의 모든 달(1월~12월)의 마지막 날을 적는다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> month = listOf(<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>)</span><br><span class="line"> <span class="comment">// 1월~12월의 전체 날짜 수</span></span><br></pre></td></tr></table></figure></li><li><p>2016년 1월 1일이 무슨일인지 알아낸다. (금요일)</p></li><li><p>금요일부터 목요일까지 영어로 적혀있는 배열을 만든다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dayOfWeek = listOf(<span class="string">"FRI"</span>, <span class="string">"SAT"</span>, <span class="string">"SUN"</span>, <span class="string">"MON"</span>, <span class="string">"TUE"</span>, <span class="string">"WED"</span>, <span class="string">"THU"</span>)</span><br><span class="line"><span class="comment">// 1월 1일부터 반복되는 요일 영어</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>1월 1일이라면 (0 + 1 - 1) % 7 = 0 -&gt; FRI<br>3월 6일이라면 (31 + 29 + 6 - 1) % 7 = 2 -&gt; SUN<br>숫자로 계산한 후 <code>dayOfWeek</code>에서 대응하는 날짜를 찾아 변환한다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until a - <span class="number">1</span>) &#123;  </span><br><span class="line">    total += month[i]  <span class="comment">// 날짜 계산식</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">total += (b-<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">return</span> dayOfWeek[total%<span class="number">7</span>] <span class="comment">// 요일 산출</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="내장-라이브러리를-사용해서-만들경우"><a href="#내장-라이브러리를-사용해서-만들경우" class="headerlink" title="내장 라이브러리를 사용해서 만들경우"></a>내장 라이브러리를 사용해서 만들경우</h5><ol><li><p>월, 일을 날짜 변수에 넣는다</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> calendar = Calendar.getInstance()  </span><br><span class="line">calendar.<span class="keyword">set</span>(<span class="number">2016</span>, a-<span class="number">1</span>, b)</span><br></pre></td></tr></table></figure></li><li><p>현재 날짜를 밀리초 단위로 변경한 후, 반환값이 날짜 포맷으로 출력되는 함수 SimpleDateFormat을 활용해서 영어단어로 출력한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> SimpleDateFormat(<span class="string">"EEE"</span>, Locale.ENGLISH).format(calendar.timeInMillis).toUpperCase()  </span><br><span class="line"><span class="comment">// 밀리초단위로 변경 후 SimpleDateFormat으로 요일 출력</span></span><br></pre></td></tr></table></figure></li></ol><p>해당 내장함수에 대한 설명은 타 포스팅 참조</p><ul><li><a href="https://taeyeonkim93.github.io/2019/09/17/kotlin-calendar-function/">Kotlin 날짜함수 정리</a></li></ul><p>전체 답안</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat  </span><br><span class="line"><span class="keyword">import</span> java.util.*  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: String &#123;  </span><br><span class="line"> <span class="keyword">val</span> calendar = Calendar.getInstance()  </span><br><span class="line"> calendar.<span class="keyword">set</span>(<span class="number">2016</span>, a-<span class="number">1</span>, b)  </span><br><span class="line"> <span class="keyword">return</span> SimpleDateFormat(<span class="string">"EEE"</span>, Locale.ENGLISH).format(calendar.timeInMillis).toUpperCase()  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference : &lt;a href=&quot;https://programmers.co.kr/learn/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프로그래머스 코딩 테스트 연습&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;문제-설명&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://taeyeonkim93.github.io/categories/Algorithm/"/>
    
      <category term="프로그래머스" scheme="https://taeyeonkim93.github.io/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
    
      <category term="ALGORITHM" scheme="https://taeyeonkim93.github.io/tags/ALGORITHM/"/>
    
      <category term="CODING TEST" scheme="https://taeyeonkim93.github.io/tags/CODING-TEST/"/>
    
      <category term="DATE LIBRARY" scheme="https://taeyeonkim93.github.io/tags/DATE-LIBRARY/"/>
    
      <category term="KOTLIN" scheme="https://taeyeonkim93.github.io/tags/KOTLIN/"/>
    
  </entry>
  
  <entry>
    <title>[VCS] Github에서 실수로 Push한 Commit 삭제하기</title>
    <link href="https://taeyeonkim93.github.io/2019/09/17/etc-2019-09-17-github-commit-remove/"/>
    <id>https://taeyeonkim93.github.io/2019/09/17/etc-2019-09-17-github-commit-remove/</id>
    <published>2019-09-17T06:18:50.000Z</published>
    <updated>2019-09-18T11:07:47.687Z</updated>
    
    <content type="html"><![CDATA[<p>Git 작업 시 오타가 났거나 올라가면 안되는 Commit을 Push 했을경우 어떻게 삭제해야 할까?</p><p><img src="/images/git-commit-remove/git-commit-remove-1.png" alt></p><div style="text-align: center;">- 지워야 하는 Commit </div><p>잘못된 커밋이 몇개나 있으면 가독성을 해치게 된다. 깔끔하게 삭제하고 새롭게 commit 내용을 추가해보자.</p><p>지워야하는 해당 폴더에 들어가서 <code>git log</code>로 내역이 잘 나오는지 확인하자.<br>  * Hexo를 사용하는 유저는 .deploy_git 폴더에서 작업해야함</p><p><a href="https://taeyeonkim93.github.io/images/git-commit-remove/git-commit-remove-2.png"><img src="/images/git-commit-remove/git-commit-remove-2.png" alt></a></p><div style="text-align: center;">- git log 화면</div><p>지워야할 내용을 확인했다면 삭제 명령어를 입력하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~[지울 개수]</span><br></pre></td></tr></table></figure><p><code>reset</code>은 현재 진행중인 최신 commit에서부터 아래로 [지울 개수] 만큼 삭제한다.</p><ul><li>commit 시점 되돌리기 관련 내용은 타 문서를 참고하면 좋다.<br><a href="https://www.devpools.kr/2017/02/05/%EC%B4%88%EB%B3%B4%EC%9A%A9-git-%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0-reset-revert/" target="_blank" rel="noopener">개발 바보들의 놀이터 - [초보용] Git 되돌리기( Reset, Revert )</a></li></ul><p><img src="/images/git-commit-remove/git-commit-remove-3.png" alt></p><div style="text-align: center;">- 삭제화면</div><p><img src="/images/git-commit-remove/git-commit-remove-4.png" alt></p><div style="text-align: center;">- 삭제 이후 git log</div><p>현재 local의 commit 상태는 그대로 유지되니 올바른 내용의 commit을 한 후에 push를 진행하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin +master // 강제푸시해야함</span><br></pre></td></tr></table></figure><p>혹시 reset의 HEAD 숫자를 잘못입력해서 너무 많이 reset했을경우, <code>git reflog</code>를 사용해 몇번째 HEAD로 이동해야 하는지 살펴본다.</p><p>이동해야할 HEAD를 확인했으면</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD@&#123;1&#125;</span><br></pre></td></tr></table></figure><p>과 같이 강제로 되돌릴수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git 작업 시 오타가 났거나 올라가면 안되는 Commit을 Push 했을경우 어떻게 삭제해야 할까?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/git-commit-remove/git-commit-remove-1.png&quot; alt&gt;&lt;/p&gt;
&lt;di
      
    
    </summary>
    
    
      <category term="etc" scheme="https://taeyeonkim93.github.io/categories/etc/"/>
    
      <category term="VCS" scheme="https://taeyeonkim93.github.io/categories/etc/VCS/"/>
    
    
      <category term="DOCUMENT" scheme="https://taeyeonkim93.github.io/tags/DOCUMENT/"/>
    
      <category term="GIT" scheme="https://taeyeonkim93.github.io/tags/GIT/"/>
    
      <category term="GITHUB" scheme="https://taeyeonkim93.github.io/tags/GITHUB/"/>
    
      <category term="HEXO" scheme="https://taeyeonkim93.github.io/tags/HEXO/"/>
    
      <category term="RESET" scheme="https://taeyeonkim93.github.io/tags/RESET/"/>
    
      <category term="VCS" scheme="https://taeyeonkim93.github.io/tags/VCS/"/>
    
  </entry>
  
  <entry>
    <title>[kotlin] 3. 함수형 프로그래밍</title>
    <link href="https://taeyeonkim93.github.io/2019/09/15/Programming-kotlin-2019-09-15-kotlin-study-3/"/>
    <id>https://taeyeonkim93.github.io/2019/09/15/Programming-kotlin-2019-09-15-kotlin-study-3/</id>
    <published>2019-09-15T10:29:05.000Z</published>
    <updated>2019-09-17T06:15:09.265Z</updated>
    
    <content type="html"><![CDATA[<p>References: <a href="https://acaroom.net/ko/blog/youngdeok/do-it-kotlin-programming" target="_blank" rel="noopener">Do it! 코틀린 프로그래밍</a></p><hr><h2 id="함수-구조"><a href="#함수-구조" class="headerlink" title="함수 구조"></a>함수 구조</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chap03.section1  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123; <span class="comment">// fun 키워드 // 함수 이름 // 매개변수 // 반환자료형 명시  </span></span><br><span class="line"> <span class="keyword">var</span> sum = a + b <span class="comment">// 함수 본문  </span></span><br><span class="line"> <span class="keyword">return</span> sum <span class="comment">// 반환  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>한줄로 단축도 가능하다</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b</span><br></pre></td></tr></table></figure><h3 id="코틀린-함수-특성"><a href="#코틀린-함수-특성" class="headerlink" title="코틀린 함수 특성"></a>코틀린 함수 특성</h3><p>함수는 스택 메모리에 저장된다.<br>스택은 각 함수가 Frame단위로 적재된다.<br>LIFO인 스택 구조상 Main() 함수의 프레임이 가장 바닥에 적재되고, 그위에 max()함수 등 호출되는 순서대로 적재된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">힙 영역 (낮은 주소)  </span><br><span class="line">↓  </span><br><span class="line">min()함수 Frame  </span><br><span class="line">max()함수 Frame  </span><br><span class="line">main()함수 Frame  </span><br><span class="line">↑  </span><br><span class="line">스택 영역(높은 주소)</span><br></pre></td></tr></table></figure><p>함수는 스택 영역의 높은 주소부터 거꾸로 자라듯이 채워져 나간다.<br>가장 나중에 호출된 min 함수가 가장 위로 올라가고, 호출이 종료되면 Frame단위로 사라진다.<br>함수 내부의 변수들은 서로 겹치지않으므로 함수 내부의 변수들끼리 계산이 가능하다.</p><p>Kotlin에서는 <strong>함수의 반환값을 생략</strong>할 수 있다.<br>단, 함수의 반환값을 생략하고 함수를 작성하면 Unit이라는 특수한 자료형으로 반환된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span> &#123; <span class="comment">//Unit은 없어도 상관없음  </span></span><br><span class="line"> println(<span class="string">"sum of <span class="variable">$a</span> and <span class="variable">$b</span> is <span class="subst">$&#123;a + b&#125;</span>"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 내에서 여러개의 매개변수를 받을 때, <strong>가변 인자</strong>를 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> normalVarargs(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"> normalVarargs(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">normalVarargs</span><span class="params">(<span class="keyword">vararg</span> counts: <span class="type">Int</span>)</span></span> &#123; <span class="comment">// 가변인자 vararg  </span></span><br><span class="line"> <span class="keyword">for</span> (num <span class="keyword">in</span> counts) &#123;  </span><br><span class="line"> print(<span class="string">"<span class="variable">$num</span> "</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> print(<span class="string">"\n"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>variable argument, 가변 인자의 약자 <strong>vararg</strong>를 사용하면 그때그때 변하는 인자의 개수를 전부 매개변수로 받아 사용 할 수 있다.</p><h3 id="함수형-프로그래밍-구조"><a href="#함수형-프로그래밍-구조" class="headerlink" title="함수형 프로그래밍 구조"></a>함수형 프로그래밍 구조</h3><p>코틀린은 함수형 프로그래밍과 객체지향형 프로그래밍을 모두 지원하는 <strong>다중 패러다임 언어</strong> 이다.</p><ul><li><strong>다중 패러다임 언어</strong> : 한가지 구현 규칙에 얽매이지 않고 다양한 문법과 형식을 지원하는 언어</li></ul><h4 id="함수형-프로그래밍"><a href="#함수형-프로그래밍" class="headerlink" title="함수형 프로그래밍?"></a>함수형 프로그래밍?</h4><p>함수형 프로그래밍의 정의와 특징</p><ul><li>순수 함수를 사용해야 한다.</li><li>람다식을 사용할 수 있다.</li><li>고차 함수를 사용할 수 있다.</li></ul><h5 id="1-순수함수"><a href="#1-순수함수" class="headerlink" title="1. 순수함수"></a>1. 순수함수</h5><p>함수형 프로그래밍은 순수 함수를 작성하여 프로그램의 부작용을 줄이는 프로그래밍 기법을 말한다.</p><ul><li><strong>순수 함수</strong>의 조건<ol><li>같은 인자에 대하여 항상 같은 값을 반환하는 함수</li><li>함수 외부의 어떤 상태도 바꾸지 않는 함수</li></ol></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">순수 함수의 예    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;  </span><br><span class="line"> <span class="keyword">return</span> a + b  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">순수 함수를 만족하지 않는 함수의 예  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="keyword">val</span> test = User.grade()  </span><br><span class="line"> <span class="keyword">if</span> (test != <span class="literal">null</span>) process(test) <span class="comment">// test는 User.grade()의 상태에 따라 달라짐  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-람다식"><a href="#2-람다식" class="headerlink" title="2. 람다식"></a>2. 람다식</h5><p>람다식은 다음과 같은 형태로 이루어져있다.</p><p><code>{ x, y -&gt; x + y }</code></p><p>함수의 이름이 없고, 화살표(-&gt;)가 사용되었다. 함수형 프로그래밍의 람다식은 다음과 같은것을 말한다.</p><ul><li>다른 함수의 인자로 넘기는 함수</li><li>함수의 결과값으로 반환되는 함수</li><li>변수에 저장하는 함수</li></ul><p>람다식 예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">변수에 할당하는 람다식  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//// 같은 람다식 ////  </span></span><br><span class="line"><span class="keyword">val</span> multi: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>, <span class="built_in">Int</span> -&gt; x * y&#125;  </span><br><span class="line"><span class="keyword">val</span> multi = &#123;x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x * y&#125;  </span><br><span class="line"><span class="keyword">val</span> multi: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x, y -&gt; x * y&#125;  </span><br><span class="line"><span class="comment">//// 같은 람다식 ////  </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> multi = &#123;x,y -&gt; x * y&#125; <span class="comment">// 이건 오류  (자료형이 없음)</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">val</span> greet: () -&gt; <span class="built_in">Unit</span> = &#123;println(<span class="string">"Hello World!"</span>)&#125; <span class="comment">// 반환값이 없을때  </span></span><br><span class="line"><span class="keyword">val</span> square: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x -&gt; x * x&#125; <span class="comment">// 매개변수가 하나일때  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">val</span> nestedLambda: () -&gt; () -&gt; <span class="built_in">Unit</span> = &#123;&#123;println(<span class="string">"nested"</span>)&#125;&#125; <span class="comment">// 람다식 안에 람다식</span></span><br></pre></td></tr></table></figure><p>사용할경우 함수처럼 <code>multi(x,y)</code>로 사용하면 된다.</p><h5 id="3-일급-객체"><a href="#3-일급-객체" class="headerlink" title="3. 일급 객체"></a>3. 일급 객체</h5><p>함수형 프로그래밍에서는 함수를 “일급 객체” 로 생각한다. 일급 객체의 특징은 다음과 같다.</p><ul><li>일급 객체는 함수의 인자로 전달할 수 있다.</li><li>일급 객체는 함수의 반환값에 사용할 수 있다.</li><li>일급 객체는 변수에 담을 수 있다.</li></ul><p>함수가 일급 객체면 일급 함수라고 부른다.<br>일급 함수에 이름이 없는 경우 람다식 함수 혹은 람다식이라고 부를 수 있다<br>즉 람다식은 일급 객체의 특징을 가진 이름 없는 함수이다.</p><h5 id="4-고차-함수"><a href="#4-고차-함수" class="headerlink" title="4. 고차 함수"></a>4. 고차 함수</h5><p>고차 함수 란 다른 함수를 인자로 사용하거나 함수를 결과값으로 반환하는 함수를 말한다.</p><p>인자가 일반 함수인 고차 함수 예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">인자가 일반 함수인 고차 함수  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="keyword">val</span> res1 = sum(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"> <span class="keyword">val</span> res2 = mul(sum(<span class="number">3</span>,<span class="number">3</span>),<span class="number">3</span>) <span class="comment">// 인자에 함수 사용  </span></span><br><span class="line">  </span><br><span class="line"> println(<span class="string">"res1: <span class="variable">$res1</span>, res2: <span class="variable">$res2</span>"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a:<span class="type">Int</span>, b:<span class="type">Int</span>)</span></span> = a + b  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mul</span><span class="params">(a:<span class="type">Int</span>, b:<span class="type">Int</span>)</span></span> = a * b</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행 결과  </span><br><span class="line">res1: <span class="number">5</span>, res2: <span class="number">18</span></span><br></pre></td></tr></table></figure><p>반환값이 일반 함수인 고차 함수 예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">반환값이 일반 함수인 고차 함수  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> println(<span class="string">"funcFunc: <span class="subst">$&#123;funcFunc()&#125;</span>"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a:<span class="type">Int</span>, b:<span class="type">Int</span>)</span></span> = a + b  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">funcFunc</span><span class="params">()</span></span>:<span class="built_in">Int</span> &#123;  </span><br><span class="line"> <span class="keyword">return</span> sum(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">// 반환값이 함수  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행 결과  </span><br><span class="line">funcFunc: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>람다식을 매개변수에 할당하는 고차함수 예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">람다식을 매개변수에 할당하는 고차함수  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line"> <span class="keyword">var</span> result: <span class="built_in">Int</span>  </span><br><span class="line"> result = highOrder(&#123; x, y -&gt; x + y&#125;, <span class="number">10</span>,<span class="number">20</span>) <span class="comment">// 람다식 함수 호출  </span></span><br><span class="line"> println(result)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">highOrder</span><span class="params">(sum: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;  </span><br><span class="line"> <span class="comment">// 매개변수에 삽입된 람다식  </span></span><br><span class="line"> <span class="keyword">return</span> sum(a,b)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행 결과  </span><br><span class="line">30</span><br></pre></td></tr></table></figure><p>인자와 반환값이 없는 람다식 고차함수 예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">인자와 반환값이 없는 람다식 고차함수</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="keyword">val</span> <span class="keyword">out</span>: () -&gt; <span class="built_in">Unit</span> = &#123;println(<span class="string">"Hello World"</span>)&#125; <span class="comment">// -&gt; Unit 생략 가능  </span></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">out</span>() <span class="comment">// 함수처럼 이용가능  </span></span><br><span class="line"> <span class="keyword">val</span> new = <span class="keyword">out</span> <span class="comment">// 다른 변수에 람다식 할당 가능  </span></span><br><span class="line"> new()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">실행 결과  </span><br><span class="line">Hello World  </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;References: &lt;a href=&quot;https://acaroom.net/ko/blog/youngdeok/do-it-kotlin-programming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Do it! 코틀린 프로그래밍&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://taeyeonkim93.github.io/categories/Programming/"/>
    
      <category term="Kotlin" scheme="https://taeyeonkim93.github.io/categories/Programming/Kotlin/"/>
    
    
      <category term="do it study" scheme="https://taeyeonkim93.github.io/tags/do-it-study/"/>
    
      <category term="kotlin" scheme="https://taeyeonkim93.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>[kotlin] 2. 코틀린 기초</title>
    <link href="https://taeyeonkim93.github.io/2019/09/14/Programming-kotlin-2019-09-14-kotlin-study-2/"/>
    <id>https://taeyeonkim93.github.io/2019/09/14/Programming-kotlin-2019-09-14-kotlin-study-2/</id>
    <published>2019-09-14T09:04:45.000Z</published>
    <updated>2019-09-16T03:26:20.715Z</updated>
    
    <content type="html"><![CDATA[<p>References: <a href="https://acaroom.net/ko/blog/youngdeok/do-it-kotlin-programming" target="_blank" rel="noopener">Do it! 코틀린 프로그래밍</a></p><hr><h2 id="프로젝트-모듈-패키지-파일"><a href="#프로젝트-모듈-패키지-파일" class="headerlink" title="프로젝트, 모듈, 패키지, 파일"></a>프로젝트, 모듈, 패키지, 파일</h2><p>코틀린은 파일이 모여 패키지가 되고, <strong>패키지가 모여 모듈</strong>이 된다.<br>파이썬에서는 모듈이 모여 패키지가 되더니 언어마다 다른건가 싶다.</p><p><strong>코틀린 프로젝트 계층 구조</strong>   </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 프로젝트  </span><br><span class="line">## 모듈  </span><br><span class="line">### 패키지  </span><br><span class="line">#### 파일</span><br></pre></td></tr></table></figure><h4 id="패키지"><a href="#패키지" class="headerlink" title="패키지"></a>패키지</h4><p>같은 프로젝트 내에서 같은 클래스 이름을 쓰더라도 오류가 나지 않게 <strong>패키지 이름으로 분류</strong>한다.</p><ul><li>같은 프로젝트 내 Person 클래스 2개 -&gt; <strong>충돌 발생</strong></li><li>1번 패키지 내 Person 클래스 / 2번 패키지 내 Person 클래스 -&gt; <strong>문제없음</strong></li></ul><p>패키지 이름을 선언하지 않고 파일을 만들면 default 패키지 아래로 자동으로 들어간다.  </p><p><img src="/images/kotlin-study-2/1.png" alt></p><div style="text-align: center;"> - 보이지않는 default 패키지 아래에 존재하는 파일 </div><p>패키지 명은 .으로 구분한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.edu</span><br></pre></td></tr></table></figure><p>기능이나 역할을 뒤에 추가로 넣어주면 좋다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.net.upload <span class="comment">// 인터넷 업로드 기능을 하는 패키지명</span></span><br></pre></td></tr></table></figure><p>다른 패키지 내 클래스 import 문법 및 클래스 객체로 만들기</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taeyeon93.study.freetest2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age:<span class="built_in">Int</span>) <span class="comment">// 클래스 선언</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taeyeon93.study.freetest         </span><br><span class="line"><span class="keyword">import</span> com.taeyeon93.study.freetest2.Person <span class="comment">// 클래스 import</span></span><br><span class="line">         </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user1 = Person(<span class="string">"kildong"</span>, <span class="number">30</span>)  <span class="comment">// 클래스 객체로 만들기</span></span><br><span class="line">     </span><br><span class="line">    println(user1.name)</span><br><span class="line">    println(user1.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">kildong</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p>다른 패키지 내의 클래스명과 현재 패키지의 클래스명이 같아서 객체를 만들기 어려울 때 as 별명을 붙여 구분한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.edu.Person <span class="keyword">as</span> User  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="keyword">val</span> user1 = User(<span class="string">"kildong"</span>, <span class="number">30</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="변수-자료형"><a href="#변수-자료형" class="headerlink" title="변수/자료형"></a>변수/자료형</h2><h4 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h4><p>변수는 val, var라는 키워드를 이용하여 선언한다.</p><ul><li>val : 변할 수 없는 상수 선언시 사용 / C,C++ 등에서는 const</li><li>var : 일반적인 변수</li></ul><p>코틀린은 자료형을 지정하지 않아도 <strong>자료형을 추론해서</strong> 알아서 자료형을 지정 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> username = <span class="string">"Kildong"</span></span><br><span class="line"><span class="comment">// 코틀린이 자료형을 추론하여 username의 자료형을 String으로 결정</span></span><br></pre></td></tr></table></figure><p>단, 자료형을 명시하지 않는 변수는 자료형을 추론할 수 있는 값을 지정해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username <span class="comment">// 자료형이 지정되지 않아 선언불가</span></span><br></pre></td></tr></table></figure><p>변수에 커서를 대고 Ctrl+Shift+P를 누르면 추론된 자료형을 볼 수 있다.</p><p>쌍따옴표 내부에서 변수를 사용할때는 $ 특수문자를 붙여야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> <span class="keyword">val</span> number = <span class="number">1234</span>  </span><br><span class="line">  </span><br><span class="line"> println(number)  </span><br><span class="line"> println(<span class="string">"<span class="variable">$number</span>"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="자료형"><a href="#자료형" class="headerlink" title="자료형"></a>자료형</h3><p>코틀린의 자료형은 참조형 자료형을 사용한다.</p><ul><li><strong>기본형 자료형(Primitive Data Type)</strong> : int, long, float, double 등</li><li><strong>참조형 자료형(Reference Type)</strong> : String, Date 등</li></ul><p>참조형으로 선언한 변수는 코틀린 컴파일러에서 다시 기본형 자료형으로 대체되기 때문에 굳이 기본형을 신경쓸 필요가 없다.</p><p>언더스코어를 사용하면 자릿값을 구분할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">val</span> cardNum = <span class="number">1234_1234_1234_1234L</span>  </span><br><span class="line"><span class="keyword">val</span> hexVal = <span class="number">0XAB_CD_EF_12</span></span><br></pre></td></tr></table></figure><p>변수를 선언할때는 힙 영역에 실제 데이터를, 스택 영역에 주소값을 넣는다.</p><p>문자열 자료형은 동일한 문자열을 선언할 경우, 이미 힙 영역을 사용하고있는 문자열을 참조하는것이 효율적이므로<br>이전에 선언한 힙 영역의 실제 데이터를 참조하는 주소값을 생성한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="keyword">var</span> str1: String = <span class="string">"Hello"</span>  </span><br><span class="line"> <span class="keyword">var</span> str2 = <span class="string">"World"</span>  </span><br><span class="line"> <span class="keyword">var</span> str3 = <span class="string">"Hello"</span>  </span><br><span class="line"><span class="comment">// 동일한 Hello 라는 값을 선언한 경우 str1이 갖고있는 값의 주소값을 스택에 넣는다.</span></span><br><span class="line">  </span><br><span class="line"> println(<span class="string">"str1 === str2: <span class="subst">$&#123;str1 === str2&#125;</span>"</span>)  </span><br><span class="line"> println(<span class="string">"str1 === str3: <span class="subst">$&#123;str1 === str3&#125;</span>"</span>)  </span><br><span class="line"><span class="comment">// 주소값이 일치하므로 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">실행결과   </span><br><span class="line">str1 === str2: <span class="literal">false</span></span><br><span class="line">str1 === str3: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>코틀린은 아예 변수에 null을 허용하지 않아 NullPointerException 오류가 발생하지 않는다.<br>그래서 코틀린에서 null을 허용하기위해서는 ? 기호를 이용해 선언해야 한다.</p><p>null을 허용한 변수를 사용하기위해선 <strong>세이프 콜과 non-null 단정 기호</strong>를 사용해야 한다.</p><ul><li><strong>세이프 콜</strong> : String? 과 같은 자료형은 변수 뒤에 ?. 을 붙여야 콜이 가능하다.</li><li><strong>non-null 단정기호</strong> : 세이프콜과 같은 역할이며 !!. 을 붙여서 콜을 하지만, null에 대한 검증을 거치지 않아 컴파일은 가능하나 빌드중에 NPE 에러를 낸다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="keyword">var</span> str1 : String? = <span class="string">"Hello Kotlin"</span>  </span><br><span class="line"> str1 = <span class="literal">null</span>  </span><br><span class="line"> println(<span class="string">"str1: <span class="subst">$&#123;str1?.length&#125;</span>"</span>)  <span class="comment">// 세이프콜</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과  </span><br><span class="line">str1 : <span class="literal">null</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="keyword">var</span> str1 : String? = <span class="string">"Hello Kotlin"</span>  </span><br><span class="line"> str1 = <span class="literal">null</span>  </span><br><span class="line"> println(<span class="string">"str1: <span class="subst">$&#123;str1!!.length&#125;</span>"</span>)  <span class="comment">// non-null 단정기호</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> kotlin.KotlinNullPointerException  </span><br><span class="line"> at chap02.section3.Sec3Kt.main(sec3.kt:<span class="number">6</span>)  </span><br><span class="line"> at chap02.section3.Sec3Kt.main(sec3.kt)</span><br></pre></td></tr></table></figure><p><strong>엘비스 연산자</strong>를 이용하면 좀 더 안전하고 효율적으로 null을 허용한 변수를 사용할 수 있다.<br>변수에 들어있는 값이 null일경우 반환값을 특정한 값으로 대체할 수 있다.</p><ul><li><strong>엘비스 연산자</strong> : [?:] 왼쪽의 값이 null일 경우 오른쪽 값을 반환.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="keyword">var</span> str1 : String? = <span class="string">"Hello Kotlin"</span>  </span><br><span class="line"> str1 = <span class="literal">null</span>  </span><br><span class="line"> println(<span class="string">"str1: <span class="variable">$str1</span> length: <span class="subst">$&#123;str1?.length ?: <span class="number">-1</span>&#125;</span>"</span>)  <span class="comment">// 엘비스 연산자 사용</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과  </span><br><span class="line">str1: <span class="literal">null</span> length: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>코틀린에서는 <strong>서로 다른 자료형의 변수를 비교하거나 연산할 수 없다.</strong><br>서로 다른 변수를 같은 자료형으로 직접 만들어야 연산할 수 있다.<br>형변환은 toByte, toLong, toDouble 등을 통해서 변경한다.</p><p>어떤 변수가 정수일수도 있고 실수일 수도 있는 경우, <strong>스마트 캐스트</strong>를 활용한다.<br>일반적으로 처음 선언한 자료형은 뒤에 다른 자료형을 대입할 수 없지만, 스마트캐스트를 이용하면 가능하다.<br>스마트캐스트는 <strong>Number, Any</strong> 등을 써서 다양하게 사용 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="keyword">var</span> test: Number = <span class="number">12.2</span>  </span><br><span class="line"> println(<span class="string">"<span class="variable">$test</span>"</span>)  </span><br><span class="line">  </span><br><span class="line"> test = <span class="number">12</span>  </span><br><span class="line"> println(<span class="string">"<span class="variable">$test</span>"</span>)  </span><br><span class="line">  </span><br><span class="line"> test = <span class="number">120L</span>  </span><br><span class="line"> println(<span class="string">"<span class="variable">$test</span>"</span>)  </span><br><span class="line">  </span><br><span class="line"> test += <span class="number">12.0f</span>  </span><br><span class="line"> println(<span class="string">"<span class="variable">$test</span>"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">결과값  </span><br><span class="line"><span class="number">12.2</span>  </span><br><span class="line"><span class="number">12</span>  </span><br><span class="line"><span class="number">120</span>  </span><br><span class="line"><span class="number">132.0</span></span><br></pre></td></tr></table></figure><p>$변수.javaClass 를 사용하면 변수의 자료형을 얻을 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;References: &lt;a href=&quot;https://acaroom.net/ko/blog/youngdeok/do-it-kotlin-programming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Do it! 코틀린 프로그래밍&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://taeyeonkim93.github.io/categories/Programming/"/>
    
      <category term="Kotlin" scheme="https://taeyeonkim93.github.io/categories/Programming/Kotlin/"/>
    
    
      <category term="do it study" scheme="https://taeyeonkim93.github.io/tags/do-it-study/"/>
    
      <category term="kotlin" scheme="https://taeyeonkim93.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>[kotlin] 1. 코틀린 Hello World</title>
    <link href="https://taeyeonkim93.github.io/2019/09/14/Programming-kotlin-2019-09-14-kotlin-study-1/"/>
    <id>https://taeyeonkim93.github.io/2019/09/14/Programming-kotlin-2019-09-14-kotlin-study-1/</id>
    <published>2019-09-14T07:04:30.000Z</published>
    <updated>2019-09-14T08:57:20.367Z</updated>
    
    <content type="html"><![CDATA[<p>References: <a href="https://acaroom.net/ko/blog/youngdeok/do-it-kotlin-programming" target="_blank" rel="noopener">Do it! 코틀린 프로그래밍</a></p><hr><p>코틀린 공부를 정리하는 포스팅</p><h3 id="코틀린-언어의-장점"><a href="#코틀린-언어의-장점" class="headerlink" title="코틀린 언어의 장점"></a>코틀린 언어의 장점</h3><ul><li>자료형 오류를 미리 검사한다.</li><li>NPE(NullPointerException) 예방으로 인한 안정성이 향상된다.</li><li>간결하고 효율적이다.</li><li>함수형 프로그래밍, 객체지향 프로그래밍 모두 가능하다.</li></ul><h3 id="코틀린-환경-세팅"><a href="#코틀린-환경-세팅" class="headerlink" title="코틀린 환경 세팅"></a>코틀린 환경 세팅</h3><ul><li>JVM 환경에서 실습을 진행하기위하여 JDK(Java Development Kit) 설치가 필요하므로<br><a href="https://www.azul.com/downloads/azure-only/zulu/?&version=java-8-lts&architecture=x86-64-bit" target="_blank" rel="noopener">OpenJDK</a> 설치(안정적인 동작을 위해 Java 8 버전 설치), 환경변수 세팅</li><li><a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">InteliJ</a> IDE 설치</li></ul><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h3><p>코틀린 언어의 Hello World 출력법</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;  </span><br><span class="line"> println(<span class="string">"Hello Kotlin!"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">실행결과</span><br><span class="line">Hello Kotlin!</span><br></pre></td></tr></table></figure><p>Ctrl + Shift + F10으로 빌드가 가능하다.</p><p>코틀린 코드는 main()메서드가 있는 파일 이름을 기준으로 JVM이 자동으로 클래스를 생성하므로 <strong>클래스를 명시하지 않아도 동작한다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">내부에서 자동으로 생성된 코틀린의 클래스  </span><br><span class="line">(tools &gt; Kotlin &gt; show Kotlin Bytecode 혹은 우측 Kotlin Bytecode 클릭)  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloKotlinKt</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line"> <span class="comment">// access flags 0x19  </span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> static main(\[Ljava/lang/String;)V  </span><br><span class="line"> <span class="comment">// annotable parameter count: 1 (visible)  </span></span><br><span class="line"> <span class="comment">// annotable parameter count: 1 (invisible)  </span></span><br><span class="line"> <span class="meta">@Lorg</span>/jetbrains/annotations/NotNull;() <span class="comment">// invisible, parameter 0  </span></span><br><span class="line"> ...  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;References: &lt;a href=&quot;https://acaroom.net/ko/blog/youngdeok/do-it-kotlin-programming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Do it! 코틀린 프로그래밍&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://taeyeonkim93.github.io/categories/Programming/"/>
    
      <category term="Kotlin" scheme="https://taeyeonkim93.github.io/categories/Programming/Kotlin/"/>
    
    
      <category term="do it study" scheme="https://taeyeonkim93.github.io/tags/do-it-study/"/>
    
      <category term="kotlin" scheme="https://taeyeonkim93.github.io/tags/kotlin/"/>
    
  </entry>
  
</feed>

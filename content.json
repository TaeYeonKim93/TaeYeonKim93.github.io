{"meta":{"title":"Taeyeon","subtitle":"Taeyeon's blog","description":"Taeyeon's dev blog","author":"Taeyeon Kim","url":"https://taeyeonkim93.github.io","root":"/"},"pages":[{"title":"About me","date":"2019-09-11T12:43:47.000Z","updated":"2019-09-11T12:48:05.156Z","comments":true,"path":"about/index.html","permalink":"https://taeyeonkim93.github.io/about/index.html","excerpt":"","text":"김태연"}],"posts":[{"title":"[PineScript] PineScript (TradingView) Guide for Beginners (파인스크립트 배우기)","slug":"Coin-PineScript-2022-03-26-pinescript-1","date":"2022-03-25T16:44:54.000Z","updated":"2022-03-25T16:47:54.303Z","comments":true,"path":"2022/03/26/Coin-PineScript-2022-03-26-pinescript-1/","link":"","permalink":"https://taeyeonkim93.github.io/2022/03/26/Coin-PineScript-2022-03-26-pinescript-1/","excerpt":"","text":"asdsd","categories":[{"name":"Coin","slug":"Coin","permalink":"https://taeyeonkim93.github.io/categories/Coin/"},{"name":"PineScript","slug":"Coin/PineScript","permalink":"https://taeyeonkim93.github.io/categories/Coin/PineScript/"}],"tags":[{"name":"PineScript","slug":"PineScript","permalink":"https://taeyeonkim93.github.io/tags/PineScript/"}]},{"title":"[Android] 프레임워크 패턴 정리(MVC, MVP, MVVM, VIPER)","slug":"Develop-Programming-kotlin-2019-12-02-android-framework-pattern","date":"2019-12-02T07:39:54.000Z","updated":"2019-12-21T05:51:39.543Z","comments":true,"path":"2019/12/02/Develop-Programming-kotlin-2019-12-02-android-framework-pattern/","link":"","permalink":"https://taeyeonkim93.github.io/2019/12/02/Develop-Programming-kotlin-2019-12-02-android-framework-pattern/","excerpt":"","text":"안드로이드 패턴 MVC, MVP, MVVM 이 가장 많이 쓰이는 패턴들이다. 협업, 유지보수, 테스트가 용이해진다. 화면에 보여주는 로직과 실제 데이터가 처리 되는 로직을 분리하는게 목적 패턴을 적용하지 않고 하나의 Activity 에서 표현한다면 이와 같다. 화면 제공 유저 이벤트 업무 로직 화면 업데이트 각 패턴의 재료 Data Object (자료 객체) 기본이 되는 데이터의 순수 객체 표현 Business Logic (비즈니스 로직) 데이터를 생성/표시/저장/변경 하는 로직 대부분의 Use Case 가 구현될 부분 Coordinator 이벤트 핸들링이나 Business Logic을 제외한 기타 로직 외부 API 호출이나 DB 호출도 들어갈 수 있다. Converter 로컬에 존재하는 Domain Data 를 표현 계층의 데이터 형태로 Formatting 하는 역할 복잡하지 않으면 Controller 나 Abstract View 안으로 들어갈 수 있음 Abstract View 실제 화면에 표시되기 전의 추상화된 데이터 View Logic 추상화되어있는 데이터가 화면에 어떻게 표현될지 구체적 로직을 구성함 View Logic 이 존재하지 않는 디자인을 불러오기위한 역할 Event Bundle 사용자 입력이나 외부 요인에 의한 데이터 변경을 정의 View 또는 Data 쪽으로 흡수 될 수 있다 External Interface DB 접근, API 호출 등 외부 시스템과의 연동 인터페이스. MVC (Model + View + Controller) Model 실제 데이터 및 데이터 조작 로직을 처리하는 부분 12345678910111213141516171819202122class MainModel(val context: Context) &#123; fun getListDatas(): ArrayList&lt;String&gt; &#123; val datas: ArrayList&lt;String&gt; = ArrayList&lt;String&gt;() //dbms val helper=DBHelper(context) val db=helper.readableDatabase val cursor = db.rawQuery(\"select * from tb_test\", null) while(cursor.moveToNext())&#123; datas.add(cursor.getString(1)) &#125; db.close() return datas &#125; fun addItem(item: String)&#123; val helper=DBHelper(context) val db=helper.writableDatabase db.execSQL(\"insert into tb_test (todo) values (?)\", arrayOf(item)) db.close() &#125;&#125; View 사용자에게 제공되어 보여지는 UI 부분 layout(xml) 만을 View 로 정의한다. Activity, Fragment 의 경우에는 Controller 로 정의 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ListView android:id=\"@+id/listView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:layout_alignParentBottom=\"true\"&gt; &lt;EditText android:id=\"@+id/editView\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\"/&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"add\"/&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; Controller 사용자의 입력을 받고 처리하는 부분 Activity, Fragment 가 이러한 역할을 대신함 123456789101112131415161718192021222324class MVCMainActivity : AppCompatActivity(), View.OnClickListener &#123; lateinit var datas: ArrayList&lt;String&gt; lateinit var adapter: ArrayAdapter&lt;String&gt; val model=MainModel(this) override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) button.setOnClickListener(this) datas=model.getListDatas() adapter=ArrayAdapter(this, android.R.layout.simple_list_item_1, datas) listView.adapter = adapter &#125; override fun onClick(v: View?) &#123; val data: String = editView.text.toString() model.addItem(data) datas.add(data) adapter.notifyDataSetChanged() editView.setText(\"\") &#125;&#125; 로직 Controller 로 사용자의 입력을 받음 사용자의 입력으로 인해 Model 값을 변경해야하는지 검사한다. (T) Controller 에서 Model 의 데이터를 가져오거나 갱신한다. Controller 에서 UI 를 갱신한다. MVVM (Model + View + ViewModel) Model 업무로직을 수행하고 결과에 대한 데이터를 표현한다. View 화면 표시가 주 목적 Activity, FrameWork 역할 12345678910111213141516class MVVMMainActivity : AppCompatActivity(), View.OnClickListener &#123; val viewModel: MainViewModel= MainViewModel(this) override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) button.setOnClickListener(this) viewModel.onCreate() &#125; override fun onClick(v: View?) &#123; val data: String = editView.text.toString() editView.setText(\"\") viewModel.onClick(data) &#125;&#125; ViewModel Model 과 View 를 분리 시키는게 목적 View 가 필요한 Data 와 Command 제공 Actiity 객체나 onCreate 등 LifeCycle 업무가 포함될 수 있다. Model 결과에 의한 데이터 바인딩이 직접 될 수 있다. 1234567891011121314151617class MainViewModel(val activity: Activity)&#123; lateinit var datas: ArrayList&lt;String&gt; lateinit var adapter: ArrayAdapter&lt;String&gt; val model=MainModel(activity) fun onCreate()&#123; datas=model.getListDatas() adapter= ArrayAdapter(activity, R.layout.simple_list_item_1, datas) activity.listView.adapter = adapter &#125; fun onClick(data: String)&#123; model.addItem(data) datas.add(data) adapter.notifyDataSetChanged() &#125;&#125; MVP (Model + View + Presenter) MVP 패턴의 가장 큰 의의는 View와 Model을 완전하게 분리해서 사용 할 수 있어야 한다. interface 순수한 interface를 정의한다. Constant를 정의할때도 interface를 활용한다. Model, View, Presenter에서 사용할 function들을interface 형태로 정의한다. 12345678interface IMainPresenter &#123; fun getListView(): ArrayList&lt;String&gt; fun addItem(item: String) interface IView &#123; fun updateListView(item: String) &#125;&#125; Model presenter에 정의된 함수들에 대한 내용을 작성한다. data class 를 정의한다. View Presenter 에 이벤트 핸들링을 위임한다. Activity 가 View interface 를 구현해서 Presenter에서 코드를 만들 인터페이스를 갖도록 하면 된다. Activity / Fragment 에 속하는 분류는 전부 View에 속한다. interface 폴더에서 만든 view의 interface를 가지고 있음. 12345678910111213141516171819202122232425class MVPMainActivity : AppCompatActivity(), View.OnClickListener, IMainPresenter.IView&#123; val presenter: MainPresenter = MainPresenter(this) lateinit var datas: ArrayList&lt;String&gt; lateinit var adapter: ArrayAdapter&lt;String&gt; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) button.setOnClickListener(this) presenter.view=this datas=presenter.getListView() adapter= ArrayAdapter(this, android.R.layout.simple_list_item_1, datas) listView.adapter = adapter &#125; override fun onClick(v: View?) &#123; val data: String = editView.text.toString() presenter.addItem(data) &#125; override fun updateListView(item: String) &#123; datas.add(item) adapter.notifyDataSetChanged() &#125;&#125; Presenter model에서 사용할 interface를 선언하여 각자 할일을 정의해준다.(view에서 직접 override 하기도 함) interface를 가져와서 override한뒤 필요한 함수들을 넣어서 View 의상호작용에 필요한 함수들을 정의한다. 12345678910111213 class MainPresenter(val context: Context): IMainPresenter &#123; var model: MainModel= MainModel(context) lateinit var view: IMainPresenter.IView override fun getListView(): ArrayList&lt;String&gt; &#123; return model.getListDatas() &#125; override fun addItem(item: String) &#123; model.addItem(item) view.updateListView(item) &#125;&#125; VIPER (View + Interactor + Presenter + Entity + Router) View 사용자 입력을 Presenter 로 보내는 작업 UI View Controller 에 해당 View Life Cycle : Life Cycle 관련 함수가 호출되는것을 Presenter 에 알림 View Event : Event 관련 함수가 호출되는 것을 Presenter 에 알림 View Control : 뷰의 UI 생성,변경,삭제 등의 방법을 Presenter 에 제공 Interactor API 로부터 data 를 받아 entity(model) 을 생성함 Presenter Interactor 에서 data 를 요청하고 받음 view logic 을 갖고 있으며 Interactor 에서data 를 받으면 View 에 어떻게 그릴지 알려줌 Life Cycle에 대한 처리 Entity Interactor 에 의해 만들어지는 Model 네트워크, DB 등의 데이터 모델 Realm Object, NSUserDefaults, Json Data 등 Router Navigation logic 을 담당하며 screen 에서 다른 screen 으로 화면이변경되는 부분을 처리함 VIPER 컴포넌트들의 DI 를 담당함 특징 Distribution : 4개의 구조 중 제일 분배가 잘 되어있음 Testability : 테스트에 용이함 Hard to use : 코드 양이 제일 많음. 작은 기능에도 많은 클래스를 작성해야함","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"MVP","slug":"MVP","permalink":"https://taeyeonkim93.github.io/tags/MVP/"},{"name":"MVC","slug":"MVC","permalink":"https://taeyeonkim93.github.io/tags/MVC/"},{"name":"MVVM","slug":"MVVM","permalink":"https://taeyeonkim93.github.io/tags/MVVM/"},{"name":"VIPER","slug":"VIPER","permalink":"https://taeyeonkim93.github.io/tags/VIPER/"}]},{"title":"[Android] 안드로이드 디자인 관련 이슈 정리","slug":"Develop-Programming-kotlin-2019-11-21-android-design-issue","date":"2019-11-21T13:31:45.000Z","updated":"2019-12-22T07:00:33.261Z","comments":true,"path":"2019/11/21/Develop-Programming-kotlin-2019-11-21-android-design-issue/","link":"","permalink":"https://taeyeonkim93.github.io/2019/11/21/Develop-Programming-kotlin-2019-11-21-android-design-issue/","excerpt":"","text":"UI, layout 등 안드로이드 디자인 관련 기억하고 싶은 내용을 적는 곳 목차레이아웃 종류디자인 용어 정리뷰 종류디자인 함수 정리디자인 관련 유용한 사이트 정리UI 코딩 시 사용하는 구성요소xml 에서 사용하는 속성 정리res 폴더 정리 1. 레이아웃 종류 Frame Layout 자식 뷰들을 겹쳐서 배치한다. 화면에 표시되는 View를 바꿔가면서 표현하고싶을때 사용 일반적으로는 하나의 자식 뷰를 보여주기 위함이다. Linear Layout 선택된 방향(수직 또는 수평) 에 따라 일자로 자식 뷰들을 배치한다. 각 자식 뷰는 가중치(weight value)를 설정해서얼마나 많은 레이아웃 공간을 차지할 것인지 정할 수 있다. Table Layout 자식 뷰들을 격자 형태의 행과 열로 배치한다. 하나의 테이블에 있는 각 행은 TableRow 객체로 나타내며, 각 셀의 뷰 객체를 포함한다. 이것보단 Grid Layout 을 사용한다. Relative Layout 다른 자식뷰들과 상대적으로 비교해서 배치한다. 다양한 화면 크기와 방향에서 동작하는 사용자 인터페이스를 구현할 수 있다. Absolute Layout 자식 뷰들을 특정 XY좌표에 위치하게 배치한다. 화면 크기가 달라지는것에 유연하게 대처하기 힘들기때문에 하지 않는것이 좋다 Grid Layout 격자무늬(grid)를 구성하여 각 셀에 자식 뷰들을 배치한다. 컴포넌트들의 간격은 스페이스 뷰라는 특별한 타입의 뷰를 인접 셀에 두어서 구현하거나마진 매개변수를 설정해서 구현할 수 있다. 테이블 레이아웃의 단점을 보완한 레이아웃이다. Coordinator Layout 화면 위 앱 바(app bar)와 다른 자식 뷰들과 상호작용을 하기위한 레이아웃이다. Frame Layout과 유사하다. Behavior을 자식 뷰에 지정할 수 있다. 자식 뷰들은 anchor를 가진다. anchor는 일반적으로 다른 뷰를 가리키며, 뷰의 id값으로 표시된다. anchor는 반드시 Coordinator layout 하위의 자손 뷰중 하나의 아이디여야 한다. insetEdge를 이용해 자식 뷰들이 어떻게 배치될지 지정할 수 있다. 레이아웃 구조12345678910111213&lt;CoordinatorLayout&gt; &lt;AppBarLayout&gt; &lt;ToolBar/&gt; &lt;/AppBarLayout&gt; &lt;include/&gt; &lt;NestedScroolView/&gt; &lt;FloatingActionButton/&gt;&lt;/CoordinatorLayout&gt; DrawerLayout 서랍처럼 등장하는 레이아웃 모든 뷰보다 최상위에 있어야 함 레이아웃 구조123456789101112&lt;DrawerLayout&gt; &lt;CoordinatorLayout&gt; &lt;include/&gt; &lt;SwipePlaceHolderView/&gt; &lt;/CoordinatorLayout&gt; &lt;NavigationView/&gt;&lt;/DrawerLayout&gt; 2. 디자인 용어 정리 뷰 (View) 화면의 표시될 모든 클래스에 대한 모음집(패키지) 이다. 사용자가 보는 화면의 모든 인터페이스의 요소들은View (android.view.View) 클래스의 서브 클래스다. 위젯을 자식으로 둔 부모클래스이다. 위젯 (Widget) 화면 상 UI 요소들에 대한 모음집(패키지) 이다. ImageView, TextView, Button 등의 통칭이다. 이들은 View, ViewGroup의 클래스를 무조건 상속받는다. 뷰 그룹(ViewGroup) Widget 들을 자식으로 가진 View 이다. 주로 Layout, AdapterView 등 하위 widget 들을그룹핑 해야하는 Widget 클래스들의 모음집(패키지)이다. 앱 위젯(AppWidget) 다른 App 위에 올라가는 소형 View이다. 네비게이션 드로어(Navigation Drawer) / 항법 서랍장 왼쪽에서 출현하는 서랍장과 같은 기능 네비 바 라고도 부른다. 앱 바(App bar) 화면 최상단에 Bar 형식으로 들어가는 작업 표시줄 ActionBar 는 Activity 에 작업표시줄에 대한 개념 Toolbar 는 Widget 으로, Activity 의 앱 바로 설정할 수 있다. 스타일(Style) View 또는 창의 모양과 형식을 지정하는 속성 모음 height, padding, font-color, font-size, background 등의 속성 지정 가능 Layout 내 xml 과 별개인 xml resource 에 정의됨 테마(Theme) 개별 View 가 아닌 전체 Activity 또는 Application 에 적용되는 Style 3. 뷰 종류 Recycler View ListView 의 대체로 나온 View 사용자가 관리하는 많은 수의 데이터 집합(Data Set) 을 개별 Item 단위로구성하여 화면에 출력하는 ViewGroup 이며, 한 화면에 표시되기 힘든많은 수의 데이터를 Scroll 가능한 List 로 표시해주는 Widget 뷰 홀더를 필수로 구현해야 한다. Navigation View navigation 의 내부 내용을 작성할 수 있는 View 두가지의 레이아웃으로 나뉘어있다 headerLayout : 상단 헤더부분 레이아웃 menu : 하단 메뉴부분 레이아웃 4. 디자인 함수 정리Recycler View onCreateViewHolder([ViewGroup], [viewType]) viewType 형태의 ItemView 를 위한 ViewHolder 객체 생성 onBindViewHolder([ViewHolder], [position]) position 에 해당하는 데이터를 ViewHolder 의 ItemView 에 표시 getItemCount() 전체 아이템 갯수 리턴 setLayoutManager([LayoutManager]) 레이아웃매니저를 지정한다. new LinearLayoutManager(this) 와 같이 매개변수를 넣는다. 이외에 GridLayoutManager, StaggeredGridLayoutManager 가 있다 setAdapter([adapter]) 어답터를 지정한다. 액션바 setSupportActionBar(Toolbar) 화면 상단 액션바를 toolbar 위젯으로 사용하도록 설정가능 기본 액션바를 NoActionBar로 변경해야 한다 사용 예시1setSupportActionBar(toolbar) ActionBarDrawerToggle(activity, drawerLayout, toolbar, openDrawerContentDescRes, closeDrawerContentDescRes) 액션바에 Drawer 을 토글로 붙여 사용할 수 있도록 한다. @param 현재 Activity Toolbar drawer 레이아웃 열었을때 나올 String 닫았을때 나올 String 사용 예시123456789101112val toggle = ActionBarDrawerToggle( this, drawerLayout, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close)drawerLayout.addDrawerListener(toggle)// drawerLayout은 drawerLayout의 idtoggle.syncState()// 토글이 계속해서 동기화 될수 있도록 함navView.setNavigationItemSelectedListener(this)// navView 는 네비게이션 내 Item들을 담당하는 View id 5. 디자인 관련 유용한 사이트 정리 https://material.io/ 구글에서 표준으로 지정하는 material 디자인 가이드 6. UI 코딩 시 사용하는 구성요소 LayoutManager (레이아웃 매니저) 아이템 뷰가 나열되는 형태를 관리하기 위한 요소 Adapter (어댑터) 사용자 Data Set 으로부터 Item View 를 만드는 역할 ViewHolder (뷰홀더) 화면에 표시될 Item View 를 저장하는 객체 어댑터 내부에서 생성됨 7. xml 에서 사용하는 속성 정리 android:id android:layout_marginStart : 좌측에서부터 margin android:layout_marginEnd : 우측에서부터 margin android:layout_width android:layout_height android:layout_gravity : View 의 위치 (left,right,bottom,center,top) 8. res 폴더 정리 anim drawable layout menu mipmap values","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://taeyeonkim93.github.io/tags/Android/"},{"name":"Android issue","slug":"Android-issue","permalink":"https://taeyeonkim93.github.io/tags/Android-issue/"},{"name":"Android Design","slug":"Android-Design","permalink":"https://taeyeonkim93.github.io/tags/Android-Design/"}]},{"title":"[Android] Dagger2 정리","slug":"Develop-Programming-kotlin-2019-11-20-android-dagger","date":"2019-11-20T08:10:24.000Z","updated":"2019-12-17T11:39:44.836Z","comments":true,"path":"2019/11/20/Develop-Programming-kotlin-2019-11-20-android-dagger/","link":"","permalink":"https://taeyeonkim93.github.io/2019/11/20/Develop-Programming-kotlin-2019-11-20-android-dagger/","excerpt":"","text":"의존성? 의존성? 코드에서 두 모듈간의 연결 두 클래스 간의 관계 의존성이 크다는 것은 Coupling(결합도)가 높다는 것 의존성이 왜 중요한가? 하나의 모듈이 변경됨에 따라 결합된 다른 모듈이 영향을 받게 된다. 두개의 모듈일때는 괜찮지만 최악의경우 모듈이 100개,1000개…n 개 일때 하나의 모듈변경으로 인해 n-1개의 모듈이 영향을 받는다고 생각해보자 나머지 모듈이 제대로 동작하는지에 대한 검증이 필요할 수도 있다. 그럼 시간과 비용도 n만큼?? 결합도가 높으면 독립성이 떨어진다. 반대로 결합도가 낮으면 독립성이 높아진다. 의존성 주입 구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일등을 통해 정의되게 하는 디자인 패턴 외부에서 인스턴스 변수를 생성하여 넘겨주는(주입하는) 것 객체가 자신이 사용할 객체를 스스로 선택하지 않고제 3의 객체에게 사용될 객체를 주입받는다.(의존 관계 역전) 123public Example(DatabaseThingie useThisDatabaseInstead) &#123; myDatabase = useThisDatabaseInstead;&#125; useThisDatabaseInstead 라는 다른 클래스의 인스턴스를 사용하게 만듬 Example 클래스에 “의존성” 을 “주입” 했다 의존성 주입의 목적 독립된 모듈에 대한 테스트 코드 작성이 가능하다. 하나의 모듈이 변경되어도 다른 모듈들이 영향을 받지 않는다. 객체 생성을 외부에서 하므로 재사용성이 높아진다. Dagger? Dagger : Dependency Injection (의존성 주입) Framework Provides 메소드로 이루어진 Module 을 작성한다. Component 를 작성해서 Module 과 연결하고, 의존성 객체를 주입받을 객체를 만든다. 객체를 일단 만들고, 모듈로 객체를 사용하는 방법을 정의하고,컴포넌트로 모듈을 메인으로 사용할 클래스에 전달한다. Dagger 의 Inject 방법 Constructor Injection (생성자 주입) Method(Setter) Injection (메소드 주입) Field Injection Provides 어노테이션이 달린 메소드를 Dagger Pool 에 제공하겠다는 의미 모든 Provides 메소드는 @Module 클래스 안에 속해야 함 Binds Provides 와 같지만 매개변수를 바로 return 한다 Provides 의 개선된 버전 Multibinding Set 이나 Map 을 이용한 Multibinding 을 지원함 1234567891011@Providespublic LoginContract.Presenter provideLoginPresenter(LoginPresenter loginPresenter) &#123; return loginPresenter;&#125;---------------------------------------------------------------@Bindspublic abstract LoginContract.Presenter provideLoginPresenter(LoginPresenter loginPresenter); Scope 해당 클래스의 단일 인스턴스가 존재하는 범위 Singleton scope Application scope 를 가지는 annotation 싱글톤 scope 를 특정하게 지정해주면 아무 곳에서나 inject 할 수 있다. Module 의존성 객체를 생성함 Inject 의존성 주입을 요청하는 Annotation @Inject 를 사용하면, Component 가 Module 을 이용해 Generate 한 객체들이Inject Annotation 이 달린 함수에 주입된다. Component 구성요소 라는 뜻. Application Component 는 어플리케이션 구성요소이다. 이 annotation 이 달려있는 인터페이스는 의존성 주입 코드가 generate 된다 module class 에서 제공받은 객체를 어떤곳에 주입 할지 정하는 역할을 한다. Activity 에서 build 를 통해 받을 곳이라는 명시를 해야 한다 Subcomponent 부모 component 가 존재하는 component 코드 생성은 부모 component 에서 이루어진다 사용법은 interface 나 abstract class 에 @Subcomponent 를 달아줌 Qualifier 같은 Return 값을 가질 때 구별하기 위한 annotation 같은 값을 return 하는 경우 @other1 @other2 로 구분이 때 Inject 할때도 @other1 @other2 를 붙여서 구분해서 inject 가능 안드로이드에서의 사용법 Dagger2 코딩하기 Dagger2 를 빌드할 Activity 를 만들기 전체를 총괄할 AppComponent 만들기 1. 애플리케이션에서 Dagger 빌드하기 우리가 첫 공부할때 Main 문에서 하듯 Dagger2 의 실행부터 역으로 살펴보기로 한다. Activity 의 인스턴스를 Android OS 내에서 만들기 때문에 (new Activity 가 불가능)Life Cycle 내에서 반드시 Constructor Injection 이 아닌 Field Injection 이 이루어져야 한다. 과거의 방식 12345((MyApplication) getApplication()) .getAppComponent() .myActivity(new MyActivityModule(userId)) .build() .inject(this); 최근 방식 Class 가 어떤 방식으로 의존성 주입이 되는지 전혀 알 필요 없게 구성되었다.12345DaggerAppComponent .builder() .application(this) .build() .inject(this); 2. AppComponent 로 전체 모듈 구성하기 빌드할 메인 에플리케이션을 만들었으면, 빌드에 필요한 재료를 만든다. AppComponent interface 는 module 들을 Component 라는 영역에 가두고,Builder 로 Component 영역에 접근 할 수 있게 만든다. 빌드 할 때 Component Annotation 에 기입된 모듈에 있는 모든 클래스는 인스턴스가 생성된다. @Component.Builder 1234567891011121314151617181920@Singleton@Component(modules = [ (AndroidInjectionModule::class), (AppModule::class), (ActivityBuilder::class)])interface AppComponent &#123; @Component.Builder interface Builder &#123; @BindsInstance fun application(application: Application): Builder fun build(): AppComponent &#125; fun inject(app: MvpApp)&#125; 3. AppModule 로 전체 객체 구성하기4. 사용할 Activity 구성하기 MVP 구성 interactor 폴더 [Activity 이름]Interactor [Activity 이름]MVPInteractor presenter 폴더 [Activity 이름]Presenter [Activity 이름]MVPPresenter view 폴더 [Activity 이름]Activity [Activity 이름]MVPView [Activity 이름]ActivityModule Module 에서 Model 역할인 Interactor 와 Presenter 을 Provides 함 activityDispatchingAndroidInjector: DispatchingAndroidInjector 제네릭 타입으로 클래스를 선언함으로써 객체를 선언할때 강한 TypeCheck 를 하고 객체 생성 시타입변환(Casting) 을 하지 않아도 된다. @Inject Annotation 을 사용함으로써 Generate 되어있던 Reflection 없이 사용하기 Reflection : 자바 언어의 기능 중 하나로 프로그램 내부 속성을 조작 할 수 있게함 12345678910111213141516public class FrombulationActivity extends Activity &#123; @Inject Frombulator frombulator; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 반드시 선행되어야 할 작업, 그렇지 않으면 frombulator는 null이 됩니다. ((SomeApplicationBaseType) getContext().getApplicationContext()) .getApplicationComponent() .newActivityComponentBuilder() .activity(this) .build() .inject(this); // 인젝션이 끝났으므로 신나는 코딩 이예~ &#125;&#125; 빌드 후 인젝션하는 단순 반복되는 보일러플레이트코드가 너무 많다. 종속성 주입의 원칙인 클래스가 주입되는 방식에 대해서 알지 않아도 되게 만들어야한다. AndroidInjection AndroidInjection.inject() 를 호출 하면 애플리케이션으로부터DispatchingAndroidInjector&lt;Object&gt; 를 얻게되고 해당 액티비티를 인자로 메소드 인젝션 하게된다. @Binds 나 @Provider 을 설정하지 않아도 Activity 와 바인딩 할 수 있다. 1private fun performDI() = AndroidInjection.inject(this) 기타 @ContributesAndroidInjector 반환타입을 통해 AndroidInjector 를 생성시켜주는 인터페이스 Component 에서 Module 을 Activity 에 Inject 시켜주는 일을 간단히 하게 해준다. Dagger 에서는 항상 “객체” 를 Provide 하고, “객체” 를 Inject 해서 사용한다","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://taeyeonkim93.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://taeyeonkim93.github.io/tags/Kotlin/"},{"name":"Koin","slug":"Koin","permalink":"https://taeyeonkim93.github.io/tags/Koin/"},{"name":"Dagger","slug":"Dagger","permalink":"https://taeyeonkim93.github.io/tags/Dagger/"},{"name":"DI","slug":"DI","permalink":"https://taeyeonkim93.github.io/tags/DI/"}]},{"title":"[Android] Retrofit 으로 서버-앱 통신 구현하기","slug":"Develop-Programming-kotlin-2019-11-20-android-network","date":"2019-11-20T04:57:47.000Z","updated":"2019-12-03T08:54:18.999Z","comments":true,"path":"2019/11/20/Develop-Programming-kotlin-2019-11-20-android-network/","link":"","permalink":"https://taeyeonkim93.github.io/2019/11/20/Develop-Programming-kotlin-2019-11-20-android-network/","excerpt":"","text":"안드로이드 앱에서 서버-앱 통신으로 가장 많이 쓰이고, 가장 편하게 사용할 수 있는 프레임워크가 Retrofit 이다.사용법은 간단하지만 각자 사용하는 방식이 달라 깔끔하게 정의하고 사용할 수 있도록 한다. 클라이언트의 입장에서만 기록한다. 준비사항 \\interface\\Constant 에 들어갈 내용 :BASE URL(연결할 사이트의 URL, 뒤에 꼭 “/“ 붙여야함), API KEY, USER KEY 등 manifest 에 Internet Permission 취득 1&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; Rest API 에 사용되는 Request 함수 내용 정의 1. Retrofit 객체 생성 Retrofit 의 각종 기능들을 사용하기 위해 Retrofit 객체를 생성한다. 12345678910111213141516171819202122232425262728293031/** \\model\\ApiManager 폴더 생성* \\model\\ApiService 인터페이스를 만들어서 다른 model 함수에서 통신함수를 만들 뼈대를 만들어준다.*/object ApiManager &#123; val retrofit = Retrofit.Builder() .baseURL(Constant.BASE_URL) .addConverterFactory(GsonConverterFactory.create()) // Json 객체 &lt;-&gt; Java 객체 // 직렬화를 해주는 Gson Converter 라이브러리 추가 .build() // 빌더 패턴을 사용해서 각 인자들을 정의함&#125;--------------------------------------------------------------------/* * Main Activity 사용 예시 */class MainActivity : AppCompatActivity() &#123; var client : ApiService? = ApiManager.retrofit.create(ApiService::class.java) // retrofit 객체 생성 override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) &#125;&#125; 추가사항으로 retrofit 객체 생성시 .client(httpClient.build()) 를 붙여 로그를 확인 가능하다. addHeader를 통해 api key 추가도 가능하다. 12345678910111213141516171819202122232425/* * API 통신 로그 확인 및 고정 헤더 추가용 * 사용시 Retrofit builder에 .client(httpClient.build()) 추가 */fun HttpInterceptor(): OkHttpClient.Builder &#123; val logging = HttpLoggingInterceptor() logging.level = HttpLoggingInterceptor.Level.BODY // 로그 레벨 정의 val httpClient = OkHttpClient.Builder() httpClient.addInterceptor(Interceptor &#123; chain -&gt; val original = chain.request() val request = original.newBuilder() .addHeader(\"x-api-key\", Constant.API_KEY) .build() return@Interceptor chain.proceed(request) &#125;) // 매 신호 송수신마다 헤더 추가 .addInterceptor(logging) // 로그 인터셉터 추가 .build() return httpClient&#125; 2. GET/POST/DELETE 등의 Rest API 클래스 생성 Retrofit 객체를 가지고 통신을 하기위해 Rest API 가 정의되어있어야 한다. ApiService 라는 Class를 만들어 내부 내용을 정의해준다. 1234567891011121314151617interface ApiService&#123; @GET(\"lectures\") fun getLectures() : Call&lt;LecturesResponseModel&gt; // BASE_URL/lectures&amp;code=\"\" 형식으로 들어간다 @GET(\"lectures\") fun getLectureByCode(@Query(\"code\") code : String) : Call&lt;LecturesResponseModel&gt; @POST(\"timetable\") fun addLecture(@Body addLectureBody: HashMap&lt;String,Any&gt;) : Call&lt;JsonElement&gt; @DELETE(\"timetable\") fun deleteLecture(@Body deleteLectureBody: HashMap&lt;String,Any&gt;) : Call&lt;JsonElement&gt; @GET(\"memo\") fun getMemoByCode(@Query(\"user_key\") userKey : String?,@Query(\"code\") code : String?) : Call&lt;MemoResponseModel&gt;&#125; 3. data model 정의 Request 및 Response에 필요한 data model 을 정의해준다. kotlin 에는 data class 를 사용한다. 1234567891011data class LecturesResponseModel( @SerializedName(\"Items\") val lectures: List&lt;LecturesModel&gt;? = null, @SerializedName(\"Count\") val count: Int? = null, @SerializedName(\"ScannedCount\") val scannedCount: Int? = null)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://taeyeonkim93.github.io/tags/Android/"},{"name":"Network","slug":"Network","permalink":"https://taeyeonkim93.github.io/tags/Network/"},{"name":"Retrofit","slug":"Retrofit","permalink":"https://taeyeonkim93.github.io/tags/Retrofit/"}]},{"title":"디자인 패턴 정리","slug":"Develop-CS-디자인패턴-2019-11-19-design-pattern","date":"2019-11-19T11:15:42.000Z","updated":"2019-12-17T12:39:13.143Z","comments":true,"path":"2019/11/19/Develop-CS-디자인패턴-2019-11-19-design-pattern/","link":"","permalink":"https://taeyeonkim93.github.io/2019/11/19/Develop-CS-디자인패턴-2019-11-19-design-pattern/","excerpt":"","text":"디자인 패턴 소프트웨어를 개발 할 때 특정 맥락에서 자주 발생하는 고질적인 문제들에재사용 할 수 있는 훌륭한 해결책 패턴? 각기 다른 소프트웨어 모듈에는 서로 공통되는 설계 문제가 존재하며이를 처리하는 해결책도 공통점이 있다. 이러한 유사점을 패턴이라 한다 디자인 패턴 종류 GoF(Gang of Four) 디자인 패턴 에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides) http://blog.naver.com/PostView.nhn?blogId=2feelus&amp;logNo=220642212134&amp;redirect=Dlog&amp;widgetTypeCall=true 생성 패턴 객체 생성에 관련된 패턴 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다. 추상 팩토리 패턴 서로 연관되거나 의존적인 객체들을 합쳐서 하나의 객체로 만들 수 있게 해주는 패턴 빌더 패턴 팩토리 메서드 패턴 싱글톤 패턴 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴 구조 패턴 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴 어댑터 패턴 브리지 패턴 컴포지트 패턴 데코레이터 패턴 파사드 패턴 프록시 패턴 플라이웨이트 패턴 행위패턴 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴 한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지,객체 사이의 결합도를 어떻게 최소화하는지 책임 연쇄 패턴 반복자 패턴 중재자 패턴 전략 패턴 커맨드 패턴 방문자 패턴 인터프리터 패턴 메멘토 패턴 옵저버 패턴 상태 패턴 템플릿 메소드 패턴 널 오브젝트 패턴 동시성 패턴 반응자 패턴(Reactor Pattern) 디자인 패턴 상세 빌더 패턴 객체를 생성할때 흔하게 사용하는 패턴이다.자바로 코딩할 때 다음과 같은 스타일로 객체를 생성하는 코드가 있다면, 빌더 패턴을 사용했다고 할 수 있다. 1234Member customer = Member.build() .name(\"홍길동\") .age(30) .build(); 자바에서는 다음과 같이 매개변수를 받아 객체를 생성할 수 있다. (빌더패턴 미적용) 점층적 생성자 패턴123456789101112131415161718192021class Car &#123; private int a; private int b; private int c; private int d; public Car(int a, int b) &#123; this(a, b, 0); &#125; public Car(int a, int b, int c) &#123; this(a, b, c, 0); &#125; public Car(int a, int b, int c, int d) &#123; this.a = a; this.b = b; this.c = c; this.d = d; &#125;&#125; 다만 이렇게 적용하면 너무 가독성이 떨어지므로 다음과 같이 패턴화한다. 빌더 패턴12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Car &#123; private int a; private int b; private int c; private int d; public static class Builder &#123; private int a = 0; private int b = 0; private int c = 0; private int d = 0; public Builder() &#123; &#125; public Builder setA(int v) &#123; a = v; return this; &#125; public Builder setB(int v) &#123; b = v; return this; &#125; public Builder setC(int v) &#123; c = v; return this; &#125; public Builder setD(int v) &#123; d = v; return this; &#125; public Car build() &#123; return new Car(this); &#125; &#125; // Car 객체로 return 하기위한 Car 생성자를 생성함 private Car(Builder builder) &#123; a = builder.a; b = builder.b; c = builder.c; d = builder.d; &#125;&#125; 123456Car car = new Car.Builder() .setA(1) .setB(2) .setC(1) .setD(2) .build(); 코틀린에선 클래스를 정의하면서 사용할 수 있는data class가 있으므로 굳이 빌더패턴을 만들 필요가 없다. 팩토리 패턴 클래스의 인스턴스를 생성할때 바로 new 를 써서 생성하지 않고 new Instance() 를 써서 만든다. 팩토리 메소드 패턴 객체를 생성하기 위한 인터페이스를 정의할때, 어떤 클래스의 인터페이스를 만들지는 서브 클래스에서 결정한다. 추상 팩토리 패턴 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다. 추상 팩토리 패턴에는 팩토리 메소드 패턴이 포함될 수 있다. 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하지 않도록 만든다 에 기안한 패턴이다. 필요한 것 객체를 만들기위한 interface (없어도 됨) 위의 interface 를 기반으로 한 객체 클래스 객체 클래스를 선택하기 위한 팩토리 클래스 (서브클래스) 메인 클래스 (서브클래스를 이용해 객체클래스를 선택하기위함) 반응자패턴 (reactor pattern) 이벤트 핸들 패턴의 전형적인 모습이다. 이벤트 핸들링을 위한 객체들을 초기화(Initiate)하고, 여러 통로에서 들어오는 이벤트들을 수신(Receive)하고, 이벤트들을 대응할 객체별로 분할 (Demultiplex)하고, 객체에게 이벤트를 발송(dispatch)해서, 그 객체가 이벤트에 걸맞는 작업을 수행(process events) 한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://taeyeonkim93.github.io/categories/CS/"},{"name":"Design pattern","slug":"CS/Design-pattern","permalink":"https://taeyeonkim93.github.io/categories/CS/Design-pattern/"}],"tags":[{"name":"Design pattern","slug":"Design-pattern","permalink":"https://taeyeonkim93.github.io/tags/Design-pattern/"}]},{"title":"[Android] 안드로이드 이슈 정리","slug":"Develop-Programming-kotlin-2019-11-04-android-issue","date":"2019-11-04T11:13:23.000Z","updated":"2019-12-17T12:03:39.814Z","comments":true,"path":"2019/11/04/Develop-Programming-kotlin-2019-11-04-android-issue/","link":"","permalink":"https://taeyeonkim93.github.io/2019/11/04/Develop-Programming-kotlin-2019-11-04-android-issue/","excerpt":"","text":"앱 개발 도중 기억하고 싶은 이슈를 적는 곳 목차안드로이드 용어 정리안드로이드 생애주기Java와 Kotlin이 다른점정적 변수 및 메서드 사용하기함수 리턴형 숨기기Gradle 꿀팁 안드로이드 용어 정리어렴풋이 알고 있었던 안드로이드의 용어들을 정리한다. Activity (액티비티) 애플리케이션 구성요소 중 “화면” 을 제공하는 단어 주로 화면에 보이는 UI와 상호작용할 수 있는 화면을 제공한다. Interface (인터페이스) 함수들의 묶음을 정의해두기 위해 만든 개념 내부의 함수들은 다른 Class에서 정의한다. boilerplate code(보일러 플레이트 코드) 표준 문안이라는 뜻의 단어 꼭 필요하지만 반복적이고 중복이 많아 코드가 길어져 불편하다. 최소한의 변경으로 재사용할 수 있는 것 적은 수정만으로 여러 곳에 활용 가능한 코드, 문구 각종 문서에서 반복적으로 인용되는 문서의 한 부분 Annotation (애노테이션) 메타데이터 클래스 @를 붙여 다른 클래스나 메소드, 필드, 다른 애노테이션과 결합되어 사용 추가적인 정보를 제공하는 대안이 됨 애노테이션을 활용하면 코드가 컴파일시간에 생성되므로보일러 플레이트 코드를 줄일 수 있다. DAO (Data Access Object) Database 의 data 에 접근을 하기 위한 객체 DB에 접근을 하기위한 로직과, 비즈니스 로직을 분리하기 위해서 사용함 DTO (Data Transfer Object) (Value Object 와 같음) 계층간 데이터 교환을 위한 Java Beans 를 말함 로직을 갖고 있지 않는 순수한 데이터 객체이며 속성과 그 속성에 접근하기위한 클래스 주로 getter, setter 이 적힌 클래스 안드로이드 생애주기어렴풋이 알고 있었던 안드로이드의 생애주기를 정리한다. 안드로이드 시스템은 어느 특정한 main() 함수가 없다. Activity 를 초기화하고, 여기에 있는 콜백 함수들이 호출되게 한다. 맨 처음 앱을 누르면 Manifest 에 MAIN 으로 지정된 Activity 내의 onCreate() 함수가 실행된다. Lifecycle에 따른 기본적인 기능만 정리한다. onCreate() Activity 를 처음 실행할 때 딱 한번만 호출된다. 딱 한번만 발생하는 로직을 담아야 하므로 변수초기화, 클래스 인스턴스화 등의 작업을 한다. onStart() onCreate()가 실행된 이후에 호출된다. Activity 가 Foreground에 나오기 전에 수행되므로 UI를 관리하는 코드를 작성한다. onRestart() onStart()와는 달리 앱이 실행될때는 실행되지 않는다. onStop() -&gt; onRestart() 일때만 실행된다. onResume() onStart()가 수행된 이후에 호출된다. Activity에 포커스가 맞춰져있는동안 onResume()의 상태가 유지된다. 앱이 포커스를 되찾으면 onPause()를 거쳐 onResume()이 다시 수행될 수 있다. 대부분의 자주 사용하는 메소드(새로고침 후에 사용되는)를 적는다. onPause() Activity의 포커스가 다른곳으로 이동하면 호출된다. 앱을 종료하는것 뿐만아니라 일시적인 포커스 이동에도 수행된다. 메모리나 배터리 소모를 일으키는 자원을 해제하는 로직을 구현한다. onResume()이 했던 작업들을 저장하거나 멈추게 한다. Activity가 다시 재개되면 onResume()이 다시 수행된다. onStop() onPause() 이후 단계로 액티비티가 활동을 중지한 상태이다. 대부분의 자원을 해제해야한다. 이후에 Activity가 재개되면 onRestart()를 통해 onStart()를 실행한다. onDestroy() 앱이 종료되는 최종단계로 모든 리소스를 해제한다. Activity 수행 예시 앱을 실행했을때 onCrate() -&gt; onStart() -&gt; onResume() Activity 1에서 Activity 2를 생성했을때 Activity 1 : onPause() -&gt; onStop() Activity 2 : onCreate() -&gt; onStart() -&gt; onResume() Activity 2를 종료하고 1로 돌아왔을때 onRestart() -&gt; onStart() -&gt; onResume() 홈키를 눌러서 백그라운드로 전환됐을 때 onPause() -&gt; onStop() 다시 돌아왔을 때 onRestart() -&gt; onStart() -&gt; onResume() 앱을 종료할 때 onPause() -&gt; onStop() -&gt; onDestroy() 5. Java와 Kotlin이 다른점 상속 생성자가 있는 class를 상속했을때는 무조건 생성자를 받아야 한다. Extends 부모 클래스에서 선언/정의를 모두 하고 자식은 그대로 사용만 할수 있게 상속하는 명령어 코틀린에선 Extends나 Implements나 콜론으로 통일함 Implements 부모 클래스에서 선언만 하며 정의는 자식 클래스에서 오버라이드하도록 상속시키는 명령어 코틀린에선 Extends나 Implements나 콜론으로 통일함 Abstract extends로 사용하지만 abstract로 선언된 클래스는 interface도 가질 수 있음 Super / this super은 상위 클래스에서 멤버변수/메소드를 가져옴 this는 현재 클래스에서 멤버변수/메소드를 가져옴 Java에서 생성자 사용하는 방법 123456public class testClass &#123; String example; testClass(String example2)&#123; this.example = example2; &#125;&#125; 생성자를 따로 만들어서 내부변수를 this로 선언해서 매개변수를 받아야 한다. Kotlin에서 생성자 사용하는 방법 123456789101112131415161718class testClass(var example: String)&#123; println(\"매개변수 : $example\")&#125;// 부를때class testClass2(example2 : String) : testClass(example2) &#123; println(\"example2 를 매개변수로 testClass를 상속받음\")&#125;------------------------------------------------------------------------class testClass(num : Int)&#123; var example : String = \"\" constructor(example2 : String, num : Int) : this(num)&#123; // 기본 생성자를 상속받아야 한다. this.example = example2 &#125;&#125; 생성자는 (var example: String) 이고, 따로 변수 선언없이 바로 사용 가능하다. constructor() 함수를 사용하면 추가적으로 매개변수를 받아서 사용할 수 있다. 인터페이스는 class로 상속받을경우 내부에 있는 모든 함수를 override 해야 한다. 123456789101112//Dagger2 + constructor 예시class MainInteractor@Inject internal constructor( private val questionRepoHelper: QuestionRepo, private val optionsRepoHelper: OptionsRepo, preferenceHelper: PreferenceHelper, apiHelper: ApiHelper) : BaseInteractor( preferenceHelper = preferenceHelper, apiHelper = apiHelper), MainMVPInteractor &#123; BaseInteractor 을 상속받기위해 인자인 preferenceHelper, apiHelper 를 생성자로 받아야함 MainMVPInteractor 는 interface 이므로 그냥 상속 questionRepoHelper 는 클래스 내부에서 사용하기 위한 객체이므로 선언 optionRepoHelper 는 클래스 내부에서 사용하기 위한 객체이므로 선언 Java에서는 매개변수자리에 … 을 사용하면 varargs, 가변인자가 된다. 정적 변수 및 메서드 사용하기 정적 변수를 사용하면 [클래스명].[함수명]혹은 [클래스명].[상수명]등으로 활용 가능하다. 사용처 액티비티/프래그먼트의 인텐트 Extra로 사용하는 키 로그 출력을 위한 태그(Tag) 이름 정의 뷰 내부에서 사용하는 고정된 길이 값 (너비, 높이 등) 각종 유틸리티 클래스 내 메서드 사용법 12345678910111213141516171819202122232425262728293031323334353637/* * object(오브젝트) 기본 정의 */object Foo1 &#123; val BAR1 = \"bar1\"&#125;/* * companion object를 이용한 정의 */class Foo2 &#123; companion object &#123; const val BAR2 = \"bar2\" fun baz() &#123; // Do something &#125; &#125;&#125;------------------------------------------------------------/* * Main Activity에서 object 호출 */override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // object 정의된 BAR1 호출 val str = Foo1.BAR1 // Foo.baz() 함수 호출 Foo2.baz()&#125; 코틀린에서는 object를 이용해서 클래스를 정의함과 동시에객체를 생성할 수 있다 Foo1라는 이름을 가진 객체를 생성한 싱글턴 패턴으로 봐도 무방하다 companion object 를 이용하면 class 내부에 선언된 private property에 접근 가능하다 익명 클래스를 구현할때도 object를 이용한다. 익명 클래스 설명은 익명클래스 사용방법 참조12345678910111213141516171819/* * 익명 클래스 구현 */interface ClickListener &#123; fun onClick() &#125; fun main(args: Array) &#123; setClickAction(object : ClickListener &#123; override fun onClick() &#123; println(\"clicked!!!\") &#125; &#125;) &#125; fun setClickAction(clickListener: ClickListener) &#123; clickListener.onClick() &#125; Gradle 꿀팁 Project 영역 gradle 에서 ext 를 선언하면 gradle 내에서 편하게 쓸 수 있다. 12345678910111213141516171819202122232425262728293031// Project 영역ext &#123; // Sdk and tools minSdkVersion = 19 targetSdkVersion = 29 compileSdkVersion = 29 buildToolsVersion = \"29.0.2\" // App dependencies kotlinVersion = kotlinVersion constraintLayoutVersion = \"1.1.3\" appCompatVersion = \"1.1.0\"&#125;--------------------------------------------------------// Module 영역dependencies &#123; // kotlin implementation\"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlinVersion\" // android support libraries implementation \"androidx.appcompat:appcompat:$rootProject.ext.appCompatVersion\" implementation \"androidx.constraintlayout:constraintlayout:$rootProject.ext.constraintLayoutVersion\" // dependency injection implementation \"com.google.dagger:dagger:$rootProject.ext.daggerVersion\" implementation \"com.google.dagger:dagger-android-support:$rootProject.ext.daggerVersion\" kapt \"com.google.dagger:dagger-compiler:$rootProject.ext.daggerVersion\"&#125; Project 영역 내 android - buildType 에 통신관련 내용을 적으면 안전하게 build 할수 있다. 1234567891011121314android &#123; buildTypes &#123; debug &#123; buildConfigField(\"String\", \"BASE_URL\", \"\\\"http://www.mocky.io/v2\\\"\") buildConfigField(\"String\", \"API_KEY\", \"\\\"ABCXYZ123TEST\\\"\") &#125; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' buildConfigField(\"String\", \"BASE_URL\", \"\\\"http://www.mocky.io/v2\\\"\") buildConfigField(\"String\", \"API_KEY\", \"\\\"ABCXYZ123TEST\\\"\") &#125; &#125;&#125; 함수 리턴형 숨기기코틀린에서는 함수가 return 할때 간단하게 쓸 수 있는 방법이 있다. 1234override fun toString(): String&#123; return content&#125; 1override fun toString(): String = content","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://taeyeonkim93.github.io/tags/Android/"},{"name":"Android FUNCTION","slug":"Android-FUNCTION","permalink":"https://taeyeonkim93.github.io/tags/Android-FUNCTION/"},{"name":"Android issue","slug":"Android-issue","permalink":"https://taeyeonkim93.github.io/tags/Android-issue/"}]},{"title":"[Kotlin] 코틀린 함수 정리","slug":"Develop-Programming-kotlin-2019-10-21-kotlin-function","date":"2019-10-21T12:17:52.000Z","updated":"2019-12-18T13:13:00.512Z","comments":true,"path":"2019/10/21/Develop-Programming-kotlin-2019-10-21-kotlin-function/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/21/Develop-Programming-kotlin-2019-10-21-kotlin-function/","excerpt":"","text":"그때그때 모르는 함수 있으면 정리해서 올리는 용도 목차whenCallbackData Classlateinit, lazypublic, private, internal, protectedGeneric TypeLet 1. when 일반 C같은 곳에서 사용되던 Switch문을 대체함 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; print(\"x is neither 1 nor 2\") &#125;&#125; 보통 Switch의 default는 필수가 아니지만 Kotlin의 When은 else문이 필수로 들어가야 한다. 많은 경우가 동시에 처리되야하면 콤마를 사용한다 1234when (x) &#123; 0, 1 -&gt; print(\"x == 0 or x == 1\") else -&gt; print(\"otherwise\")&#125; 각 조건에 상수가 아닌 함수가 올 수도 있다 1234when (x) &#123; parseInt(s) -&gt; print(\"s encodes x\") else -&gt; print(\"s does not encode x\")&#125; in을 사용하면 범위를 지정할 수 있다. 12345when (x) &#123; in 1..10 -&gt; print(\"x is in the range\") in validNumbers -&gt; print(\"x is valid\") !in 10..20 -&gt; print(\"x is outside the range\") else -&gt; print(\"none of the above\") 인수를 생략해서 사용도 가능하다. 이 경우 해당 조건이 참일 경우에만 분기문이 실행된다. 12345when &#123; x.isOdd() -&gt; print(\"x is odd\") x.isEven() -&gt; print(\"x is even\") else -&gt; print(\"x is funny\")&#125; 2. callback콜백함수는 늘 봐도봐도 헷갈린다. 코틀린에서 콜백함수를 만들고 사용하는 법을 정리한다. 사용법123fun [함수명] (callback: ([변수 자료형]) -&gt; Unit) &#123; callback(변수명)&#125; 콜백함수 문법은 특정 함수의 동작이 끝남과 동시에, 다른 여러 가지 함수를 호출해야 할 경우에 사용된다. Unit 형으로 변수가 Return 되어 다시 위에 선언한 변수의 자료형으로 변환된다.쓰다보면 다중으로 콜백을 해야하는 상황이 생기는데, 이런 경우를 없애는 방법을 찾고싶다. 3. data class코틀린에서 data Class를 이용하면 자바에서 만들어야했던 GET, SET, ToString, Copy 등의 간단한 함수들을 자동으로 구현해준다. 사용법12345678data class LecturesResponseModel( val lectures: List&lt;LecturesModel&gt;? = null, val count: Int? = null, val scannedCount: Int? = null) 주로 Model들의 정의를 할 때 사용한다.소괄호로 이루어져있으므로 쉼표를 붙이며 주의해서 사용해야 한다. 4. lateinit, lazy lateinit 프로퍼티의 초기화를 나중에 하기 위한 키워드이다. 반드시 null이 아닌 변수가 생성당시가 아닌 나중에 초기화를 해야할 때 사용한다. 제약사항 var(mutable) 프로퍼티만 사용 가능 non-null 프로퍼티만 사용 가능 커스텀 getter/setter가 없는 프로퍼티만 사용 가능 primitive type 프로퍼티는 사용 불가능 클래스 생성자에서 사용 불가능 로컬 변수로 사용 불가능 DI에서 사용하는 경우 12@Injectlateinit var presenter: SimpleSignInPresenter DI를 통해 SimpleSignInPresenter를 외부에서 주입받기 때문에별도로 해당 프로퍼티에 명시적으로 null을 대입하지 않는 이상Non-null이라고 확신할 수 있다. lazy 프로퍼티의 초기화를 나중에 하기 위한 함수이다. lateinit은 Modifier이지만 lazy는람다를 파라미터로 받고 Lazy&lt;T&gt; 인스턴스를 반환하는 함수다. 제약사항 val(immutable) 프로퍼티만 사용 가능 primitive type 에도 사용 가능 커스텀 getter/setter가 없는 프로퍼티만 사용 가능 Non-null, Nullable 둘다 사용 가능 클래스 생성자에서 사용 불가능 로컬 변수에서 사용 가능 사용법 1private val toolbar by lazy &#123; home_toolbar &#125; lazy 프로퍼티 연산은 기본적으로 동기화된다. Thread-safe 하다 기본적으로 UNINITIALIZED_VALUE 로 초기화되고 value 호출이 일어날 때 다시 초기화된다. lazy 를 사용하면 activity가 올라온 후에 초기화 할 수 있다. 5. public, private, internal, protected 가시성 제한자이다. kotlin 은 명시적으로 제한자를 지정하지 않으면 public 가시성을 갖는다. 패키지 레벨에서 가시성 제한자에 따른 접근 범위 public : 모든 곳에서 해당 선언에 접근할 수 있다. private : 해당 선언을 포함한 파일 내에서만 접근할 수 있다. internal : 같은 모듈 안에서 접근할 수 있다. protected : 최상위 레벨 선언에서는 protected를 사용할 수 없다.12345678package fooprivate fun foo() &#123;&#125; // example.kt에서만 접근 가능 public var bar: Int = 5 // 프로퍼티는 모든 곳에서 접근 가능 private set // setter는 example.kt에서만 접근 가능 internal val baz = 6 // 같은 모듈 안에서 접근 가능 클래스, 인터페이스 레벨에서 가시성 제한자에 따른 접근 범위 public : 선언한 클래스에 접근할 수 있는 모든 클라이언트가 public 멤버에 접근 가능하다. private : (클래스의 모든 멤버를 포함한) 클래스 안에서만 접근 가능하다. internal : 선언한 클래스에 접근할 수 있는 모듈에 속한 클라이언트가 internal 멤버에 접근 가능하다. protected : private과 동일하지만 + 하위 클래스에서 접근 가능하다.1234567891011121314151617181920212223open class Outer &#123; private val a = 1 protected val b = 2 internal val c = 3 val d = 4 // 기본으로 public protected class Nested &#123; public val e: Int = 5 &#125; &#125;class Subclass : Outer() &#123; // a에 접근 불가 //b,c 그리고 d에 접근 가능 // Nested와 e에 접근 가능 &#125; class Unrelated(o: Outer) &#123; // o.a, o.b에 접근 불가 // o.c(같은 모듈)와 o.d에 접근 가능 // Outer.Nested에 접근 불가, 그리고 Nested::e에도 접근 불가&#125; 6. generic type 제네릭 타입은 Type 을 Parameter 로 가지는 Class 나 Interface 를 말함 클래스 또는 인터페이스 이름 뒤에 &lt;&gt; 부호가 붙고 사이에 타입 파라미터가 위치함 제네릭을 왜 쓰는가? 컴파일 시 강한 Type Check 를 할수 있다. 타입 변환 (Casting) 을 제거한다. 12345678910List list = new ArrayList();list.add(\"hello\");String str = (String) list.get(0); // 타입 변환이 필요--------------------------------------------------------------------List&lt;String&gt; list2 = new ArrayList&lt;&gt;();list2.add(\"hello\");String str2 = list.get(0); // 불필요 타입 파라미터는 일반적으로 대문자 알파벳 한 글자로 표현한다. 123public class 클래스&lt;T&gt; &#123; ... &#125;public interface 인터페이스&lt;T&gt; &#123; ... &#125; 제네릭 타입은 두 개 이상의 멀티 파라미터를 이용할 수 있다. 이 경우 각 타입 파라미터는 콤마로 구분한다. 제네릭 메소드 제네릭 메소드는 매개변수와 반환자료형의 Type 이 Type Parameter 를 갖는 메소드를 뜻함 public &lt;T&gt; [리턴Type] [메소드명] () {} 이와같이 선언함 객체.&lt;T&gt;함수명 이와같이 사용도 가능함. 함수의 리턴 타입을 명시하는 용도 7. Let Let 함수를 호출하는 객체를 block 부분의 인자로 넘긴다. block 의 결과를 반환한다. inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R) : R 사용 예시 널 체크후 코드 실행하고 싶을 경우 블록 내의 결과물을 반환하고 싶을 경우 단일 지역 변수의 범위를 제한하고 싶을 경우 1234567891011121314@Testfun blockTest() &#123; val person = Person(\"park\", \"jieun\") val result = person?.let &#123; printPerson(it.lastName + it.firstName) &#125; Assert.assertEquals(result, \"parkjieun\")&#125;private fun printPerson(msg: String): String &#123; println(msg) return msg&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://taeyeonkim93.github.io/tags/Kotlin/"},{"name":"Kotlin FUNCTION","slug":"Kotlin-FUNCTION","permalink":"https://taeyeonkim93.github.io/tags/Kotlin-FUNCTION/"}]},{"title":"[프로젝트] 안드로이드 앱 개발 구상","slug":"Develop-Project-Android-2019-10-15-app-develop-project-1","date":"2019-10-15T11:54:02.000Z","updated":"2019-11-04T11:13:14.635Z","comments":true,"path":"2019/10/15/Develop-Project-Android-2019-10-15-app-develop-project-1/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/15/Develop-Project-Android-2019-10-15-app-develop-project-1/","excerpt":"","text":"개요개발자로써 커리어를 App 개발로 정했고, 시작으로 간단한 프로젝트를 진행한다.이전에 앱 개발을 해본 경험을 바탕으로 프로토타입용 앱을 개발하려고 한다. 기획과 디자인, 개발 모두 1인으로 진행한다.짧은 시간과 1인 프로젝트인 만큼 toy 프로젝트 형식으로 간단하게 개발한다. 1. 어떤 개발을 할 것인가?짧은 시간제한과 의미있는 프로젝트를 위해 몇 가지 고려해야할 사항이 있다. 어떤 개발환경으로 진행할 것인가? (language, DB, logger, error handling..) 어떤 어플을 만들것인가? 수익구조나 타겟층같은 내용도 고려해야 하지만 toy 프로젝트이므로 그런점은 감안하고 진행한다. 어떤 개발환경으로 진행할 것인가? 개발언어 : Kotlin 2017 Google이 선정한 Android 대표 개발언어. 객체지향 언어라 기존 JAVA 개발과 흡사하며 코드가 간결하다. DB : SQLite Android 개발시에 사용할 DB. 마지막 개발한지 몇년이 지나서 아직도 이걸 쓰는지 모르겠다 Realm 도 검토예정 Server : AWS $0.88 매달 내면서 이용중인 개인서버가 있다. 유저가 로컬만 사용하는 어플이 아니어서 회원가입, 로그인 등에 이용가능할듯 기타 사항은 만들면서 추가 예정 어떤 어플을 만들 것인가?1인개발의 장점을 살리기 위해서는 화려한 기능보다는 적은 기능에 집중하는게 좋다.아이디어를 고민하던 중 친구의 도움을 받아 일정 관리 어플을 만들어보기로 했다. 12345678910111213&lt;챙겼나요?&gt;- 특정 날짜를 지정해서 한줄메모를 계속 추가할 수 있음- 위젯으로 각 날자에 써놓은 항목을 배경화면이나 잠금화면 위에 띄울수있음- 각 항목을 클릭하면 삭제선그어짐ex)10월 18일- 우산(삭제선)- 대강당 교육 오후 2시- xx한테 돈보냄?(삭제선)앱은 기능이 많으면 안되고 최대한 단촐하게. 추가한다면 알람정도 일정 관리 어플 장점 구글 Keep 메모, MS 원노트, 에버노트, 리마인더 등 먼저 있었던 앱들을 참고할수 있다. 유저마다 원하는 일정 관리의 형태가 달라 특정 사용자층을 노릴 수 있다 간단하다 실생활에 접목하기 쉽다 일정 관리 어플 단점 시장에 비슷한 어플이 너무 많아 굳이 쓸 이유가 없다 너무…많다… 기존 앱들을 사용해보고 불편했던점을 종합해서 요구사항으로 반영해보기로 했다. 2. 어플 기능 정리 요구사항 정의 123456789101112131415- 메모가 가능해야함 - 가독성이 용이해야함 - 수정이 용이해야함 / 채팅형 방식도 고민중- 다음날짜로 넘어갈경우(24:00 이후) 안에 내용도 모두 다음날짜 내용으로 바뀌어야함- 위젯이 가능해야함. 4x2 ~ 5x5 대응 - 이전 날짜에 있던 모든 일정은 보이지 않아야함(기본) - [메모 유지] Flag 가 On 되어있을경우 다음날짜로 일정이 넘어감 (선택)- 검색창에 내 할일을 찾으면 찾을 수 있어야함 (추가기능)- 리마인더, 구글캘린더와 연동이 가능해야함 (추가기능) - 스마트워치와 연동가능해야함 (추가기능)- 백업이 가능해야함 (추가기능)- 잠금화면 위에 위젯이 올라와야함 (추가기능)- AOD 위로 올라와야함 (추가기능)- 알림이 가능해야함 (추가기능) 기능 정의 1234567891011121314151617181920212223242526272829303132333435363738394041- 메인 화면 구현 - 메인화면 상단 달력 바 구현 - 날짜 클릭 시 해당 날짜의 일정 출현 기능 구현 - 이전 주 / 다음 주 슬라이드 이동 기능 구현 - 월 누르면 월 선택할수있는 박스 기능 구현 - 해당 월의 가장 뒤 날짜로 이동 기능 구현(이번달은 오늘날짜) - # 아래 bar 클릭시 달력 출현 기능 구현 (추가기능) - 메인화면 하단 일정 관리 화면 구현 - 체크박스 기능 구현 (체크할시 취소선) - 우측에 휴지통 버튼 구현 (클릭시 일정 삭제) - 최하단 메모 추가 버튼 구현 (클릭시 일정추가화면으로 이동) - 무한 기능이 들어간 일정의 경우 글자색이 바뀜- 위젯 화면 구현 - 위젯 화면 상단 소형 달력 화면 구현 - 이전 날 / 다음 날 버튼 기능 구현 - 오늘 날짜 표시 기능 구현 - 오늘 날짜로 돌아가기 버튼 구현 - 일정 추가 버튼 구현 - 다양한 크기가 가능해야함 - 위젯 하단 일정 화면 구현 - 당일의 일정 리스트 가져오기 기능 구현 - 취소선이 그어진 일정은 가져오지 않음 - 체크박스 기능 구현 - 체크박스 클릭시 3초뒤에 위젯에서 삭제- 일정 추가 화면 구현 - 뒤로가기 버튼 구현 - 메모 작성칸 구현 - 화면 진입시 오토포커스 - 클릭시 키보드 출현, 내용 입력 가능 - 날짜 기능 구현 - 오늘 날짜 표시 기능 구현 - 이전 날 / 다음 날 버튼 기능 구현 - 하단에 취소 / 저장 버튼 구현 - 저장 기능 구현 - 저장시 해당된 날짜 기준으로 메모 내용 저장 - 무한 버튼 구현 - 무한 버튼이 활성화 되어있을경우 다음날로 넘어가면 다음날에 해당 일정이 추가됨 디자인 정의앱 디자인화면Oven.io 로 구현했다. 프로토타입 디자인하기에 최적의 사이트. 메인화면 위젯화면 일정추가 화면 크게 3개로 분류했고 [해당일정 관리화면]이 따로 필요할 경우 추가예정","categories":[{"name":"Project","slug":"Project","permalink":"https://taeyeonkim93.github.io/categories/Project/"},{"name":"Android","slug":"Project/Android","permalink":"https://taeyeonkim93.github.io/categories/Project/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://taeyeonkim93.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"https://taeyeonkim93.github.io/tags/App/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://taeyeonkim93.github.io/tags/Kotlin/"}]},{"title":"[알고리즘] 완전탐색 알고리즘 정리","slug":"Develop-CS-알고리즘-2019-10-15-exhaustive-search-algorithm","date":"2019-10-15T09:28:36.000Z","updated":"2019-12-03T08:59:44.515Z","comments":true,"path":"2019/10/15/Develop-CS-알고리즘-2019-10-15-exhaustive-search-algorithm/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/15/Develop-CS-알고리즘-2019-10-15-exhaustive-search-algorithm/","excerpt":"","text":"* 19.09.19 작성중.. 완전탐색 알고리즘 이란?어떤 해답에 도달하기까지의 과정을 전부 하나하나씩 검사한다는 의미이다. 가장 이상적인 방법이지만 해결까지에 드는 자원 소모가 많은게 단점이다. 완전탐색 알고리즘의 사용처 무작위의 변수를 비교/탐색해야 할 때 최적화 문제(여러가지 경우를 만들 수 있을때, 가장 적합한 답을 구하는 문제) 완전탐색 알고리즘완전탐색 알고리즘의 종류로는 Brute Force (무작위 대입) DFS (깊이 우선 탐색) BFS (너비 우선 탐색) 백트래킹 네종류가 있다. 1. Brute Force (무작위 대입) 방식 가장 흔히 사용하는, for문으로 배열의 시작값부터 끝값까지 전부 체크하는 방식이다. 123456checkStr = 'qwertyuiopasdfghjkl' # 원래값pattern = 'asdf' # 찾을 값for idx in range(0, len(checkStr)): if checkStr[idx:idx + 4] == pattern: print(\"checkStr에서 patter이 시작되는 index :\", idx) checkStr이 가진 qwertyuiopasdfghjkl 값을 q부터 4개씩 비교해가면서 무작위대입 방식으로 찾는다. (위 예는 checkStr.find(pattern) 내장함수와 동일하다.) 예제 - [프로그래머스] 코딩테스트 풀이 - 모의고사 2. DFS (Depth First Search)아래로 가면서 모든 경우의 수를 전부 탐색하는 방법이다.BF에 비해 구현방식이 간단하다. 트리 그래프는 많은곳에서 볼수있으니 딱히 그리지는 않겠다.보통 재귀함수로 많이 구현한다. DFS 재귀함수 구현조건 종료를 언제 할 것인가? 종료시에 어떤 값을 반환할 것인가?(T/F 두 가지 전부) 왼쪽 / 오른쪽 중 탐색할 방향의 결과값을 담는다 이전 단계에서 탐색하지 않은 방향으로 탐색하게 한다. 다시 원래지점으로 되돌아와서 반환한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://taeyeonkim93.github.io/categories/CS/"},{"name":"알고리즘","slug":"CS/알고리즘","permalink":"https://taeyeonkim93.github.io/categories/CS/알고리즘/"}],"tags":[{"name":"완전탐색","slug":"완전탐색","permalink":"https://taeyeonkim93.github.io/tags/완전탐색/"},{"name":"BRUTE FORCE","slug":"BRUTE-FORCE","permalink":"https://taeyeonkim93.github.io/tags/BRUTE-FORCE/"},{"name":"EXHAUSTIVE SEARCH","slug":"EXHAUSTIVE-SEARCH","permalink":"https://taeyeonkim93.github.io/tags/EXHAUSTIVE-SEARCH/"},{"name":"DFS","slug":"DFS","permalink":"https://taeyeonkim93.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://taeyeonkim93.github.io/tags/BFS/"},{"name":"BACK TRACKING","slug":"BACK-TRACKING","permalink":"https://taeyeonkim93.github.io/tags/BACK-TRACKING/"}]},{"title":"[종만북] 책 내용 정리 2","slug":"Develop-Algorithm-book-2019-10-15-jongman-book-study-2","date":"2019-10-15T05:16:21.000Z","updated":"2019-12-03T08:57:01.809Z","comments":true,"path":"2019/10/15/Develop-Algorithm-book-2019-10-15-jongman-book-study-2/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/15/Develop-Algorithm-book-2019-10-15-jongman-book-study-2/","excerpt":"","text":"프로그래밍 대회에서 배우는 알고리즘 문제해결전략 책 정리용 알고리즘 시간 복잡도 분석 알고리즘의 수행 시간을 지배하는것은 반복문이다. 선형 시간 알고리즘 -&gt; O(n) 선형 시간에 실행되는 알고리즘은 대개 가장 좋은 알고리즘인 경우가 많음 선형 이하 시간 알고리즘 로그함수가 대표적. 입력의 크기가 커지는 것보다 수행시간이 느리게 증가하는 알고리즘들을 선형 이하 시간 알고리즘이라 부름 이진탐색 지수 시간 알고리즘 N, N^2, N 거듭제곱들의 선형결합으로 이루어진 식들을 다항식이라고 부름 반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘들을 다항 시간 알고리즘이라 부름 N이 하나 증가할때마다 걸리는 시간이 배로 증가하는 알고리즘들을 지수 시간 알고리즘이라고 함 시간 복잡도 점근적 시간 표기 : O 표기 주어진 함수에서 가장 빨리 증가하는 항만을 남긴채 나머지를 다 버리는 표기법","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"Book","slug":"Algorithm/Book","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/Book/"}],"tags":[{"name":"공부정리","slug":"공부정리","permalink":"https://taeyeonkim93.github.io/tags/공부정리/"},{"name":"종만북","slug":"종만북","permalink":"https://taeyeonkim93.github.io/tags/종만북/"}]},{"title":"[종만북] 책 내용 정리","slug":"Develop-Algorithm-book-2019-10-09-jongman-book-study-1","date":"2019-10-09T08:50:08.000Z","updated":"2019-12-03T08:57:01.807Z","comments":true,"path":"2019/10/09/Develop-Algorithm-book-2019-10-09-jongman-book-study-1/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/09/Develop-Algorithm-book-2019-10-09-jongman-book-study-1/","excerpt":"","text":"프로그래밍 대회에서 배우는 알고리즘 문제해결전략 책 정리용 알고리즘 문제를 푸는 방법1234561. 문제를 읽고 이해한다2. 문제를 익숙한 용어로 재정의한다3. 어떻게 해결할지 계획을 세운다4. 계획을 검증한다5. 프로그램으로 구현한다6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다. 문제를 읽고 이해한다 초보~고수까지 문제를 잘못읽는 경우가 다반사 문제의 궁극적인 목적, 사소한 제약조건까지 완벽하게 이해해야함 재정의와 추상화 자신이 다루기 쉬운 개념을 이용해서 자신의 언어로 풀어쓰기 현실세계의 개념을 우리가 다루기 쉬운 수학적/전산학점 개념으로 옮겨 표현 계획 세우기 사용할 알고리즘, 자료구조 선택 계획 검증하기 설계한 알고리즘이 모든 경우에 요구조건을 정확히 수행하는지 증명 수행에 걸리는 시간과 메모리가 문제의 제한 내에 들어가는지 확인 계획 수행하기 정확히 구현하기 회고하기 자신이 문제를 해결한 과정을 돌이켜보고 개선하기 문제를 풀 때마다 코드와 함께 자신의 경험을 기록으로 남겨야 함 문제의 간단한 해법과, 어떤 방식으로 접근했는지, 문제의 해법을 찾는데 결정적이었던 깨달음 한번에 맞추지 못한 경우는 오답 원인도 적는게 좋음 다른 사람의 코드를 보면서 공부하는것도 좋음 문제를 풀지 못할 때# 직관과 체계적인 접근 직관은 해당 문제를 해결하는 알고리즘이 대략 어떤 형태를 가질지 짐작하게 함 어려운 문제들은 체계적으로 접근해야 함 비슷한 문제를 풀어본 적이 있던가? 비슷한 문제를 풀어봤으면 이전 방법과 비슷한 접근방법을 사용할 것임 기존 문제를 경험으로 만들려면 원리를 완전히 이해하고 변형할 수 있어야 함 형태가 비슷하지 않더라도 문제의 목표가 같은 경우 또한 이에 소함 어떤 사건의 발생확률/경우의 수를 계산하는 문제는 대부분 동적계획법으로 해결 가능 단순한 방법에서 시작할 수 있을까? 무식하게 풀 수 있을까? 시간과 공간 제약을 생각하지 않고 문제를 해결해봄 점진적인 개선을 통해 알고리즘의 효율성을 증가시킴 내가 손으로 문제를 푸는 과정을 수식화 할 수 있을까? 번뜩이는 영감이 필요한 문제를 만났을때는 다른 방법을 시도해봐야한다. 손으로 여러 간단한 입력(문제에 주어진 예제 입력)을 직접 해결 문제를 해결하는 방법을 공식화해서 답을 만드는 알고리즘을 만들수 있는 경우가 있음 이 과정에서 알고리즘이 어떤 점을 고려해야하는지를 알게됨 문제를 단순화할 수 있을까? 좀더 쉬운 변형판을 먼저 풀어보기. 제약조건을 없애거나, 계산해야하는 변수를 줄이거나, 다차원의 문제를 1차원으로 줄이기도 함 그림으로 그려볼 수 있을까? 관련된 그림을 그려보면 더 쉬움 수식으로 표현할 수 있을까? 평문으로 쓰여있는 문제를 수식으로 표현하는 것도 도움이 됨 문제를 분해할 수 있을까? 문제의 제약조건을 분해할 수 있음 뒤에서 생각해서 문제를 풀 수 있을까? 모든 선택지를 위에서 아래로 내려가 보는 대신에 아래에서 위로 딱 한번만 하면 해결 가능 순서를 강제할 수 있을까? 순서가 없는 문제에 순서를 강제함 경우의 수를 셀 때도 유용함. 특정 조건을 만족하는 답들의 수를 세는 경우 특정 형태의 답만을 고려할 수 있을까? 정규화 기법이 있음 정규화란 우리가 고려해야 할 답들 중 형태가 다르지만 결과적으로 똑같은것들을 그룹으로 묶은 뒤, 각 그룹의 대표만을 고려하는 방법 좋은 코드를 짜기 위한 원칙 간결한 코드를 작성하기 가장 간결한 코드를 작성해야 오타나 버그가 생길 가능성이 적다 적극적으로 코드 재사용하기 같은 코드가 세번 이상 등장한다면 해당 코드를 함수로 분리해 재사용한다 표준 라이브러리 공부하기 시간낭비를 줄일 수 있으나 표준적인 알고리즘 구현 사용법을 잘 알아두기 항상 같은 형태로 프로그램을 작성하기 여러 종류의 반복적인 코드들(BFS, 2차원 자료구조 등)은 항상 같은것으로 사용하기 일관적이고 명료한 명명법 사용하기 모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이기 사용하는 언어의 표준 라이브러리에서 사용하는 명명규약을 익히기 모든 자료를 정규화해서 저장하기 같은 자료를 두가지 형태로 저장하지 않기 정규화는 프로그램이 자료를 입력받거나 계산하자마자 곧장 이루어져야 함 이상적으로는 자료를 표현하는 클래스의 생성자에서 정규화를 수행하거나 외부에서 자료를 입력받자마자 정규화를 하는게 좋음 코드와 데이터를 분리하기 정적 데이터 내용을 함수로 따로 만드는 행위를 하지 않기 자주 하는 실수 산술 오버플로 계산 과정에서 변수의 표현범위를 벗어나는 값을 사용 배열 범위 밖 원소에 접근 배열 크기를 정할때 계산을 신중하게 하기 0 시작범위와 1 시작범위 혼동하지않기 일관되지않은 범위표현방식 사용하기 [2,12] -&gt; 2~12 까지 자연수 표현, (2,12) -&gt; 3~11까지 자연수 표현 절충안으로 [lo, hi)를 사용함 Off-by-one 오류 반복문을 한번 더 많이 순회하거나 열린구간과 닫힌구간을 혼용해서 쓴 경우 많이 발생 입력이 주어졌을 때 코드가 어떻게 동작할지 되새겨보면서 프로그램 짜야함 컴파일러가 잡아주지 못하는 상수 오타 상수를 잘못 입력해서 생기는 오류 스택 오버플로 call stack이 오버플로해서 프로그램이 강제종료 되는것 재귀호출의 깊이가 너무 깊어지는게 대개 원인 스택 메모리가 적을때는 힙에 메모리를 할당하는게 좋음 다차원 배열 인덱스 순서 바꿔서 쓰기 특정 배열에 접근하는 위치를 하나로 통일하는것이 좋음 잘못된 비교 함수 작성 최소, 최대 예외 잘못 다루기 예외를 잘 처리해야 한다 연산자 우선순위 잘못 쓰기 시프트 연산자나 비트 단위 연산자들은 종종 헷갈림 너무 느린 입출력 방식 선택 gets()로 한꺼번에 받거나 cin으로 고수준 입력방식을 받을수도 있지만 느릴수 있기때문에 잘 선택해야함 변수 초기화 문제 이전 입력에 사용한 전역변수값을 초기화하지않고 그대로 사용함 디버깅과 테스팅 디버깅에 관하여 프로그래밍 대회용 소스코드는 대부분 짧기때문에 눈으로 하는것이 훨씬 빠름 재귀호출이나 중복 반복문을 자주 쓰면 디버깅하기에 힘듬 디버거 사용 대신 해야할 단계 작은 입력에 대해 제대로 실행되나 확인하기 오동작하는 가장 작은 입력을 먼저 찾아내면 디버깅하기 훨씬 용이함 단정문을 쓴다 주어진 조건이 거짓일때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문 프로그램의 계산 중간겨로가를 출력한다 중간과정 값들을 출력하고 자신이 예상하는 바와 맞아들어가는지 검사하기 디버거를 사용하는 좋은 예는 프로그램이 런타임 오류를 내고 종료하는 경우 테스트에 관하여 제출 전에 예제 입력을 만들어 가능한 많이 프로그램을 테스트하는것이 좋음 스캐폴딩 방법을 이용해 검증한다.(다른 코드를 개발할때 뼈대를 잡기위해 임시로 사용하는 코드) 변수 범위의 이해 산술 오버플로 어떤 식의 계산값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우 너무 큰 결과 프로그램이 출력해야할 결과가 너무 크면 안됨 너무 큰 중간값 계산식 도중에 값이 자료형의 크기를 넘는 경우가 있음 너무 큰 무한대값 무한대 값을 이용해 특수한값으로 사용할때는 무한대값들이 서로 더해지거나 곱해지는 경우가 없는지 잘 살펴봐야함. 오버플로 피해가기 자료형 큰거로 바꾸기 계산 순서 바꾸기 점화식 이용하기 자료형의 프로모션 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러가 자동으로 변환하는것을 프로모션이라 함 자동으로 형변환되는 숫자들에 대한 주의가 필요함","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"Book","slug":"Algorithm/Book","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/Book/"}],"tags":[{"name":"공부정리","slug":"공부정리","permalink":"https://taeyeonkim93.github.io/tags/공부정리/"},{"name":"종만북","slug":"종만북","permalink":"https://taeyeonkim93.github.io/tags/종만북/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 큰 수 만들기","slug":"Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-9","date":"2019-10-02T08:42:30.000Z","updated":"2019-10-03T12:21:23.628Z","comments":true,"path":"2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-9/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-9/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한 조건 number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다. 입출력 예 name k return “1924” 2 “94” “1231234” 3 “3234” “4177252841” 4 “775841” 조건 분석 나와야 하는 결과 1만들 수 있는 숫자 중 가장 큰 숫자의 [문자열] 문제를 풀기위해 주어진 데이터 1234567# 문제 해결에 필요한 데이터1. name 문자열2. 문자열에서 제거할 숫자의 갯수# 제한조건- 앞에서 뒤로 제거하는 방식 간단 알고리즘 12341. 만들 문자열 길이(전체길이 - k) 만큼의 배열리스트 내에서 최대값을 찾는다.2. answer에 최대값을 저장하고 최대값과 그 이전의 값들을 다 없앤다.3. 만들 문자열 길이 -1 을 하고 다시 리스트 내에서 최대값을 찾는다.4. 만들 문자열 길이가 0이면 반환한다. 나의 풀이사용언어 : Python 3 위와 같은 알고리즘으로 답은 나왔으나 테스트케이스 중 시간초과로 해결하지 못한 케이스가 있었다.찾아보니 스택으로 처리해야 한다는데 생각보다 간단해서 김이 빠졌다. 12345678910111213def solution(number, k): collected = [] for i, num in enumerate(number): while len(collected) &gt; 0 and collected[-1] &lt; num and k &gt; 0: collected.pop() k -= 1 if k == 0: collected += list(number[i:]) break collected.append(num) collected = collected[:-k] if k &gt; 0 else collected return ''.join(collected) 풀고 난 이후에 다른 사람들의 풀이를 봐도 매번 최대값을 찾는 풀이는 없었고 모두 스택으로 해결한것 같다. 123456789101112131415# 알고리즘1. numbers 의 값들을 순회한다. 1. 스택에 값이 있는지 확인한다. T : 제일 위 스택이 현재값보다 작은지 확인한다 T : k값이 0보다 큰지 확인한다. T : 스택의 값을 제거하고 k = k - 1 해준다. 2. k값이 0인지 확인한다. T : 남은 number 리스트의 값들을 모두 뒤에 추가하고 break 한다 3. 현재값보다 스택이 큰지 확인한다. T : 스택에 현재값을 넣는다2. numbers 에서 k값이 0이 안됐을 경우 ([5,4,3,2,1] , [2]) T : 스택에서 뽑아야 할 문자열의 갯수만큼 뽑아낸다. F : 스택 그대로 출력한다. 스택을 활용한 방법이 O(n)이라 매우 빠르다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"STACK","slug":"STACK","permalink":"https://taeyeonkim93.github.io/tags/STACK/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 조이스틱","slug":"Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-8","date":"2019-10-02T05:58:32.000Z","updated":"2019-10-03T12:21:23.620Z","comments":true,"path":"2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-8/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/02/Develop-Algorithm-programmers-2019-10-02-programmers-coding-test-8/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. 1234▲ - 다음 알파벳▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다. 1234- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.따라서 11번 이동시켜 &quot;JAZ&quot;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 제한 조건 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 name return “JEROEN” 56 “JAN” 23 조건 분석 나와야 하는 결과 1조이스틱 조작 횟수의 [최솟값] 문제를 풀기위해 주어진 데이터 12345678# 문제 해결에 필요한 데이터1. 조이스틱 조작방식에 대한 정보2. 만들어야하는 이름의 정보# 제한조건- 알파벳 대문자로만 이루어져 있음- 길이가 1~20까지 간단 알고리즘 11. Greedy 알고리즘을 사용해서 각 칸의 최적해를 찾아낸다. 나의 풀이사용언어 : Python 3 매 Case 마다 최적값이 달라지므로 Greedy 알고리즘을 사용해서 푸는 문제이다.그때그때 최적의 해를 찾아서 푸는 문제이므로 각 칸에서의 최적해를 구하는 방식을 찾는다. 왼쪽/오른쪽 중 어떤 조작을 해야 알파벳을 빨리 찾을 수 있는지 조건을 넣는다. A가 아닌 알파벳에 가장 가까운 방향으로 진행시킨다. 현재값이 A가 아니면 위아래 조작으로 넘어간다 현재값이 A일 경우 A가 아닌 값이 왼쪽으로 몇번째에 있는지 찾는다. 현재값이 A일 경우 A가 아닌 값이 오른쪽으로 몇번째에 있는지 찾는다. 두 값을 비교하고 이동횟수가 적은쪽으로 이동하고 A 갯수만큼 answer에 값을 추가한다. 위/아래 중 어떤 조작을 해야 알파벳을 빨리 찾을 수 있는지 조건을 넣는다. A~Z의 중간값인 N(위 13회, 아래 13회) 을 기준으로 나눈다. name 문자가 N보다 크거나 같으면 아래, 작으면 위 if문으로 들어간다. name 문자가 N보다 작을 때 아스키코드와 A의 아스키코드를 빼서 차 값을 answer에 넣는다 name 문자가 N보다 크거나 같을 때 아스키코드와 Z+1의 아스키코드를 빼서 차 값을 answer에 넣는다 12345678910111213141516171819202122232425262728293031323334def solution(name): answer = 0 name = list(name) base = [\"A\"] * len(name) idx = 0 while True: rIndex = 1 lIndex = 1 if name[idx] != \"A\": if name[idx] &lt; \"N\": answer += ord(name[idx]) - 65 else: answer += 91 - ord(name[idx]) name[idx]=\"A\" if name == base: break else: for i in range(1, len(name)): if name[idx + i] == \"A\": rIndex += 1 else: break if name[idx - i] == \"A\": lIndex += 1 else: break if rIndex &gt; lIndex: answer += lIndex idx -= lIndex else: answer += rIndex idx += rIndex return answer","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"GREEDY","slug":"GREEDY","permalink":"https://taeyeonkim93.github.io/tags/GREEDY/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 쇠막대기","slug":"Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-7","date":"2019-10-01T12:31:51.000Z","updated":"2019-10-03T12:21:23.615Z","comments":true,"path":"2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-7/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-7/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명문제 설명여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다. 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다. 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다. 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다. 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다. 이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다. 12(a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 &apos;()&apos;으로 표현합니다. 또한 모든 &apos;()&apos;는 반드시 레이저를 표현합니다.(b) 쇠막대기의 왼쪽 끝은 여는 괄호 &apos;(&apos;로, 오른쪽 끝은 닫힌 괄호 &apos;)&apos;로 표현됩니다. 위 예의 괄호 표현은 그림 위에 주어져 있습니다.쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다. 쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요. 제한 조건 arrangement의 길이는 최대 100,000입니다. arrangement의 여는 괄호와 닫는 괄호는 항상 쌍을 이룹니다. 입출력 예 arrangement return “()(((()())(())()))(())” 17 조건 분석 나와야 하는 결과 1잘린 쇠막대기 조각의 총 [개수] 문제를 풀기위해 주어진 데이터 12345678910# 문제 해결에 필요한 데이터1. 쇠막대기와 레이저의 배치를 표현한 arrangement# 제한조건- 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.- 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.- 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.- 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다. 간단 알고리즘 11. 레이저와 쇠막대기의 상관관계와 규칙을 찾아낸다. 나의 풀이사용언어 : Python 3 스택을 활용해서 푸는 문제이다.간단하게 규칙을 이용해서 공식을 찾아낼수도 있지만 (쇠막대기 갯수 + 쇠막대기 갯수 * 레이저 갯수 = 조각 갯수) 문제 의도에 맞게 스택으로 풀이한다. 알고리즘 isLaser 변수를 True 로 놓는다. 스택에 arrangement 의 내부 기호를 쌓는다. 만약 isLaser 가 True 인데 ) 기호가 들어올 경우 isLaser 을 False 로 바꾸고 가장 위에있던 ( 기호를 제거하고 스택에 남아있던 ( 기호만큼 쇠막대기 갯수를 증가시킨다. 만약 isLaser 가 False 인데 ) 기호가 들어올 경우 가장 위에있던 ( 기호를 제거하고 쇠막대기 갯수를 1만큼 증가시킨다 만약 isLaser 가 True 인데 ( 기호가 들어올 경우 스택에 쌓는다. 만약 isLaser 가 False 인데 ( 기호가 들어올 경우 isLaser 을 True 로 변경하고 그대로 스택에 쌓는다. 쌓인 쇠막대기 갯수를 return 한다. insert 와 pop 을 행할 시 결과값이 어떻게 바뀌는지 주의하면서 알고리즘을 짠다. 12345678910111213141516171819def solution(arrangement): answer = 0 isLaser = True steel_stack = [] for bracket in arrangement: if isLaser and bracket == \")\": isLaser = False steel_stack.pop() answer += len(steel_stack) elif not isLaser and bracket == \")\": answer += 1 steel_stack.pop() elif isLaser and bracket == \"(\": steel_stack.append(bracket) else: isLaser = True steel_stack.append(bracket) return answer 다른 풀이스택을 활용한 방법과 replace를 이용해 레이저를 다른 변수로 바꿔버린 풀이가 있다. 레이저 부분을 P로 치환해서 해결한 사례. 그외에는 스택을 이용해서 비슷하다. 1234567891011121314151617def solution(arrangement): answer = 0 stack = [] arrangement = arrangement.replace(\"()\",\"P\") for arr in arrangement: if arr == '(': stack.append(arr) answer +=1 elif arr == ')': stack.pop() else: answer += len(stack) return answer","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"STACK","slug":"STACK","permalink":"https://taeyeonkim93.github.io/tags/STACK/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 탑","slug":"Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-6","date":"2019-10-01T11:48:41.000Z","updated":"2019-12-04T05:07:05.349Z","comments":true,"path":"2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-6/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-6/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다. 예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다. 송신 탑(높이) 수신 탑(높이) 5(4) 4(7) 4(7) 2(9) 3(5) 2(9) 2(9) - 1(6) - 맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return 하도록 solution 함수를 작성해주세요. 제한 조건 heights는 길이 2 이상 100 이하인 정수 배열입니다. 모든 탑의 높이는 1 이상 100 이하입니다. 신호를 수신하는 탑이 없으면 0으로 표시합니다. 입출력 예 heights return [6,9,5,7,4] [0,0,2,2,4] [3,9,9,3,5,7,2] [0,0,0,3,3,3,6] [1,5,3,6,7,6,5] [0,0,2,0,0,5,6] 조건 분석 나와야 하는 결과 1각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열 문제를 풀기위해 주어진 데이터 1234567# 문제 해결에 필요한 데이터1. 탑의 길이# 제한조건1. 신호를 수신하는 탑이 없으면 0으로 표시 간단 알고리즘 121. 0번째 탑은 항상 수신하지 못한다.2. 현재 탑의 왼쪽이 현재 탑의 높이보다 높은지 체크하고 높으면 배열에 넣는다. 나의 풀이사용언어 : Python 3 간단하게 2중 for문을 사용해서 풀어주었다.이번 예제를 통해 for else문을 알게되었다. 123456789101112def solution(heights): answer = [] for i, num in enumerate(heights): for j in range(i, -1, -1): if heights[j] &gt; num: answer.append(j + 1) break else: answer.append(0) return answer 다른 풀이1. 2중 for문0을 먼저 선언해준뒤에 비교했다는 사실을 빼면 차이 없음. 12345678def solution(h): ans = [0] * len(h) for i in range(len(h)-1, 0, -1): for j in range(i-1, -1, -1): if h[i] &lt; h[j]: ans[i] = j+1 break return ans 2. 스택을 사용한 방법문제 의도가 스택인것같아 한번 더 봤다.기본적으로는 비슷하지만 pop 을 이용해서 공간을 덜 먹는다는게 장점인듯 스택을 만들어주고 LIFO 법칙에 따라 가장 마지막 배열을 현재의 탑으로 잡고 배열에서 없앤다. 1234def solution(heights): responses = [] while heights: top = heights.pop() 현재의 탑의 길이보다 -1부터 내려가면서 탐색한다. 있으면 answer에 append한다.123456789 for i in range(len(heights) - 1, -1, -1): if top &lt; heights[i]: responses.append(i + 1) break else: responses.append(0)return responses[::-1]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"STACK","slug":"STACK","permalink":"https://taeyeonkim93.github.io/tags/STACK/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 124 나라의 숫자","slug":"Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-5","date":"2019-10-01T07:29:56.000Z","updated":"2019-10-01T10:18:55.623Z","comments":true,"path":"2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-5/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/01/Develop-Algorithm-programmers-2019-10-01-programmers-coding-test-5/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124나라 10진법 124나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 제한 조건 n은 500,000,000이하의 자연수 입니다. 입출력 예 n result 1 1 2 2 3 4 4 11 조건 분석 나와야 하는 결과 1자연수 n을 124나라에서 사용하는 숫자로 변환한 [값] 문제를 풀기위해 주어진 데이터 12345# 문제 해결에 필요한 데이터1. 124 나라에서 사용된 10진법 데이터# 제한조건 간단 알고리즘 11. 124나라에서 10진법을 변환하는 규칙을 찾는다. 나의 풀이사용언어 : Python 3 주먹구구로 규칙을 찾아서 풀었다.머리가 문제인가 경험이 문제인가.. 1,2,4 총 3개의 값으로 계속 순환되고 있으므로 10진법 124나라 몫 0 x 0 1 1 0 2 2 0 3 4 1 4 11 1 5 12 1 6 14 2 7 21 2 8 22 2 9 24 3 10 41 3 11 42 3 12 44 4 13 111 4 14 112 4 15 114 5 몫이 0일때까지 3으로 나눈다. 이때 3으로 나누기가 가능한 만큼 자릿수를 추가한다. 몫-1이 0이면 자릿수 1개몫-1이 1~3이면 자릿수 2개몫-1이 4~8이면 자릿수 3개 인 규칙을 발견할수 있다. 알고리즘1234def solution(n): answer = '' pattern = [4, 1, 2] chk = n 123456789101112while True: answer = str(pattern[(chk % 3)]) + answer # 나누고 남은 나머지값이 들어간다. chk는 1,2,0 순으로 순환된다. chk = int((chk - 1)//3) # 자릿수를 파악한다. n = int(n // 3) # 나머지를 찾기위한 n의 값을 계산한다. if chk == 0: break # 더이상 계산할 자릿수가 없을때 breakreturn answer 다른 풀이n에서 1을 뺄 경우 쉬운 규칙으로 변하는 부분을 잘 캐치하였다.chk 라는 변수를 따로 선언해서 삽질하지 않은 부분이 가장 크게 다른 부분. 12345678910def solution(n): num = ['1', '2', '4'] answer = \"\" while n &gt; 0: n -= 1 answer = num[n % 3] + answer n = n // 3 return answer","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 기능개발","slug":"Develop-Algorithm-programmers-2019-09-24-programmers-coding-test-4","date":"2019-09-24T10:20:02.000Z","updated":"2019-10-01T07:02:30.511Z","comments":true,"path":"2019/09/24/Develop-Algorithm-programmers-2019-09-24-programmers-coding-test-4/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/24/Develop-Algorithm-programmers-2019-09-24-programmers-coding-test-4/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 조건 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93,30,55] [1,30,5] [2,1] 조건 분석 나와야 하는 결과 1특정 순서로 이루어진, 작업이 끝나서 배포한 작업의 [갯수] 문제를 풀기위해 주어진 데이터 12345678# 문제 해결에 필요한 데이터1. 작업의 배포순서가 적힌 리스트2. 작업의 개발 속도# 제한조건1. 배포는 하루에 한번만 가능 간단 알고리즘 1231. 작업 리스트를 큐에 집어넣는다2. 각 작업별 스피드를 작업 진척도에 더하다가 큐에서 제일 처음에 넣은 작업이 완료됐을경우 완료된 작업을 빼내고 카운트한다. 풀이사용언어 : Python 3 전형적인 Queue의 가장 쉬운 예제로 볼 수 있다.작업이 모두 완료됐을 때의 날짜를 가지고 끝난 작업의 개수를 계산하는 방법도 있다 Queue를 사용하는 방법 작업 리스트를 큐에 집어넣는다 (이미 주어진 progresses 배열이 Queue 자료구조로 되어있는 상태) 12def solution(progresses, speeds): answer = [] 각 작업별 진척도를 작업에 더한다. 12345while progresses: result = 0 if progresses[0] &lt; 100: for idx, speed in enumerate(speeds): progresses[idx] += speed 가장 앞의 작업의 진척도가 100이상일 경우, 작업의 진척도가 100인 자료들을 모두 꺼낸다. 1234567 else: while progresses and progresses[0] &gt;= 100: progresses.pop(0) speeds.pop(0) result += 1 answer.append(result)return answer 완료된 작업의 소요시간으로 계산하는 방법 마지막 작업이 걸린 소요시간을 계산한다. 12345678def solution(progresses, speeds): Q = [] for p, s in zip(progresses, speeds): # p : progresses, s : speeds if len(Q) == 0 or Q[-1][0] &lt; -((p - 100) // s): # 배열이 하나도 없거나, 현재 작업이 마지막 작업보다 소요시간이 더 길 경우 Q.append([-((p - 100) // s), 1]) # 큐에 추가한다. 현재 작업이 마지막 작업보다 소요시간이 적은 작업일 경우, 마지막 작업이 배포될 날의 개수에 추가한다. 1234 else: # 현재 작업이 마지막 작업보다 소요시간이 더 작을경우 Q[-1][1] += 1return [q[1] for q in Q]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"QUEUE","slug":"QUEUE","permalink":"https://taeyeonkim93.github.io/tags/QUEUE/"}]},{"title":"[파이썬] 이슈 정리","slug":"Develop-Programming-python-2019-09-24-python-issue","date":"2019-09-24T06:18:23.000Z","updated":"2019-12-03T08:48:37.504Z","comments":true,"path":"2019/09/24/Develop-Programming-python-2019-09-24-python-issue/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/24/Develop-Programming-python-2019-09-24-python-issue/","excerpt":"","text":"목차foreach로 배열값을 꺼낼때문자열 정렬(sort) 방법문자열 분할 시 주의할점파이썬 산술연산자리스트 내포(List comprehension)리스트 out of range를 피하는 방법반복문 중간에 break 여부 판단하기문자열 내의 문자를 index 기반으로 다른 문자로 치환하기배열 내 중복이 없게 만들기 1. foreach로 배열값을 꺼낼때 동작을 index 기반으로 하기때문에 copy를 해주거나 while로 돌리는게 편하다.12345678lost = [1,3]reserve = [1,3,5]for res in reserve if res in lost: lost.remove(res) reserve.remove(res) # 1을 비교후, 3이 아닌 5로 점프한다. 해결방법 1234lost = [1,3]reserve = [1,3,5]_reserve = [r for r in reserve if r not in lost]_lost = [l for l in lost if l not in reserve] 2. 문자열 정렬(sort) 방법 list.sort() 혹은 sorted(list) 가 있다. sort는 리스트 자체를 정렬하고, sorted는 정렬된 리스트를 반환한다. 3. 문자열 분할 시 주의할점 list[1:3]은 list[2], list[3] 값을 반환한다. 4. 파이썬 산술연산자 Operator Description Example % 나머지 b % a = 0 ** 제곱 a ** c = 1000 // 몫 a // c = 3 5. 리스트 내포(List comprehension)1result = [num * 3 for num in a] 6. 리스트 out of range를 피하는 방법조건문 if 앞에 len(list)==0 or [조건] 을 붙여 내용이 없을때에도 진행 가능하게 한다. 1if len(Q)==0 or Q[-1][0]&lt;-((p-100)//s): 7. 반복문 중간에 break 여부 판단하기for else 문을 사용하면 반복중에 break 되었는지 아닌지 판단할 수 있다. 중간에 break 가 되었다면 else 문에 들어가지 않는다. 123456data = [1, 3, 6, 13, 3]for i in data: if i &gt; 10: breakelse: print('10 보다 큰 수는 없습니다.') 8. 문자열 내의 문자를 index 기반으로 다른 문자로 치환하기파이썬은 문자열 내의 문자를 index 기반으로 치환하는 기능을 지원하지 않는다. 문자열을 list로 만들고 문자열을 치환한뒤에 다시 ‘’.join(name)으로 문자열로 변환한다.list(name)&#39;&#39;.join(name) 9. 배열 내 중복이 없게 만들기list에 11이라는 값을 3번 넣으면 [11,11,11]이 된다. 이때 [11] 만 남기고싶을때는 집합 자료형을 사용하면 된다. 1s1 = set([1,2,3,4,4]) 12실행결과&#123;1,2,3,4&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"https://taeyeonkim93.github.io/categories/Programming/Python/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"}]},{"title":"[Python] 파이썬 함수 정리","slug":"Develop-Programming-python-2019-09-18-python-function","date":"2019-09-18T11:59:02.000Z","updated":"2020-01-05T09:51:23.121Z","comments":true,"path":"2019/09/18/Develop-Programming-python-2019-09-18-python-function/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/18/Develop-Programming-python-2019-09-18-python-function/","excerpt":"","text":"그때그때 모르는 함수 있으면 정리해서 올리는 용도 목차enumeratemapQueueIndexZipSortHeapPermutationDeque 파이썬 함수 정리1. enumerate for문에서 현재 반복이 몇번째 반복인지 확인할 때 사용한다. 주로 배열 내부를 순회하는 반복자를 선언하고 배열에서 연산자를 통해 값을 출력하는 경우 1234arr = [1,2,3]for i in range(0,len(arr)): print(i, arr[i]) 1234실행결과0 11 22 3 와 같이 사용할때, 간단히 1234arr = [1,2,3]for i,v in enumerate(arr): print(i, v) 1234실행결과0 11 22 3 이와같이 사용할 수 있다. 2. mapmapmap(f, iterable)은 함수(f)와 반복 가능한(iterable) 자료형을 입력으로 받는다.map은 입력받은 자료형의 각 요소를 함수 f가 수행한 결과를 묶어서 돌려주는 함수이다. 123def two_times(x): return x*2list(map(two_times, [1, 2, 3, 4])) 12실행결과[2, 4, 6, 8] lambda를 활용하면 더 간략하다. 1list(map(lambda x: x * 2, [1, 2, 3, 4])) 3. Queue기본적인 Queue 모듈 123456789101112import queuedata = [3]q = queue.Queue() # 큐 선언q.put_nowait(data) # 데이터 삽입print(q.queue[0]) # pop 없이 데이터 확인q.get_nowait() # 데이터 확인print(q.qsize()) # 큐 크기 확인 4. Index위치 반환(index)index(x) 함수는 리스트에 x 값이 있으면 x의 위치 값을 돌려준다. 12a = [1,2,3]a.index(3) 12실행결과2 5. Zip동일한 갯수로 이루어진 자료형을 묶어주는 역할을 한다. 1list(zip([1,2,3],[4,5,6],[7,8,9])) 12실행결과 [(1, 4, 7), (2, 5, 8), (3, 6, 9)] 사용처 : key/value 값이 각각 배열로 있을때, dictionary 를 사용하지 않아도 key-value 구조를 이용하도록 해준다. for문에서 사용 시 12345a = [1, 2, 3]b = [4, 5, 6]for p, s in zip(a, b): print(p,s) 1234실행결과1 42 53 6 6. Sort리스트 내 자료들을 특정 기준으로 정렬해준다. (default : 오름차순) key, reverse 를 매개변수로 갖고있다. 매개변수 key 사용법 다중 조건으로 정렬해야 할 경우 123numbers = [(1,2),(4,3),(4,5)]# [0]번째 배열로 오름차순 비교후 [1]번째 배열로 내림차순으로 비교한다.numbers.sort(key=lambda x : (x[0],-x[1])) 12실행결과[(1, 2), (4, 5), (4, 3)] 1차원 배열 내 특정 조건으로 배열해야 할 경우 functools라는 모듈을 가져와서 com_to_key 라는 함수를 사용해야 한다.(python 3 기준) 123456import functoolsnumbers = [3, 30, 34, 5, 9]numbers = list(map(str, numbers))numbers.sort(key=functools.cmp_to_key(lambda x, y: int(x + y) - int(y + x)),reverse=True)# 문자열로 변환했을때 두 배열을 더해서 나온 문자열값이 큰 값을 앞으로 배치한다. 12실행결과[&apos;9&apos;, &apos;5&apos;, &apos;34&apos;, &apos;3&apos;, &apos;30&apos;] 매개변수 reverse 사용법 12numbers = [1,3,2,5,6]numbers.sort(reverse=True) 12실행결과[6, 5, 3, 2, 1] 7. Heap파이썬 내 힙 자료구조를 사용법heapq 라는 내장 모듈을 사용한다.힙 자료구조를 사용할땐 보통 최소값만 있으면 다른건 아무것도 필요없을때 가장 빠른 속도를 위해서 사용한다.push와 pop의 경우에는 매번 힙 구조로 정리까지 해주니 굳이 heapify 작업이 필요없다. 12345import heapqheapq.heapify(list) # 리스트를 힙 구조로 바꿈 / 최소값이 0번째 indexheapq.heappush(list, data) # 힙 data 입력list_min = heapq.heappop(list) # 힙 0번째 index 추출 8. Permutation순열을 외부 모듈을 이용해서 구현한다. 12345import itertoolspool = ['A', 'B', 'C']print(list(map(''.join, itertools.permutations(pool)))) # 3개의 원소로 수열 만들기print(list(map(''.join, itertools.permutations(pool, 2)))) # 2개의 원소로 수열 만들기 9. Deque양방향 큐 Deque 를 구현한다. 1234567891011121314151617181920212223242526272829303132333435363738import collections d = collections.deque([10, 20, 30, 40, 50]) d.append(60) # 오른쪽에 추가 deque([10, 20, 30, 40, 50, 60]) d.appendleft(0) # 왼쪽에 추가 deque([0, 10, 20, 30, 40, 50, 60]) d.extend([70, 80]) # 입력값을 순환하면서 오른쪽에 추가(append) deque([0, 10, 20, 30, 40, 50, 60, 70, 80]) d.extendleft([-10, -20, -30]) # 입력값을 순환하면서 왼쪽에 추가(appendleft)# deque([-30, -20, -10, 0, 10, 20, 30, 40, 50, 60, 70, 80]) d.remove(0) # 값 삭제# deque([-30, -20, -10, 10, 20, 30, 40, 50, 60, 70, 80]) maxValue = d.pop() # 오른쪽의 끝값 가져오면서 deque에서 제거# maxValue: 80# deque([-30, -20, -10, 10, 20, 30, 40, 50, 60, 70]) minValue = d.popleft() # 왼쪽의 끝값 가져오면서 deque에서 제거# minValue: -30# deque([-20, -10, 10, 20, 30, 40, 50, 60, 70]) d = collections.deque(range(5)) # 값 회전(rotating)# Deque: deque([0, 1, 2, 3, 4]) d.rotate(1)# Deque.rotate(1): deque([4, 0, 1, 2, 3]) d.rotate(1)# Deque.rotate(1): deque([3, 4, 0, 1, 2]) d.rotate(-1)# Deque.rotate(-1): deque([4, 0, 1, 2, 3]) d.rotate(-1)# Deque.rotate(-1): deque([0, 1, 2, 3, 4])","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"https://taeyeonkim93.github.io/categories/Programming/Python/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"PYTHON FUNCTION","slug":"PYTHON-FUNCTION","permalink":"https://taeyeonkim93.github.io/tags/PYTHON-FUNCTION/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 모의고사","slug":"Develop-Algorithm-programmers-2019-09-18-programmers-coding-test-3","date":"2019-09-18T07:06:05.000Z","updated":"2019-10-03T12:21:23.612Z","comments":true,"path":"2019/09/18/Develop-Algorithm-programmers-2019-09-18-programmers-coding-test-3/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/18/Develop-Algorithm-programmers-2019-09-18-programmers-coding-test-3/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 조건 분석 나와야 하는 결과 12가장 높은 점수를 받은 [사람 번호]동점일경우 오름차순 정렬 문제를 풀기위해 주어진 데이터 1234567891011121314# 문제 해결에 필요한 데이터1. 3명의 수포자의 찍는 방식 - 1번 : 1~5까지 반복 - 2번 : 홀수번째는 2, 짝수번째는 2를 제외한 1~5 반복 - 3번 : 3,1,2,4,5를 각 2번씩 반복2. 정답 데이터# 제한조건1. 최대 문제 갯수(1만문제)2. 문제 정답 제한 (1~5)3. 동점자가 있을경우 오름차순 정렬 간단 알고리즘 11. 정답마다 각 인원의 배열을 비교한다 풀이사용언어 : Python 3 answers 리스트를 수포자의 답과 비교해야되는데 answers의 값이 무작위로 들어있으므로 완전탐색으로 풀어야 한다. 완전탐색이 카테고리인 문제를 푸는 방법은 Brute Force (무작위 대입) DFS (깊이 우선 탐색) BFS (너비 우선 탐색) 백트래킹 정도가 있다. 자세한건 타 포스팅 참조 완전탐색 알고리즘 정리 변수자체가 한개밖에 없으므로 단순하게 무작위대입으로 푸는것이 좋다. 1~3번까지의 반복되는 숫자의 패턴자체가 정해져있으므로 먼저 패턴을 정의한다. 1234def solution(answers): pattern1 = [1,2,3,4,5] pattern2 = [2,1,2,3,2,4,2,5] pattern3 = [3,3,1,1,2,2,4,4,5,5] 그 뒤는 알고리즘에 따라 변수를 정의한다. answers[0]과 parttern1~3의 첫번째 배열을 비교한다. 같을경우 각 패턴에 1점씩 부여한다. 위 과정을 반복한다. 끝나고 가장 높은 배열을 출력한다. 123# 각 패턴별 점수판 변수 선언 score = [0, 0, 0] result = [] 123456789# answers[0]과 parttern1~3의 첫번째 배열을 비교한다. for idx, answer in enumerate(answers): if answer == pattern1[idx%len(pattern1)]:# 길이만큼 순환한다 score[0] += 1 if answer == pattern2[idx%len(pattern2)]: score[1] += 1 if answer == pattern3[idx%len(pattern3)]: score[2] += 1 123456for idx, s in enumerate(score): if s == max(score): # 최대값 결과값 배열에 넣는다. result.append(idx+1)return result","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"완전탐색","slug":"완전탐색","permalink":"https://taeyeonkim93.github.io/tags/완전탐색/"},{"name":"BRUTE FORCE","slug":"BRUTE-FORCE","permalink":"https://taeyeonkim93.github.io/tags/BRUTE-FORCE/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 완주하지 못한 선수","slug":"Develop-Algorithm-programmers-2019-09-17-programmers-coding-test-2","date":"2019-09-17T12:07:30.000Z","updated":"2019-09-24T08:29:43.875Z","comments":true,"path":"2019/09/17/Develop-Algorithm-programmers-2019-09-17-programmers-coding-test-2/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/Develop-Algorithm-programmers-2019-09-17-programmers-coding-test-2/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때,완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한 조건 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [leo, kiki, eden] [eden, kiki] leo [marina, josipa, nikola, vinko, filipa] [josipa, filipa, marina, nikola] vinko [mislav, stanko, mislav, ana] [stanko, ana, mislav] mislav 조건 분석 나와야 하는 결과 1완주하지 못한 선수의 [이름] 문제를 풀기위해 주어진 데이터 123456789101112# 문제 해결에 필요한 데이터1. 이름 - 참여한 선수들의 이름 리스트 (completion arr) - 완주한 선수들의 이름 리스트 (participant arr)2. 완주하지 못한 인원 수 (1명)# 제한조건1. 전체 배열 갯수 (1~10만)2. 이름 길이 (max 20 byte)3. 참가자의 동명이인 여부 (Yes) 간단 알고리즘 11. 완주한 선수들의 리스트 중에서 참여한 선수들을 제거하고 남은 선수를 반환한다. 풀이사용언어 : Python 3 알고리즘은 간결하지만 2가지의 풀이방법이 있다. 문자열을 직접 비교하는 방법 해시 테이블을 이용한 방법 문자열을 직접 비교하면 for문을 2개 활용해서 O(n^2)의 시간복잡도로 구할 수 있다.다만 문제자체에서 O(n)의 시간복잡도가 나오지 않으면 문제풀이로 인정해주지 않기 때문에 해쉬를 이용한다. 해쉬(Hash)에 대한 자세한 설명은 타 포스팅 참조 해시 알고리즘 정리 세부 알고리즘은 참여한 선수들의 이름을 특정 해쉬 함수를 통해 해쉬값으로 만든다. “색인을 통한 검색”을 위해 위의해쉬값을 색인(index)으로 하는 해쉬 테이블을 만든다. 완주한 선수들의 이름을 해쉬값으로 만들어서 참여한 선수들의해쉬 테이블에서 제거한다. 마지막에 남은 해쉬 테이블의 리스트를 반환한다. 파이썬에서는 딕셔너리라는 key-value 매핑구조를 지원한다.이때 key를 해쉬함수를 통해 나온값을 색인으로 쓰는 해쉬 테이블을 만들어주므로 편하게 사용하면 되겠다.직접 해쉬테이블을 만들고싶으면 hash()를 사용해 만들어주면 된다. 123456789101112131415161718def solution(participant, completion): dic = &#123;&#125; # 딕셔너리 선언 for parName in participant: dic[parName] = 0 # key는 참여자 이름, value는 0으로 통일하는 dic 해쉬 테이블을 만든다. for comName in completion: if comName in dic: del dic[comName] # 해쉬 테이블에서 완주자의 이름을 가진 key를 전부 제거 return list(dic.keys())[0] # 마지막 남은 key 반환participant = [\"leo\", \"kiki\", \"eden\"]completion = [\"eden\", \"kiki\"]print(solution(participant,completion)) 12실행결과leo 가장 기본적인 문제는 해결되었으니 제한조건을 살펴볼 차례이다.전체 배열갯수나 이름길이는 문제가 없지만 동명이인일때가 문제다.테스트값을participant = [&quot;leo&quot;,&quot;leo&quot;, &quot;kiki&quot;, &quot;eden&quot;]completion = [&quot;leo&quot;,&quot;eden&quot;, &quot;kiki&quot;] 이렇게 변경하면 딕셔너리 구조상 leo라는 키값이 2개가 아닌 1개로 저장된다.이때 leo라는 키를 제거하면 결국 미완주자가 0명이 된다. 같은 key를 저장할때는 value값에 값을 누적시키는 방법으로 해결이 가능하다. 12345678910111213141516171819202122def solution(participant, completion): dic = &#123;&#125; for parName in participant: if parName in dic: # 딕셔너리 내부에 동명이인이 있으면 dic[parName] = dic.get(parName) + 1 # value에 1을 추가 else: dic[parName] = 1 # 동명이인이 없으면 1로 통일 for comName in completion: if comName in dic: dic[comName] = dic.get(comName) -1 # 완주한 사람은 value값에 -1 if dic[comName] == 0: del dic[comName] # 0인 완주자는 테이블에서 제외 return list(dic.keys())[0] # value값이 1인 참여자만 남아서 반환participant = [\"leo\",\"leo\", \"kiki\", \"eden\"]completion = [\"leo\",\"eden\", \"kiki\"]print(solution(participant,completion)) 12실행결과leo 이외에 참여자와 완주자의 리스트를 알파벳순으로 정렬해 비교하는 도중 같지않으면 반환하는 방법과 Counter 클래스를 사용하는 방법도 있다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"HASH","slug":"HASH","permalink":"https://taeyeonkim93.github.io/tags/HASH/"},{"name":"HASH TABLE","slug":"HASH-TABLE","permalink":"https://taeyeonkim93.github.io/tags/HASH-TABLE/"}]},{"title":"[자료구조] HASH 정리","slug":"Develop-CS-2019-09-17-hash-algorithm","date":"2019-09-17T11:14:21.000Z","updated":"2019-12-03T09:07:10.532Z","comments":true,"path":"2019/09/17/Develop-CS-2019-09-17-hash-algorithm/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/Develop-CS-2019-09-17-hash-algorithm/","excerpt":"","text":"HASH특정한 값을, 수많은 값들 사이에서 찾아야 할 때 사용한다. 물론 탐색은 여러가지 방법이 있다. 그중에서 HASH를 사용하는 장단점을 추려보면 장점 평균 case에서 O(1)의 시간복잡도를 가진다 단점 메모리 영역을 일정부분 차지한다 충돌이 발생할 수 있다. 보안적 측면이나 Collision 및 세부내용은 타 블로그를 참조하고여기서는 탐색 알고리즘 문제를 풀기위한 기본개념만 잡는다. HASH란?HASH 란 용어 자체는 [고기와 감자를 잘게 다져 섞어 요리하여 따뜻하게 차려 낸 것] 이란 영단어 뜻에서 시작하면 된다. 어떤 내용물들을 잘 섞어서 특정한 형태로 만든다는 것이다. 짜장면을 두그릇 사서 &#39;똑같은 위치와 힘으로&#39; &#39;왼손으로 5번&#39; &#39;오른손으로 6번&#39; 비비면 두그릇은 완벽히 똑같은 짜장면이 나온다.이때 오른손으로 8번을 비비면 다른 짜장면의 모양새가 된다. 면+소스(입력값) 를 같은 방법으로 섞으면(해시함수) 완전히 같은 짜장면(해시값)이 된다. 문제가 [가장 맛있는 짜장면] 을 탐색하는 것이라면, 면과 소스를 특정한 방법으로(5번,6번) 섞기만 하면 된다. 굳이 왼손으로 1번~5번, 오른손으로 1번~6번을 전부 다 탐색해볼 필요가 없게 된것이다. HASH 사용법HASH 자료구조는 몇가지 용어가 나온다. Hash Function(해시함수) Hash Table(해시 테이블) Hash Value, Hash Code, Hash Checksum… (해시값) 우리가 알고싶은 탐색은 해시테이블을 보면 된다. name phone number John Smith 521-1234 Lisa Smith 521-8976 Sandra Dee 521-9655 이런 입력값을 주고 “Sandra Dee”의 전화번호를 찾으라고 하면, Hash를 사용하지 않을경우 “John Smith”부터 하나하나 찾아가는수밖에 없다. 하지만 이런식으로 테이블을 만들어두면 keys(입력값)이 hash function(해시함수)를 통해 Hash Value(해시값)으로 변환되어 해시값의index(색인) 을 가진 해시테이블이 완성된다. 해시테이블 index(Hash Value) Data 01 (Lisa Smith, 521-8976) 02 (John Smith, 521-1234) … … 14 (Sandra Dee, 521-9655) 이렇게 모두 저장해두면 나중에 ‘Sandra Dee’ 라는 입력값을 찾기위해서는 Sandra Dee를 해시함수에 넣는다 Sandra Dee가 14인 해시값으로 변환된다. 0번주소값에서 14만큼 떨어진 주소로 바로 넘어가서 값을 가져온다 결국 탐색을 단 한번에 끝낼수 있으므로 시간복잡도는 O(1)이다. 예시 : [프로그래머스] 코딩테스트 풀이 - 완주하지 못한 선수","categories":[{"name":"CS","slug":"CS","permalink":"https://taeyeonkim93.github.io/categories/CS/"},{"name":"자료구조","slug":"CS/자료구조","permalink":"https://taeyeonkim93.github.io/categories/CS/자료구조/"}],"tags":[{"name":"DATA STRUCTURE","slug":"DATA-STRUCTURE","permalink":"https://taeyeonkim93.github.io/tags/DATA-STRUCTURE/"},{"name":"HASH","slug":"HASH","permalink":"https://taeyeonkim93.github.io/tags/HASH/"},{"name":"HASH TABLE","slug":"HASH-TABLE","permalink":"https://taeyeonkim93.github.io/tags/HASH-TABLE/"}]},{"title":"[Kotlin] 코틀린 날짜 함수 정리","slug":"Develop-Programming-kotlin-2019-09-17-kotlin-calendar-function","date":"2019-09-17T06:59:06.000Z","updated":"2019-09-18T09:56:55.577Z","comments":true,"path":"2019/09/17/Develop-Programming-kotlin-2019-09-17-kotlin-calendar-function/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/Develop-Programming-kotlin-2019-09-17-kotlin-calendar-function/","excerpt":"","text":"코틀린 날짜 함수프로그래머스 문제를 풀다가 java에서는 Date가 Deprecate 되고 Calendar를 사용한다고 해서 정리해봤다. 전체적으로 정리하기보단 실제로 사용하는 부분에만 중점을 뒀다. 전체 Document는 이곳 참조 java에서는 날짜를 계산하는 내장라이브러리로 Calendar클래스나 java.time 패키지를 주로 사용하지만 일단 사용하기 편한 Calendar 클래스를 보면 Calendar 인스턴스 생성1val calendar:Calendar = Calendar.getInstance() Calendar 클래스는 추상클래스이기 때문에 객체를 직접 생성할 수 없고 getInstance() 함수를 통해 완전히 구현된 클래스의 인스턴스를 얻어야 한다.이 인스턴스를 통해 Calendar 클래스 내부 함수들을 사용할 수 있다. 인스턴스의 내부에는 현재 날짜와 시간정보가 들어있다. 현재 날짜정보 가져오기123456val year = calendar.get(Calendar.YEAR) val mon = calendar.get(Calendar.MONTH) val day = calendar.get(Calendar.DAY_OF_MONTH) val hour = calendar.get(Calendar.HOUR_OF_DAY) val min = calendar.get(Calendar.MINUTE) val sec = calendar.get(Calendar.SECOND) 주의할 점은 calendar.get(Calendar.MONTH) 로 가져오는 월이 1~12이 아니라 0~11 이다.그래서 0이 1월, 11이 12월을 의미한다. 날짜 설정하기 1calendar.set(year,month,date,hour,minute,second) 날짜 일수 계산하기 12calendar.timeInMillis //설정된 시간을 밀리초로 변경 시간을 밀리초로 변환시킨 후SimpleDateFormat()함수를 통해 원하는 Date Format으로 변경한다.자세한 포맷은 정식문서 참조 결과값이 한글로 나올경우 뒤에 Locale.ENGLISH을 붙여 영어로 만든다. 12SimpleDateFormat(\"yyyy.MM.dd G 'at' HH:mm:ss z\",Locale.ENGLISH).format(calendar.timeInMillis) //2001.07.04 AD at 12:08:56 PDT","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"KOTLIN","slug":"KOTLIN","permalink":"https://taeyeonkim93.github.io/tags/KOTLIN/"},{"name":"CALENDAR","slug":"CALENDAR","permalink":"https://taeyeonkim93.github.io/tags/CALENDAR/"},{"name":"LIBRARY","slug":"LIBRARY","permalink":"https://taeyeonkim93.github.io/tags/LIBRARY/"},{"name":"JAVA","slug":"JAVA","permalink":"https://taeyeonkim93.github.io/tags/JAVA/"},{"name":"날짜 함수","slug":"날짜-함수","permalink":"https://taeyeonkim93.github.io/tags/날짜-함수/"},{"name":"내장라이브러리","slug":"내장라이브러리","permalink":"https://taeyeonkim93.github.io/tags/내장라이브러리/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 2016년","slug":"Develop-Algorithm-programmers-2019-09-17-programmers-coding-test-1","date":"2019-09-17T06:34:03.000Z","updated":"2019-09-18T09:55:14.765Z","comments":true,"path":"2019/09/17/Develop-Algorithm-programmers-2019-09-17-programmers-coding-test-1/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/Develop-Algorithm-programmers-2019-09-17-programmers-coding-test-1/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요?두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요.요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT입니다.예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요. 제한 조건2016년은 윤년입니다.2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다) 입출력 예 a b result 5 24 TUE 풀이사용언어 : Kotlin 날짜 구하는 함수를 직접 만들경우 2016년의 모든 달(1월~12월)의 마지막 날을 적는다. 12val month = listOf(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) // 1월~12월의 전체 날짜 수 2016년 1월 1일이 무슨일인지 알아낸다. (금요일) 금요일부터 목요일까지 영어로 적혀있는 배열을 만든다. 12val dayOfWeek = listOf(\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\")// 1월 1일부터 반복되는 요일 영어 1월 1일이라면 (0 + 1 - 1) % 7 = 0 -&gt; FRI3월 6일이라면 (31 + 29 + 6 - 1) % 7 = 2 -&gt; SUN숫자로 계산한 후 dayOfWeek에서 대응하는 날짜를 찾아 변환한다.123456for (i in 0 until a - 1) &#123; total += month[i] // 날짜 계산식&#125; total += (b-1) return dayOfWeek[total%7] // 요일 산출 내장 라이브러리를 사용해서 만들경우 월, 일을 날짜 변수에 넣는다 12val calendar = Calendar.getInstance() calendar.set(2016, a-1, b) 현재 날짜를 밀리초 단위로 변경한 후, 반환값이 날짜 포맷으로 출력되는 함수 SimpleDateFormat을 활용해서 영어단어로 출력한다. 12return SimpleDateFormat(\"EEE\", Locale.ENGLISH).format(calendar.timeInMillis).toUpperCase() // 밀리초단위로 변경 후 SimpleDateFormat으로 요일 출력 해당 내장함수에 대한 설명은 타 포스팅 참조 Kotlin 날짜함수 정리 전체 답안 12345678910import java.text.SimpleDateFormat import java.util.* class Solution &#123; fun solution(a: Int, b: Int): String &#123; val calendar = Calendar.getInstance() calendar.set(2016, a-1, b) return SimpleDateFormat(\"EEE\", Locale.ENGLISH).format(calendar.timeInMillis).toUpperCase() &#125; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"DATE LIBRARY","slug":"DATE-LIBRARY","permalink":"https://taeyeonkim93.github.io/tags/DATE-LIBRARY/"},{"name":"KOTLIN","slug":"KOTLIN","permalink":"https://taeyeonkim93.github.io/tags/KOTLIN/"}]},{"title":"[VCS] Github에서 실수로 Push한 Commit 삭제하기","slug":"Develop-etc-2019-09-17-github-commit-remove","date":"2019-09-17T06:18:50.000Z","updated":"2019-09-18T11:07:47.687Z","comments":true,"path":"2019/09/17/Develop-etc-2019-09-17-github-commit-remove/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/Develop-etc-2019-09-17-github-commit-remove/","excerpt":"","text":"Git 작업 시 오타가 났거나 올라가면 안되는 Commit을 Push 했을경우 어떻게 삭제해야 할까? - 지워야 하는 Commit 잘못된 커밋이 몇개나 있으면 가독성을 해치게 된다. 깔끔하게 삭제하고 새롭게 commit 내용을 추가해보자. 지워야하는 해당 폴더에 들어가서 git log로 내역이 잘 나오는지 확인하자. * Hexo를 사용하는 유저는 .deploy_git 폴더에서 작업해야함 - git log 화면 지워야할 내용을 확인했다면 삭제 명령어를 입력하자. 1git reset --hard HEAD~[지울 개수] reset은 현재 진행중인 최신 commit에서부터 아래로 [지울 개수] 만큼 삭제한다. commit 시점 되돌리기 관련 내용은 타 문서를 참고하면 좋다.개발 바보들의 놀이터 - [초보용] Git 되돌리기( Reset, Revert ) - 삭제화면 - 삭제 이후 git log 현재 local의 commit 상태는 그대로 유지되니 올바른 내용의 commit을 한 후에 push를 진행하면 된다. 1git push origin +master // 강제푸시해야함 혹시 reset의 HEAD 숫자를 잘못입력해서 너무 많이 reset했을경우, git reflog를 사용해 몇번째 HEAD로 이동해야 하는지 살펴본다. 이동해야할 HEAD를 확인했으면 1git reset --hard HEAD@&#123;1&#125; 과 같이 강제로 되돌릴수 있다.","categories":[{"name":"etc","slug":"etc","permalink":"https://taeyeonkim93.github.io/categories/etc/"},{"name":"VCS","slug":"etc/VCS","permalink":"https://taeyeonkim93.github.io/categories/etc/VCS/"}],"tags":[{"name":"DOCUMENT","slug":"DOCUMENT","permalink":"https://taeyeonkim93.github.io/tags/DOCUMENT/"},{"name":"GIT","slug":"GIT","permalink":"https://taeyeonkim93.github.io/tags/GIT/"},{"name":"GITHUB","slug":"GITHUB","permalink":"https://taeyeonkim93.github.io/tags/GITHUB/"},{"name":"HEXO","slug":"HEXO","permalink":"https://taeyeonkim93.github.io/tags/HEXO/"},{"name":"RESET","slug":"RESET","permalink":"https://taeyeonkim93.github.io/tags/RESET/"},{"name":"VCS","slug":"VCS","permalink":"https://taeyeonkim93.github.io/tags/VCS/"}]},{"title":"[kotlin] 3. 함수형 프로그래밍","slug":"Develop-Programming-kotlin-2019-09-15-kotlin-study-3","date":"2019-09-15T10:29:05.000Z","updated":"2019-09-17T06:15:09.265Z","comments":true,"path":"2019/09/15/Develop-Programming-kotlin-2019-09-15-kotlin-study-3/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/15/Develop-Programming-kotlin-2019-09-15-kotlin-study-3/","excerpt":"","text":"References: Do it! 코틀린 프로그래밍 함수 구조123456package chap03.section1 fun sum(a: Int, b: Int): Int &#123; // fun 키워드 // 함수 이름 // 매개변수 // 반환자료형 명시 var sum = a + b // 함수 본문 return sum // 반환 &#125; 한줄로 단축도 가능하다 1fun sum(a: Int, b: Int): Int = a + b 코틀린 함수 특성함수는 스택 메모리에 저장된다.스택은 각 함수가 Frame단위로 적재된다.LIFO인 스택 구조상 Main() 함수의 프레임이 가장 바닥에 적재되고, 그위에 max()함수 등 호출되는 순서대로 적재된다. 1234567힙 영역 (낮은 주소) ↓ min()함수 Frame max()함수 Frame main()함수 Frame ↑ 스택 영역(높은 주소) 함수는 스택 영역의 높은 주소부터 거꾸로 자라듯이 채워져 나간다.가장 나중에 호출된 min 함수가 가장 위로 올라가고, 호출이 종료되면 Frame단위로 사라진다.함수 내부의 변수들은 서로 겹치지않으므로 함수 내부의 변수들끼리 계산이 가능하다. Kotlin에서는 함수의 반환값을 생략할 수 있다.단, 함수의 반환값을 생략하고 함수를 작성하면 Unit이라는 특수한 자료형으로 반환된다. 123fun printSum(a: Int, b: Int): Unit &#123; //Unit은 없어도 상관없음 println(\"sum of $a and $b is $&#123;a + b&#125;\") &#125; 함수 내에서 여러개의 매개변수를 받을 때, 가변 인자를 사용하면 된다. 1234567891011fun main() &#123; normalVarargs(1,2,3,4) normalVarargs(4,5,6) &#125; fun normalVarargs(vararg counts: Int) &#123; // 가변인자 vararg for (num in counts) &#123; print(\"$num \") &#125; print(\"\\n\") &#125; 123실행결과1 2 3 4 4 5 6 variable argument, 가변 인자의 약자 vararg를 사용하면 그때그때 변하는 인자의 개수를 전부 매개변수로 받아 사용 할 수 있다. 함수형 프로그래밍 구조코틀린은 함수형 프로그래밍과 객체지향형 프로그래밍을 모두 지원하는 다중 패러다임 언어 이다. 다중 패러다임 언어 : 한가지 구현 규칙에 얽매이지 않고 다양한 문법과 형식을 지원하는 언어 함수형 프로그래밍?함수형 프로그래밍의 정의와 특징 순수 함수를 사용해야 한다. 람다식을 사용할 수 있다. 고차 함수를 사용할 수 있다. 1. 순수함수함수형 프로그래밍은 순수 함수를 작성하여 프로그램의 부작용을 줄이는 프로그래밍 기법을 말한다. 순수 함수의 조건 같은 인자에 대하여 항상 같은 값을 반환하는 함수 함수 외부의 어떤 상태도 바꾸지 않는 함수 1234순수 함수의 예 fun sum(a: Int, b: Int): Int &#123; return a + b &#125; 123456순수 함수를 만족하지 않는 함수의 예 fun check() &#123; val test = User.grade() if (test != null) process(test) // test는 User.grade()의 상태에 따라 달라짐 &#125; 2. 람다식람다식은 다음과 같은 형태로 이루어져있다. { x, y -&gt; x + y } 함수의 이름이 없고, 화살표(-&gt;)가 사용되었다. 함수형 프로그래밍의 람다식은 다음과 같은것을 말한다. 다른 함수의 인자로 넘기는 함수 함수의 결과값으로 반환되는 함수 변수에 저장하는 함수 람다식 예시 1234567891011121314변수에 할당하는 람다식 //// 같은 람다식 //// val multi: (Int, Int) -&gt; Int = &#123;x: Int, y: Int, Int -&gt; x * y&#125; val multi = &#123;x: Int, y: Int -&gt; x * y&#125; val multi: (Int, Int) -&gt; Int = &#123;x, y -&gt; x * y&#125; //// 같은 람다식 //// val multi = &#123;x,y -&gt; x * y&#125; // 이건 오류 (자료형이 없음) val greet: () -&gt; Unit = &#123;println(\"Hello World!\")&#125; // 반환값이 없을때 val square: (Int) -&gt; Int = &#123;x -&gt; x * x&#125; // 매개변수가 하나일때 val nestedLambda: () -&gt; () -&gt; Unit = &#123;&#123;println(\"nested\")&#125;&#125; // 람다식 안에 람다식 사용할경우 함수처럼 multi(x,y)로 사용하면 된다. 3. 일급 객체함수형 프로그래밍에서는 함수를 “일급 객체” 로 생각한다. 일급 객체의 특징은 다음과 같다. 일급 객체는 함수의 인자로 전달할 수 있다. 일급 객체는 함수의 반환값에 사용할 수 있다. 일급 객체는 변수에 담을 수 있다. 함수가 일급 객체면 일급 함수라고 부른다.일급 함수에 이름이 없는 경우 람다식 함수 혹은 람다식이라고 부를 수 있다즉 람다식은 일급 객체의 특징을 가진 이름 없는 함수이다. 4. 고차 함수고차 함수 란 다른 함수를 인자로 사용하거나 함수를 결과값으로 반환하는 함수를 말한다. 인자가 일반 함수인 고차 함수 예시 1234567891011인자가 일반 함수인 고차 함수 fun main() &#123; val res1 = sum(3,2) val res2 = mul(sum(3,3),3) // 인자에 함수 사용 println(\"res1: $res1, res2: $res2\") &#125; fun sum(a:Int, b:Int) = a + b fun mul(a:Int, b:Int) = a * b 12실행 결과 res1: 5, res2: 18 반환값이 일반 함수인 고차 함수 예시 1234567891011반환값이 일반 함수인 고차 함수 fun main() &#123; println(\"funcFunc: $&#123;funcFunc()&#125;\") &#125; fun sum(a:Int, b:Int) = a + b fun funcFunc():Int &#123; return sum(2,2) // 반환값이 함수 &#125; 12실행 결과 funcFunc: 4 람다식을 매개변수에 할당하는 고차함수 예시 123456789101112람다식을 매개변수에 할당하는 고차함수 fun main() &#123; var result: Int result = highOrder(&#123; x, y -&gt; x + y&#125;, 10,20) // 람다식 함수 호출 println(result) &#125; fun highOrder(sum: (Int, Int) -&gt; Int, a: Int, b: Int): Int &#123; // 매개변수에 삽입된 람다식 return sum(a,b) &#125; 12실행 결과 30 인자와 반환값이 없는 람다식 고차함수 예시 123456789인자와 반환값이 없는 람다식 고차함수fun main() &#123; val out: () -&gt; Unit = &#123;println(\"Hello World\")&#125; // -&gt; Unit 생략 가능 out() // 함수처럼 이용가능 val new = out // 다른 변수에 람다식 할당 가능 new() &#125; 123실행 결과 Hello World Hello World","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"do it study","slug":"do-it-study","permalink":"https://taeyeonkim93.github.io/tags/do-it-study/"},{"name":"kotlin","slug":"kotlin","permalink":"https://taeyeonkim93.github.io/tags/kotlin/"}]},{"title":"[kotlin] 2. 코틀린 기초","slug":"Develop-Programming-kotlin-2019-09-14-kotlin-study-2","date":"2019-09-14T09:04:45.000Z","updated":"2019-09-16T03:26:20.715Z","comments":true,"path":"2019/09/14/Develop-Programming-kotlin-2019-09-14-kotlin-study-2/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/14/Develop-Programming-kotlin-2019-09-14-kotlin-study-2/","excerpt":"","text":"References: Do it! 코틀린 프로그래밍 프로젝트, 모듈, 패키지, 파일코틀린은 파일이 모여 패키지가 되고, 패키지가 모여 모듈이 된다.파이썬에서는 모듈이 모여 패키지가 되더니 언어마다 다른건가 싶다. 코틀린 프로젝트 계층 구조 1234# 프로젝트 ## 모듈 ### 패키지 #### 파일 패키지같은 프로젝트 내에서 같은 클래스 이름을 쓰더라도 오류가 나지 않게 패키지 이름으로 분류한다. 같은 프로젝트 내 Person 클래스 2개 -&gt; 충돌 발생 1번 패키지 내 Person 클래스 / 2번 패키지 내 Person 클래스 -&gt; 문제없음 패키지 이름을 선언하지 않고 파일을 만들면 default 패키지 아래로 자동으로 들어간다. - 보이지않는 default 패키지 아래에 존재하는 파일 패키지 명은 .으로 구분한다. 1com.example.edu 기능이나 역할을 뒤에 추가로 넣어주면 좋다. 1com.example.net.upload // 인터넷 업로드 기능을 하는 패키지명 다른 패키지 내 클래스 import 문법 및 클래스 객체로 만들기 123package com.taeyeon93.study.freetest2class Person(val name: String, val age:Int) // 클래스 선언 123456789package com.taeyeon93.study.freetest import com.taeyeon93.study.freetest2.Person // 클래스 import fun main() &#123; val user1 = Person(\"kildong\", 30) // 클래스 객체로 만들기 println(user1.name) println(user1.age)&#125; 123실행결과kildong30 다른 패키지 내의 클래스명과 현재 패키지의 클래스명이 같아서 객체를 만들기 어려울 때 as 별명을 붙여 구분한다. 1234import com.example.edu.Person as User fun main() &#123; val user1 = User(\"kildong\", 30) &#125; 변수/자료형변수변수는 val, var라는 키워드를 이용하여 선언한다. val : 변할 수 없는 상수 선언시 사용 / C,C++ 등에서는 const var : 일반적인 변수 코틀린은 자료형을 지정하지 않아도 자료형을 추론해서 알아서 자료형을 지정 할 수 있다. 12val username = \"Kildong\"// 코틀린이 자료형을 추론하여 username의 자료형을 String으로 결정 단, 자료형을 명시하지 않는 변수는 자료형을 추론할 수 있는 값을 지정해야 한다. 1var username // 자료형이 지정되지 않아 선언불가 변수에 커서를 대고 Ctrl+Shift+P를 누르면 추론된 자료형을 볼 수 있다. 쌍따옴표 내부에서 변수를 사용할때는 $ 특수문자를 붙여야 한다. 123456fun main()&#123; val number = 1234 println(number) println(\"$number\") &#125; 자료형코틀린의 자료형은 참조형 자료형을 사용한다. 기본형 자료형(Primitive Data Type) : int, long, float, double 등 참조형 자료형(Reference Type) : String, Date 등 참조형으로 선언한 변수는 코틀린 컴파일러에서 다시 기본형 자료형으로 대체되기 때문에 굳이 기본형을 신경쓸 필요가 없다. 언더스코어를 사용하면 자릿값을 구분할 수 있다. 123val number = 1_000_000val cardNum = 1234_1234_1234_1234L val hexVal = 0XAB_CD_EF_12 변수를 선언할때는 힙 영역에 실제 데이터를, 스택 영역에 주소값을 넣는다. 문자열 자료형은 동일한 문자열을 선언할 경우, 이미 힙 영역을 사용하고있는 문자열을 참조하는것이 효율적이므로이전에 선언한 힙 영역의 실제 데이터를 참조하는 주소값을 생성한다. 12345678910fun main() &#123; var str1: String = \"Hello\" var str2 = \"World\" var str3 = \"Hello\" // 동일한 Hello 라는 값을 선언한 경우 str1이 갖고있는 값의 주소값을 스택에 넣는다. println(\"str1 === str2: $&#123;str1 === str2&#125;\") println(\"str1 === str3: $&#123;str1 === str3&#125;\") // 주소값이 일치하므로 true&#125; 123실행결과 str1 === str2: falsestr1 === str3: true 코틀린은 아예 변수에 null을 허용하지 않아 NullPointerException 오류가 발생하지 않는다.그래서 코틀린에서 null을 허용하기위해서는 ? 기호를 이용해 선언해야 한다. null을 허용한 변수를 사용하기위해선 세이프 콜과 non-null 단정 기호를 사용해야 한다. 세이프 콜 : String? 과 같은 자료형은 변수 뒤에 ?. 을 붙여야 콜이 가능하다. non-null 단정기호 : 세이프콜과 같은 역할이며 !!. 을 붙여서 콜을 하지만, null에 대한 검증을 거치지 않아 컴파일은 가능하나 빌드중에 NPE 에러를 낸다. 12345fun main() &#123; var str1 : String? = \"Hello Kotlin\" str1 = null println(\"str1: $&#123;str1?.length&#125;\") // 세이프콜&#125; 12실행결과 str1 : null 12345fun main() &#123; var str1 : String? = \"Hello Kotlin\" str1 = null println(\"str1: $&#123;str1!!.length&#125;\") // non-null 단정기호&#125; 1234실행결과Exception in thread \"main\" kotlin.KotlinNullPointerException at chap02.section3.Sec3Kt.main(sec3.kt:6) at chap02.section3.Sec3Kt.main(sec3.kt) 엘비스 연산자를 이용하면 좀 더 안전하고 효율적으로 null을 허용한 변수를 사용할 수 있다.변수에 들어있는 값이 null일경우 반환값을 특정한 값으로 대체할 수 있다. 엘비스 연산자 : [?:] 왼쪽의 값이 null일 경우 오른쪽 값을 반환. 12345fun main() &#123; var str1 : String? = \"Hello Kotlin\" str1 = null println(\"str1: $str1 length: $&#123;str1?.length ?: -1&#125;\") // 엘비스 연산자 사용&#125; 12실행결과 str1: null length: -1 코틀린에서는 서로 다른 자료형의 변수를 비교하거나 연산할 수 없다.서로 다른 변수를 같은 자료형으로 직접 만들어야 연산할 수 있다.형변환은 toByte, toLong, toDouble 등을 통해서 변경한다. 어떤 변수가 정수일수도 있고 실수일 수도 있는 경우, 스마트 캐스트를 활용한다.일반적으로 처음 선언한 자료형은 뒤에 다른 자료형을 대입할 수 없지만, 스마트캐스트를 이용하면 가능하다.스마트캐스트는 Number, Any 등을 써서 다양하게 사용 할 수 있다. 12345678910111213fun main() &#123; var test: Number = 12.2 println(\"$test\") test = 12 println(\"$test\") test = 120L println(\"$test\") test += 12.0f println(\"$test\") &#125; 12345결과값 12.2 12 120 132.0 $변수.javaClass 를 사용하면 변수의 자료형을 얻을 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"do it study","slug":"do-it-study","permalink":"https://taeyeonkim93.github.io/tags/do-it-study/"},{"name":"kotlin","slug":"kotlin","permalink":"https://taeyeonkim93.github.io/tags/kotlin/"}]},{"title":"[kotlin] 1. 코틀린 Hello World","slug":"Develop-Programming-kotlin-2019-09-14-kotlin-study-1","date":"2019-09-14T07:04:30.000Z","updated":"2019-09-14T08:57:20.367Z","comments":true,"path":"2019/09/14/Develop-Programming-kotlin-2019-09-14-kotlin-study-1/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/14/Develop-Programming-kotlin-2019-09-14-kotlin-study-1/","excerpt":"","text":"References: Do it! 코틀린 프로그래밍 코틀린 공부를 정리하는 포스팅 코틀린 언어의 장점 자료형 오류를 미리 검사한다. NPE(NullPointerException) 예방으로 인한 안정성이 향상된다. 간결하고 효율적이다. 함수형 프로그래밍, 객체지향 프로그래밍 모두 가능하다. 코틀린 환경 세팅 JVM 환경에서 실습을 진행하기위하여 JDK(Java Development Kit) 설치가 필요하므로OpenJDK 설치(안정적인 동작을 위해 Java 8 버전 설치), 환경변수 세팅 InteliJ IDE 설치 Hello World!코틀린 언어의 Hello World 출력법 123fun main(args: Array&lt;String&gt;) &#123; println(\"Hello Kotlin!\") &#125; 12실행결과Hello Kotlin! Ctrl + Shift + F10으로 빌드가 가능하다. 코틀린 코드는 main()메서드가 있는 파일 이름을 기준으로 JVM이 자동으로 클래스를 생성하므로 클래스를 명시하지 않아도 동작한다. 123456789101112내부에서 자동으로 생성된 코틀린의 클래스 (tools &gt; Kotlin &gt; show Kotlin Bytecode 혹은 우측 Kotlin Bytecode 클릭) public final class HelloKotlinKt &#123; // access flags 0x19 public final static main(\\[Ljava/lang/String;)V // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 ... ...","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"do it study","slug":"do-it-study","permalink":"https://taeyeonkim93.github.io/tags/do-it-study/"},{"name":"kotlin","slug":"kotlin","permalink":"https://taeyeonkim93.github.io/tags/kotlin/"}]}]}
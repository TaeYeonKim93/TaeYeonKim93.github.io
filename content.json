{"meta":{"title":"Taeyeon","subtitle":"Taeyeon's blog","description":"Taeyeon's dev blog","author":"Taeyeon Kim","url":"https://taeyeonkim93.github.io","root":"/"},"pages":[{"title":"About me","date":"2019-09-11T12:43:47.000Z","updated":"2019-09-11T12:48:05.156Z","comments":true,"path":"about/index.html","permalink":"https://taeyeonkim93.github.io/about/index.html","excerpt":"","text":"김태연"}],"posts":[{"title":"[프로젝트] 안드로이드 앱 개발 구상","slug":"app-develop-project-1","date":"2019-10-15T11:54:02.000Z","updated":"2019-10-20T13:47:51.708Z","comments":true,"path":"2019/10/15/app-develop-project-1/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/15/app-develop-project-1/","excerpt":"","text":"개요개발자로써 커리어를 App 개발로 정했고, 시작으로 간단한 프로젝트를 진행한다.이전에 앱 개발을 해본 경험을 바탕으로 프로토타입용 앱을 개발하려고 한다. 기획과 디자인, 개발 모두 1인으로 진행한다.짧은 시간과 1인 프로젝트인 만큼 toy 프로젝트 형식으로 간단하게 개발한다. 1. 어떤 개발을 할 것인가?짧은 시간제한과 의미있는 프로젝트를 위해 몇 가지 고려해야할 사항이 있다. 어떤 개발환경으로 진행할 것인가? (language, DB, logger, error handling..) 어떤 어플을 만들것인가? 수익구조나 타겟층같은 내용도 고려해야 하지만 toy 프로젝트이므로 그런점은 감안하고 진행한다. 어떤 개발환경으로 진행할 것인가? 개발언어 : Kotlin 2017 Google이 선정한 Android 대표 개발언어. 객체지향 언어라 기존 JAVA 개발과 흡사하며 코드가 간결하다. DB : SQLite Android 개발시에 사용할 DB. 마지막 개발한지 몇년이 지나서 아직도 이걸 쓰는지 모르겠다 Realm 도 검토예정 Server : AWS $0.88 매달 내면서 이용중인 개인서버가 있다. 유저가 로컬만 사용하는 어플이 아니어서 회원가입, 로그인 등에 이용가능할듯 기타 사항은 만들면서 추가 예정 어떤 어플을 만들 것인가?1인개발의 장점을 살리기 위해서는 화려한 기능보다는 적은 기능에 집중하는게 좋다.아이디어를 고민하던 중 친구의 도움을 받아 일정 관리 어플을 만들어보기로 했다. 12345678910111213&lt;챙겼나요?&gt;- 특정 날짜를 지정해서 한줄메모를 계속 추가할 수 있음- 위젯으로 각 날자에 써놓은 항목을 배경화면이나 잠금화면 위에 띄울수있음- 각 항목을 클릭하면 삭제선그어짐ex)10월 18일- 우산(삭제선)- 대강당 교육 오후 2시- xx한테 돈보냄?(삭제선)앱은 기능이 많으면 안되고 최대한 단촐하게. 추가한다면 알람정도 일정 관리 어플 장점 구글 Keep 메모, MS 원노트, 에버노트, 리마인더 등 먼저 있었던 앱들을 참고할수 있다. 유저마다 원하는 일정 관리의 형태가 달라 특정 사용자층을 노릴 수 있다 간단하다 실생활에 접목하기 쉽다 일정 관리 어플 단점 시장에 비슷한 어플이 너무 많아 굳이 쓸 이유가 없다 너무…많다… 기존 앱들을 사용해보고 불편했던점을 종합해서 요구사항으로 반영해보기로 했다. 2. 어플 기능 정리 요구사항 정의 123456789101112131415- 메모가 가능해야함 - 가독성이 용이해야함 - 수정이 용이해야함 / 채팅형 방식도 고민중- 다음날짜로 넘어갈경우(24:00 이후) 안에 내용도 모두 다음날짜 내용으로 바뀌어야함- 위젯이 가능해야함. 4x2 ~ 5x5 대응 - 이전 날짜에 있던 모든 일정은 보이지 않아야함(기본) - [메모 유지] Flag 가 On 되어있을경우 다음날짜로 일정이 넘어감 (선택)- 검색창에 내 할일을 찾으면 찾을 수 있어야함 (추가기능)- 리마인더, 구글캘린더와 연동이 가능해야함 (추가기능) - 스마트워치와 연동가능해야함 (추가기능)- 백업이 가능해야함 (추가기능)- 잠금화면 위에 위젯이 올라와야함 (추가기능)- AOD 위로 올라와야함 (추가기능)- 알림이 가능해야함 (추가기능) 기능 정의 1234567891011121314151617181920212223242526272829303132333435363738394041- 메인 화면 구현 - 메인화면 상단 달력 바 구현 - 날짜 클릭 시 해당 날짜의 일정 출현 기능 구현 - 이전 주 / 다음 주 슬라이드 이동 기능 구현 - 월 누르면 월 선택할수있는 박스 기능 구현 - 해당 월의 가장 뒤 날짜로 이동 기능 구현(이번달은 오늘날짜) - # 아래 bar 클릭시 달력 출현 기능 구현 (추가기능) - 메인화면 하단 일정 관리 화면 구현 - 체크박스 기능 구현 (체크할시 취소선) - 우측에 휴지통 버튼 구현 (클릭시 일정 삭제) - 최하단 메모 추가 버튼 구현 (클릭시 일정추가화면으로 이동) - 무한 기능이 들어간 일정의 경우 글자색이 바뀜- 위젯 화면 구현 - 위젯 화면 상단 소형 달력 화면 구현 - 이전 날 / 다음 날 버튼 기능 구현 - 오늘 날짜 표시 기능 구현 - 오늘 날짜로 돌아가기 버튼 구현 - 일정 추가 버튼 구현 - 다양한 크기가 가능해야함 - 위젯 하단 일정 화면 구현 - 당일의 일정 리스트 가져오기 기능 구현 - 취소선이 그어진 일정은 가져오지 않음 - 체크박스 기능 구현 - 체크박스 클릭시 3초뒤에 위젯에서 삭제- 일정 추가 화면 구현 - 뒤로가기 버튼 구현 - 메모 작성칸 구현 - 화면 진입시 오토포커스 - 클릭시 키보드 출현, 내용 입력 가능 - 날짜 기능 구현 - 오늘 날짜 표시 기능 구현 - 이전 날 / 다음 날 버튼 기능 구현 - 하단에 취소 / 저장 버튼 구현 - 저장 기능 구현 - 저장시 해당된 날짜 기준으로 메모 내용 저장 - 무한 버튼 구현 - 무한 버튼이 활성화 되어있을경우 다음날로 넘어가면 다음날에 해당 일정이 추가됨 디자인 정의앱 디자인화면Oven.io 로 구현했다. 프로토타입 디자인하기에 최적의 사이트. 메인화면 위젯화면 일정추가 화면 크게 3개로 분류했고 [해당일정 관리화면]이 따로 필요할 경우 추가예정","categories":[{"name":"Project","slug":"Project","permalink":"https://taeyeonkim93.github.io/categories/Project/"},{"name":"Android","slug":"Project/Android","permalink":"https://taeyeonkim93.github.io/categories/Project/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://taeyeonkim93.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"https://taeyeonkim93.github.io/tags/App/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://taeyeonkim93.github.io/tags/Kotlin/"}]},{"title":"[종만북] 책 내용 정리","slug":"etc-2019-10-09-jongman-book-study-1","date":"2019-10-09T08:50:08.000Z","updated":"2019-10-10T13:20:10.039Z","comments":true,"path":"2019/10/09/etc-2019-10-09-jongman-book-study-1/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/09/etc-2019-10-09-jongman-book-study-1/","excerpt":"","text":"프로그래밍 대회에서 배우는 알고리즘 문제해결전략 책 정리용 알고리즘 문제를 푸는 방법1234561. 문제를 읽고 이해한다2. 문제를 익숙한 용어로 재정의한다3. 어떻게 해결할지 계획을 세운다4. 계획을 검증한다5. 프로그램으로 구현한다6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다. 문제를 읽고 이해한다 초보~고수까지 문제를 잘못읽는 경우가 다반사 문제의 궁극적인 목적, 사소한 제약조건까지 완벽하게 이해해야함 재정의와 추상화 자신이 다루기 쉬운 개념을 이용해서 자신의 언어로 풀어쓰기 현실세계의 개념을 우리가 다루기 쉬운 수학적/전산학점 개념으로 옮겨 표현 계획 세우기 사용할 알고리즘, 자료구조 선택 계획 검증하기 설계한 알고리즘이 모든 경우에 요구조건을 정확히 수행하는지 증명 수행에 걸리는 시간과 메모리가 문제의 제한 내에 들어가는지 확인 계획 수행하기 정확히 구현하기 회고하기 자신이 문제를 해결한 과정을 돌이켜보고 개선하기 문제를 풀 때마다 코드와 함께 자신의 경험을 기록으로 남겨야 함 문제의 간단한 해법과, 어떤 방식으로 접근했는지, 문제의 해법을 찾는데 결정적이었던 깨달음 한번에 맞추지 못한 경우는 오답 원인도 적는게 좋음 다른 사람의 코드를 보면서 공부하는것도 좋음 문제를 풀지 못할 때# 직관과 체계적인 접근 직관은 해당 문제를 해결하는 알고리즘이 대략 어떤 형태를 가질지 짐작하게 함 어려운 문제들은 체계적으로 접근해야 함 비슷한 문제를 풀어본 적이 있던가? 비슷한 문제를 풀어봤으면 이전 방법과 비슷한 접근방법을 사용할 것임 기존 문제를 경험으로 만들려면 원리를 완전히 이해하고 변형할 수 있어야 함 형태가 비슷하지 않더라도 문제의 목표가 같은 경우 또한 이에 소함 어떤 사건의 발생확률/경우의 수를 계산하는 문제는 대부분 동적계획법으로 해결 가능 단순한 방법에서 시작할 수 있을까? 무식하게 풀 수 있을까? 시간과 공간 제약을 생각하지 않고 문제를 해결해봄 점진적인 개선을 통해 알고리즘의 효율성을 증가시킴 내가 손으로 문제를 푸는 과정을 수식화 할 수 있을까? 번뜩이는 영감이 필요한 문제를 만났을때는 다른 방법을 시도해봐야한다. 손으로 여러 간단한 입력(문제에 주어진 예제 입력)을 직접 해결 문제를 해결하는 방법을 공식화해서 답을 만드는 알고리즘을 만들수 있는 경우가 있음 이 과정에서 알고리즘이 어떤 점을 고려해야하는지를 알게됨 문제를 단순화할 수 있을까? 좀더 쉬운 변형판을 먼저 풀어보기. 제약조건을 없애거나, 계산해야하는 변수를 줄이거나, 다차원의 문제를 1차원으로 줄이기도 함 그림으로 그려볼 수 있을까? 관련된 그림을 그려보면 더 쉬움 수식으로 표현할 수 있을까? 평문으로 쓰여있는 문제를 수식으로 표현하는 것도 도움이 됨 문제를 분해할 수 있을까? 문제의 제약조건을 분해할 수 있음 뒤에서 생각해서 문제를 풀 수 있을까? 모든 선택지를 위에서 아래로 내려가 보는 대신에 아래에서 위로 딱 한번만 하면 해결 가능 순서를 강제할 수 있을까? 순서가 없는 문제에 순서를 강제함 경우의 수를 셀 때도 유용함. 특정 조건을 만족하는 답들의 수를 세는 경우 특정 형태의 답만을 고려할 수 있을까? 정규화 기법이 있음 정규화란 우리가 고려해야 할 답들 중 형태가 다르지만 결과적으로 똑같은것들을 그룹으로 묶은 뒤, 각 그룹의 대표만을 고려하는 방법 좋은 코드를 짜기 위한 원칙 간결한 코드를 작성하기 가장 간결한 코드를 작성해야 오타나 버그가 생길 가능성이 적다 적극적으로 코드 재사용하기 같은 코드가 세번 이상 등장한다면 해당 코드를 함수로 분리해 재사용한다 표준 라이브러리 공부하기 시간낭비를 줄일 수 있으나 표준적인 알고리즘 구현 사용법을 잘 알아두기 항상 같은 형태로 프로그램을 작성하기 여러 종류의 반복적인 코드들(BFS, 2차원 자료구조 등)은 항상 같은것으로 사용하기 일관적이고 명료한 명명법 사용하기 모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이기 사용하는 언어의 표준 라이브러리에서 사용하는 명명규약을 익히기 모든 자료를 정규화해서 저장하기 같은 자료를 두가지 형태로 저장하지 않기 정규화는 프로그램이 자료를 입력받거나 계산하자마자 곧장 이루어져야 함 이상적으로는 자료를 표현하는 클래스의 생성자에서 정규화를 수행하거나 외부에서 자료를 입력받자마자 정규화를 하는게 좋음 코드와 데이터를 분리하기 정적 데이터 내용을 함수로 따로 만드는 행위를 하지 않기 자주 하는 실수 산술 오버플로 계산 과정에서 변수의 표현범위를 벗어나는 값을 사용 배열 범위 밖 원소에 접근 배열 크기를 정할때 계산을 신중하게 하기 0 시작범위와 1 시작범위 혼동하지않기 일관되지않은 범위표현방식 사용하기 [2,12] -&gt; 2~12 까지 자연수 표현, (2,12) -&gt; 3~11까지 자연수 표현 절충안으로 [lo, hi)를 사용함 Off-by-one 오류 반복문을 한번 더 많이 순회하거나 열린구간과 닫힌구간을 혼용해서 쓴 경우 많이 발생 입력이 주어졌을 때 코드가 어떻게 동작할지 되새겨보면서 프로그램 짜야함 컴파일러가 잡아주지 못하는 상수 오타 상수를 잘못 입력해서 생기는 오류 스택 오버플로 call stack이 오버플로해서 프로그램이 강제종료 되는것 재귀호출의 깊이가 너무 깊어지는게 대개 원인 스택 메모리가 적을때는 힙에 메모리를 할당하는게 좋음 다차원 배열 인덱스 순서 바꿔서 쓰기 특정 배열에 접근하는 위치를 하나로 통일하는것이 좋음 잘못된 비교 함수 작성 최소, 최대 예외 잘못 다루기 예외를 잘 처리해야 한다 연산자 우선순위 잘못 쓰기 시프트 연산자나 비트 단위 연산자들은 종종 헷갈림 너무 느린 입출력 방식 선택 gets()로 한꺼번에 받거나 cin으로 고수준 입력방식을 받을수도 있지만 느릴수 있기때문에 잘 선택해야함 변수 초기화 문제 이전 입력에 사용한 전역변수값을 초기화하지않고 그대로 사용함 디버깅과 테스팅 디버깅에 관하여 프로그래밍 대회용 소스코드는 대부분 짧기때문에 눈으로 하는것이 훨씬 빠름 재귀호출이나 중복 반복문을 자주 쓰면 디버깅하기에 힘듬 디버거 사용 대신 해야할 단계 작은 입력에 대해 제대로 실행되나 확인하기 오동작하는 가장 작은 입력을 먼저 찾아내면 디버깅하기 훨씬 용이함 단정문을 쓴다 주어진 조건이 거짓일때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문 프로그램의 계산 중간겨로가를 출력한다 중간과정 값들을 출력하고 자신이 예상하는 바와 맞아들어가는지 검사하기 디버거를 사용하는 좋은 예는 프로그램이 런타임 오류를 내고 종료하는 경우 테스트에 관하여 제출 전에 예제 입력을 만들어 가능한 많이 프로그램을 테스트하는것이 좋음 스캐폴딩 방법을 이용해 검증한다.(다른 코드를 개발할때 뼈대를 잡기위해 임시로 사용하는 코드) 변수 범위의 이해 산술 오버플로 어떤 식의 계산값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우 너무 큰 결과 프로그램이 출력해야할 결과가 너무 크면 안됨 너무 큰 중간값 계산식 도중에 값이 자료형의 크기를 넘는 경우가 있음 너무 큰 무한대값 무한대 값을 이용해 특수한값으로 사용할때는 무한대값들이 서로 더해지거나 곱해지는 경우가 없는지 잘 살펴봐야함. 오버플로 피해가기 자료형 큰거로 바꾸기 계산 순서 바꾸기 점화식 이용하기 자료형의 프로모션 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러가 자동으로 변환하는것을 프로모션이라 함 자동으로 형변환되는 숫자들에 대한 주의가 필요함","categories":[{"name":"etc","slug":"etc","permalink":"https://taeyeonkim93.github.io/categories/etc/"},{"name":"Private","slug":"etc/Private","permalink":"https://taeyeonkim93.github.io/categories/etc/Private/"}],"tags":[{"name":"공부정리","slug":"공부정리","permalink":"https://taeyeonkim93.github.io/tags/공부정리/"},{"name":"종만북","slug":"종만북","permalink":"https://taeyeonkim93.github.io/tags/종만북/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 큰 수 만들기","slug":"Algorithm-2019-10-02-programmers-coding-test-9","date":"2019-10-02T08:42:30.000Z","updated":"2019-10-03T12:21:23.628Z","comments":true,"path":"2019/10/02/Algorithm-2019-10-02-programmers-coding-test-9/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/02/Algorithm-2019-10-02-programmers-coding-test-9/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한 조건 number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다. 입출력 예 name k return “1924” 2 “94” “1231234” 3 “3234” “4177252841” 4 “775841” 조건 분석 나와야 하는 결과 1만들 수 있는 숫자 중 가장 큰 숫자의 [문자열] 문제를 풀기위해 주어진 데이터 1234567# 문제 해결에 필요한 데이터1. name 문자열2. 문자열에서 제거할 숫자의 갯수# 제한조건- 앞에서 뒤로 제거하는 방식 간단 알고리즘 12341. 만들 문자열 길이(전체길이 - k) 만큼의 배열리스트 내에서 최대값을 찾는다.2. answer에 최대값을 저장하고 최대값과 그 이전의 값들을 다 없앤다.3. 만들 문자열 길이 -1 을 하고 다시 리스트 내에서 최대값을 찾는다.4. 만들 문자열 길이가 0이면 반환한다. 나의 풀이사용언어 : Python 3 위와 같은 알고리즘으로 답은 나왔으나 테스트케이스 중 시간초과로 해결하지 못한 케이스가 있었다.찾아보니 스택으로 처리해야 한다는데 생각보다 간단해서 김이 빠졌다. 12345678910111213def solution(number, k): collected = [] for i, num in enumerate(number): while len(collected) &gt; 0 and collected[-1] &lt; num and k &gt; 0: collected.pop() k -= 1 if k == 0: collected += list(number[i:]) break collected.append(num) collected = collected[:-k] if k &gt; 0 else collected return ''.join(collected) 풀고 난 이후에 다른 사람들의 풀이를 봐도 매번 최대값을 찾는 풀이는 없었고 모두 스택으로 해결한것 같다. 123456789101112131415# 알고리즘1. numbers 의 값들을 순회한다. 1. 스택에 값이 있는지 확인한다. T : 제일 위 스택이 현재값보다 작은지 확인한다 T : k값이 0보다 큰지 확인한다. T : 스택의 값을 제거하고 k = k - 1 해준다. 2. k값이 0인지 확인한다. T : 남은 number 리스트의 값들을 모두 뒤에 추가하고 break 한다 3. 현재값보다 스택이 큰지 확인한다. T : 스택에 현재값을 넣는다2. numbers 에서 k값이 0이 안됐을 경우 ([5,4,3,2,1] , [2]) T : 스택에서 뽑아야 할 문자열의 갯수만큼 뽑아낸다. F : 스택 그대로 출력한다. 스택을 활용한 방법이 O(n)이라 매우 빠르다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"STACK","slug":"STACK","permalink":"https://taeyeonkim93.github.io/tags/STACK/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 조이스틱","slug":"Algorithm-2019-10-02-programmers-coding-test-8","date":"2019-10-02T05:58:32.000Z","updated":"2019-10-03T12:21:23.620Z","comments":true,"path":"2019/10/02/Algorithm-2019-10-02-programmers-coding-test-8/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/02/Algorithm-2019-10-02-programmers-coding-test-8/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. 1234▲ - 다음 알파벳▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다. 1234- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.따라서 11번 이동시켜 &quot;JAZ&quot;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 제한 조건 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 name return “JEROEN” 56 “JAN” 23 조건 분석 나와야 하는 결과 1조이스틱 조작 횟수의 [최솟값] 문제를 풀기위해 주어진 데이터 12345678# 문제 해결에 필요한 데이터1. 조이스틱 조작방식에 대한 정보2. 만들어야하는 이름의 정보# 제한조건- 알파벳 대문자로만 이루어져 있음- 길이가 1~20까지 간단 알고리즘 11. Greedy 알고리즘을 사용해서 각 칸의 최적해를 찾아낸다. 나의 풀이사용언어 : Python 3 매 Case 마다 최적값이 달라지므로 Greedy 알고리즘을 사용해서 푸는 문제이다.그때그때 최적의 해를 찾아서 푸는 문제이므로 각 칸에서의 최적해를 구하는 방식을 찾는다. 왼쪽/오른쪽 중 어떤 조작을 해야 알파벳을 빨리 찾을 수 있는지 조건을 넣는다. A가 아닌 알파벳에 가장 가까운 방향으로 진행시킨다. 현재값이 A가 아니면 위아래 조작으로 넘어간다 현재값이 A일 경우 A가 아닌 값이 왼쪽으로 몇번째에 있는지 찾는다. 현재값이 A일 경우 A가 아닌 값이 오른쪽으로 몇번째에 있는지 찾는다. 두 값을 비교하고 이동횟수가 적은쪽으로 이동하고 A 갯수만큼 answer에 값을 추가한다. 위/아래 중 어떤 조작을 해야 알파벳을 빨리 찾을 수 있는지 조건을 넣는다. A~Z의 중간값인 N(위 13회, 아래 13회) 을 기준으로 나눈다. name 문자가 N보다 크거나 같으면 아래, 작으면 위 if문으로 들어간다. name 문자가 N보다 작을 때 아스키코드와 A의 아스키코드를 빼서 차 값을 answer에 넣는다 name 문자가 N보다 크거나 같을 때 아스키코드와 Z+1의 아스키코드를 빼서 차 값을 answer에 넣는다 12345678910111213141516171819202122232425262728293031323334def solution(name): answer = 0 name = list(name) base = [\"A\"] * len(name) idx = 0 while True: rIndex = 1 lIndex = 1 if name[idx] != \"A\": if name[idx] &lt; \"N\": answer += ord(name[idx]) - 65 else: answer += 91 - ord(name[idx]) name[idx]=\"A\" if name == base: break else: for i in range(1, len(name)): if name[idx + i] == \"A\": rIndex += 1 else: break if name[idx - i] == \"A\": lIndex += 1 else: break if rIndex &gt; lIndex: answer += lIndex idx -= lIndex else: answer += rIndex idx += rIndex return answer","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"GREEDY","slug":"GREEDY","permalink":"https://taeyeonkim93.github.io/tags/GREEDY/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 쇠막대기","slug":"Algorithm-2019-10-01-programmers-coding-test-7","date":"2019-10-01T12:31:51.000Z","updated":"2019-10-03T12:21:23.615Z","comments":true,"path":"2019/10/01/Algorithm-2019-10-01-programmers-coding-test-7/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/01/Algorithm-2019-10-01-programmers-coding-test-7/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명문제 설명여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다. 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다. 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다. 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다. 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다. 이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다. 12(a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 &apos;()&apos;으로 표현합니다. 또한 모든 &apos;()&apos;는 반드시 레이저를 표현합니다.(b) 쇠막대기의 왼쪽 끝은 여는 괄호 &apos;(&apos;로, 오른쪽 끝은 닫힌 괄호 &apos;)&apos;로 표현됩니다. 위 예의 괄호 표현은 그림 위에 주어져 있습니다.쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다. 쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요. 제한 조건 arrangement의 길이는 최대 100,000입니다. arrangement의 여는 괄호와 닫는 괄호는 항상 쌍을 이룹니다. 입출력 예 arrangement return “()(((()())(())()))(())” 17 조건 분석 나와야 하는 결과 1잘린 쇠막대기 조각의 총 [개수] 문제를 풀기위해 주어진 데이터 12345678910# 문제 해결에 필요한 데이터1. 쇠막대기와 레이저의 배치를 표현한 arrangement# 제한조건- 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.- 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.- 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.- 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다. 간단 알고리즘 11. 레이저와 쇠막대기의 상관관계와 규칙을 찾아낸다. 나의 풀이사용언어 : Python 3 스택을 활용해서 푸는 문제이다.간단하게 규칙을 이용해서 공식을 찾아낼수도 있지만 (쇠막대기 갯수 + 쇠막대기 갯수 * 레이저 갯수 = 조각 갯수) 문제 의도에 맞게 스택으로 풀이한다. 알고리즘 isLaser 변수를 True 로 놓는다. 스택에 arrangement 의 내부 기호를 쌓는다. 만약 isLaser 가 True 인데 ) 기호가 들어올 경우 isLaser 을 False 로 바꾸고 가장 위에있던 ( 기호를 제거하고 스택에 남아있던 ( 기호만큼 쇠막대기 갯수를 증가시킨다. 만약 isLaser 가 False 인데 ) 기호가 들어올 경우 가장 위에있던 ( 기호를 제거하고 쇠막대기 갯수를 1만큼 증가시킨다 만약 isLaser 가 True 인데 ( 기호가 들어올 경우 스택에 쌓는다. 만약 isLaser 가 False 인데 ( 기호가 들어올 경우 isLaser 을 True 로 변경하고 그대로 스택에 쌓는다. 쌓인 쇠막대기 갯수를 return 한다. insert 와 pop 을 행할 시 결과값이 어떻게 바뀌는지 주의하면서 알고리즘을 짠다. 12345678910111213141516171819def solution(arrangement): answer = 0 isLaser = True steel_stack = [] for bracket in arrangement: if isLaser and bracket == \")\": isLaser = False steel_stack.pop() answer += len(steel_stack) elif not isLaser and bracket == \")\": answer += 1 steel_stack.pop() elif isLaser and bracket == \"(\": steel_stack.append(bracket) else: isLaser = True steel_stack.append(bracket) return answer 다른 풀이스택을 활용한 방법과 replace를 이용해 레이저를 다른 변수로 바꿔버린 풀이가 있다. 레이저 부분을 P로 치환해서 해결한 사례. 그외에는 스택을 이용해서 비슷하다. 1234567891011121314151617def solution(arrangement): answer = 0 stack = [] arrangement = arrangement.replace(\"()\",\"P\") for arr in arrangement: if arr == '(': stack.append(arr) answer +=1 elif arr == ')': stack.pop() else: answer += len(stack) return answer","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"STACK","slug":"STACK","permalink":"https://taeyeonkim93.github.io/tags/STACK/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 탑","slug":"Algorithm-2019-10-01-programmers-coding-test-6","date":"2019-10-01T11:48:41.000Z","updated":"2019-10-03T12:21:23.624Z","comments":true,"path":"2019/10/01/Algorithm-2019-10-01-programmers-coding-test-6/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/01/Algorithm-2019-10-01-programmers-coding-test-6/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다. 예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다. 송신 탑(높이) 수신 탑(높이) 5(4) 4(7) 4(7) 2(9) 3(5) 2(9) 2(9) - 1(6) - 맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return 하도록 solution 함수를 작성해주세요. 제한 조건 heights는 길이 2 이상 100 이하인 정수 배열입니다. 모든 탑의 높이는 1 이상 100 이하입니다. 신호를 수신하는 탑이 없으면 0으로 표시합니다. 입출력 예 heights return [6,9,5,7,4] [0,0,2,2,4] [3,9,9,3,5,7,2] [0,0,0,3,3,3,6] [1,5,3,6,7,6,5] [0,0,2,0,0,5,6] 조건 분석 나와야 하는 결과 1각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열 문제를 풀기위해 주어진 데이터 1234567# 문제 해결에 필요한 데이터1. 탑의 길이# 제한조건1. 신호를 수신하는 탑이 없으면 0으로 표시 간단 알고리즘 121. 0번째 탑은 항상 수신하지 못한다.2. 현재 탑의 왼쪽이 현재 탑의 높이보다 높은지 체크하고 높으면 배열에 넣는다. 나의 풀이사용언어 : Python 3 간단하게 2중 for문을 사용해서 풀어주었다.이번 예제를 통해 for else문을 알게되었다. 123456789101112def solution(heights): answer = [] for i, num in enumerate(heights): for j in range(i, -1, -1): if heights[j] &gt; num: answer.append(j + 1) break else: answer.append(0) return answer 다른 풀이1. 2중 for문0을 먼저 선언해준뒤에 비교했다는 사실을 빼면 차이 없음. 12345678def solution(h): ans = [0] * len(h) for i in range(len(h)-1, 0, -1): for j in range(i-1, -1, -1): if h[i] &lt; h[j]: ans[i] = j+1 break return ans 2. 스택을 사용한 방법문제 의도가 스택인것같아 한번 더 봤다.기본적으로는 비슷하지만 pop 을 이용해서 공간을 덜 먹는다는게 장점인듯 스택을 만들어주고 LIFO 법칙에 따라 가장 마지막 배열을 현재의 탑으로 잡고 배열에서 없앤다. 1234def solution(heights): responses = [] while heights: top = heights.pop() 현재의 탑의 길이보다 -1부터 내려가면서 탐색한다. 있으면 answer에 append한다.123456789 for i in range(len(heights) - 1, -1, -1): if top &lt; heights[i]: responses.append(i + 1) break else: responses.append(0)return responses[::-1]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"STACK","slug":"STACK","permalink":"https://taeyeonkim93.github.io/tags/STACK/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 124 나라의 숫자","slug":"Algorithm-2019-10-01-programmers-coding-test-5","date":"2019-10-01T07:29:56.000Z","updated":"2019-10-01T10:18:55.623Z","comments":true,"path":"2019/10/01/Algorithm-2019-10-01-programmers-coding-test-5/","link":"","permalink":"https://taeyeonkim93.github.io/2019/10/01/Algorithm-2019-10-01-programmers-coding-test-5/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124나라 10진법 124나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 제한 조건 n은 500,000,000이하의 자연수 입니다. 입출력 예 n result 1 1 2 2 3 4 4 11 조건 분석 나와야 하는 결과 1자연수 n을 124나라에서 사용하는 숫자로 변환한 [값] 문제를 풀기위해 주어진 데이터 12345# 문제 해결에 필요한 데이터1. 124 나라에서 사용된 10진법 데이터# 제한조건 간단 알고리즘 11. 124나라에서 10진법을 변환하는 규칙을 찾는다. 나의 풀이사용언어 : Python 3 주먹구구로 규칙을 찾아서 풀었다.머리가 문제인가 경험이 문제인가.. 1,2,4 총 3개의 값으로 계속 순환되고 있으므로 10진법 124나라 몫 0 x 0 1 1 0 2 2 0 3 4 1 4 11 1 5 12 1 6 14 2 7 21 2 8 22 2 9 24 3 10 41 3 11 42 3 12 44 4 13 111 4 14 112 4 15 114 5 몫이 0일때까지 3으로 나눈다. 이때 3으로 나누기가 가능한 만큼 자릿수를 추가한다. 몫-1이 0이면 자릿수 1개몫-1이 1~3이면 자릿수 2개몫-1이 4~8이면 자릿수 3개 인 규칙을 발견할수 있다. 알고리즘1234def solution(n): answer = '' pattern = [4, 1, 2] chk = n 123456789101112while True: answer = str(pattern[(chk % 3)]) + answer # 나누고 남은 나머지값이 들어간다. chk는 1,2,0 순으로 순환된다. chk = int((chk - 1)//3) # 자릿수를 파악한다. n = int(n // 3) # 나머지를 찾기위한 n의 값을 계산한다. if chk == 0: break # 더이상 계산할 자릿수가 없을때 breakreturn answer 다른 풀이n에서 1을 뺄 경우 쉬운 규칙으로 변하는 부분을 잘 캐치하였다.chk 라는 변수를 따로 선언해서 삽질하지 않은 부분이 가장 크게 다른 부분. 12345678910def solution(n): num = ['1', '2', '4'] answer = \"\" while n &gt; 0: n -= 1 answer = num[n % 3] + answer n = n // 3 return answer","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 기능개발","slug":"Algorithm-2019-09-24-programmers-coding-test-4","date":"2019-09-24T10:20:02.000Z","updated":"2019-10-01T07:02:30.511Z","comments":true,"path":"2019/09/24/Algorithm-2019-09-24-programmers-coding-test-4/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/24/Algorithm-2019-09-24-programmers-coding-test-4/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 조건 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93,30,55] [1,30,5] [2,1] 조건 분석 나와야 하는 결과 1특정 순서로 이루어진, 작업이 끝나서 배포한 작업의 [갯수] 문제를 풀기위해 주어진 데이터 12345678# 문제 해결에 필요한 데이터1. 작업의 배포순서가 적힌 리스트2. 작업의 개발 속도# 제한조건1. 배포는 하루에 한번만 가능 간단 알고리즘 1231. 작업 리스트를 큐에 집어넣는다2. 각 작업별 스피드를 작업 진척도에 더하다가 큐에서 제일 처음에 넣은 작업이 완료됐을경우 완료된 작업을 빼내고 카운트한다. 풀이사용언어 : Python 3 전형적인 Queue의 가장 쉬운 예제로 볼 수 있다.작업이 모두 완료됐을 때의 날짜를 가지고 끝난 작업의 개수를 계산하는 방법도 있다 Queue를 사용하는 방법 작업 리스트를 큐에 집어넣는다 (이미 주어진 progresses 배열이 Queue 자료구조로 되어있는 상태) 12def solution(progresses, speeds): answer = [] 각 작업별 진척도를 작업에 더한다. 12345while progresses: result = 0 if progresses[0] &lt; 100: for idx, speed in enumerate(speeds): progresses[idx] += speed 가장 앞의 작업의 진척도가 100이상일 경우, 작업의 진척도가 100인 자료들을 모두 꺼낸다. 1234567 else: while progresses and progresses[0] &gt;= 100: progresses.pop(0) speeds.pop(0) result += 1 answer.append(result)return answer 완료된 작업의 소요시간으로 계산하는 방법 마지막 작업이 걸린 소요시간을 계산한다. 12345678def solution(progresses, speeds): Q = [] for p, s in zip(progresses, speeds): # p : progresses, s : speeds if len(Q) == 0 or Q[-1][0] &lt; -((p - 100) // s): # 배열이 하나도 없거나, 현재 작업이 마지막 작업보다 소요시간이 더 길 경우 Q.append([-((p - 100) // s), 1]) # 큐에 추가한다. 현재 작업이 마지막 작업보다 소요시간이 적은 작업일 경우, 마지막 작업이 배포될 날의 개수에 추가한다. 1234 else: # 현재 작업이 마지막 작업보다 소요시간이 더 작을경우 Q[-1][1] += 1return [q[1] for q in Q]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"QUEUE","slug":"QUEUE","permalink":"https://taeyeonkim93.github.io/tags/QUEUE/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 모의고사","slug":"Algorithm-2019-09-18-programmers-coding-test-3","date":"2019-09-18T07:06:05.000Z","updated":"2019-10-03T12:21:23.612Z","comments":true,"path":"2019/09/18/Algorithm-2019-09-18-programmers-coding-test-3/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/18/Algorithm-2019-09-18-programmers-coding-test-3/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 조건 분석 나와야 하는 결과 12가장 높은 점수를 받은 [사람 번호]동점일경우 오름차순 정렬 문제를 풀기위해 주어진 데이터 1234567891011121314# 문제 해결에 필요한 데이터1. 3명의 수포자의 찍는 방식 - 1번 : 1~5까지 반복 - 2번 : 홀수번째는 2, 짝수번째는 2를 제외한 1~5 반복 - 3번 : 3,1,2,4,5를 각 2번씩 반복2. 정답 데이터# 제한조건1. 최대 문제 갯수(1만문제)2. 문제 정답 제한 (1~5)3. 동점자가 있을경우 오름차순 정렬 간단 알고리즘 11. 정답마다 각 인원의 배열을 비교한다 풀이사용언어 : Python 3 answers 리스트를 수포자의 답과 비교해야되는데 answers의 값이 무작위로 들어있으므로 완전탐색으로 풀어야 한다. 완전탐색이 카테고리인 문제를 푸는 방법은 Brute Force (무작위 대입) DFS (깊이 우선 탐색) BFS (너비 우선 탐색) 백트래킹 정도가 있다. 자세한건 타 포스팅 참조 완전탐색 알고리즘 정리 변수자체가 한개밖에 없으므로 단순하게 무작위대입으로 푸는것이 좋다. 1~3번까지의 반복되는 숫자의 패턴자체가 정해져있으므로 먼저 패턴을 정의한다. 1234def solution(answers): pattern1 = [1,2,3,4,5] pattern2 = [2,1,2,3,2,4,2,5] pattern3 = [3,3,1,1,2,2,4,4,5,5] 그 뒤는 알고리즘에 따라 변수를 정의한다. answers[0]과 parttern1~3의 첫번째 배열을 비교한다. 같을경우 각 패턴에 1점씩 부여한다. 위 과정을 반복한다. 끝나고 가장 높은 배열을 출력한다. 123# 각 패턴별 점수판 변수 선언 score = [0, 0, 0] result = [] 123456789# answers[0]과 parttern1~3의 첫번째 배열을 비교한다. for idx, answer in enumerate(answers): if answer == pattern1[idx%len(pattern1)]:# 길이만큼 순환한다 score[0] += 1 if answer == pattern2[idx%len(pattern2)]: score[1] += 1 if answer == pattern3[idx%len(pattern3)]: score[2] += 1 123456for idx, s in enumerate(score): if s == max(score): # 최대값 결과값 배열에 넣는다. result.append(idx+1)return result","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"완전탐색","slug":"완전탐색","permalink":"https://taeyeonkim93.github.io/tags/완전탐색/"},{"name":"BRUTE FORCE","slug":"BRUTE-FORCE","permalink":"https://taeyeonkim93.github.io/tags/BRUTE-FORCE/"},{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 완주하지 못한 선수","slug":"Algorithm-2019-09-17-programmers-coding-test-2","date":"2019-09-17T12:07:30.000Z","updated":"2019-09-24T08:29:43.875Z","comments":true,"path":"2019/09/17/Algorithm-2019-09-17-programmers-coding-test-2/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/Algorithm-2019-09-17-programmers-coding-test-2/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때,완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한 조건 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [leo, kiki, eden] [eden, kiki] leo [marina, josipa, nikola, vinko, filipa] [josipa, filipa, marina, nikola] vinko [mislav, stanko, mislav, ana] [stanko, ana, mislav] mislav 조건 분석 나와야 하는 결과 1완주하지 못한 선수의 [이름] 문제를 풀기위해 주어진 데이터 123456789101112# 문제 해결에 필요한 데이터1. 이름 - 참여한 선수들의 이름 리스트 (completion arr) - 완주한 선수들의 이름 리스트 (participant arr)2. 완주하지 못한 인원 수 (1명)# 제한조건1. 전체 배열 갯수 (1~10만)2. 이름 길이 (max 20 byte)3. 참가자의 동명이인 여부 (Yes) 간단 알고리즘 11. 완주한 선수들의 리스트 중에서 참여한 선수들을 제거하고 남은 선수를 반환한다. 풀이사용언어 : Python 3 알고리즘은 간결하지만 2가지의 풀이방법이 있다. 문자열을 직접 비교하는 방법 해시 테이블을 이용한 방법 문자열을 직접 비교하면 for문을 2개 활용해서 O(n^2)의 시간복잡도로 구할 수 있다.다만 문제자체에서 O(n)의 시간복잡도가 나오지 않으면 문제풀이로 인정해주지 않기 때문에 해쉬를 이용한다. 해쉬(Hash)에 대한 자세한 설명은 타 포스팅 참조 해시 알고리즘 정리 세부 알고리즘은 참여한 선수들의 이름을 특정 해쉬 함수를 통해 해쉬값으로 만든다. “색인을 통한 검색”을 위해 위의해쉬값을 색인(index)으로 하는 해쉬 테이블을 만든다. 완주한 선수들의 이름을 해쉬값으로 만들어서 참여한 선수들의해쉬 테이블에서 제거한다. 마지막에 남은 해쉬 테이블의 리스트를 반환한다. 파이썬에서는 딕셔너리라는 key-value 매핑구조를 지원한다.이때 key를 해쉬함수를 통해 나온값을 색인으로 쓰는 해쉬 테이블을 만들어주므로 편하게 사용하면 되겠다.직접 해쉬테이블을 만들고싶으면 hash()를 사용해 만들어주면 된다. 123456789101112131415161718def solution(participant, completion): dic = &#123;&#125; # 딕셔너리 선언 for parName in participant: dic[parName] = 0 # key는 참여자 이름, value는 0으로 통일하는 dic 해쉬 테이블을 만든다. for comName in completion: if comName in dic: del dic[comName] # 해쉬 테이블에서 완주자의 이름을 가진 key를 전부 제거 return list(dic.keys())[0] # 마지막 남은 key 반환participant = [\"leo\", \"kiki\", \"eden\"]completion = [\"eden\", \"kiki\"]print(solution(participant,completion)) 12실행결과leo 가장 기본적인 문제는 해결되었으니 제한조건을 살펴볼 차례이다.전체 배열갯수나 이름길이는 문제가 없지만 동명이인일때가 문제다.테스트값을participant = [&quot;leo&quot;,&quot;leo&quot;, &quot;kiki&quot;, &quot;eden&quot;]completion = [&quot;leo&quot;,&quot;eden&quot;, &quot;kiki&quot;] 이렇게 변경하면 딕셔너리 구조상 leo라는 키값이 2개가 아닌 1개로 저장된다.이때 leo라는 키를 제거하면 결국 미완주자가 0명이 된다. 같은 key를 저장할때는 value값에 값을 누적시키는 방법으로 해결이 가능하다. 12345678910111213141516171819202122def solution(participant, completion): dic = &#123;&#125; for parName in participant: if parName in dic: # 딕셔너리 내부에 동명이인이 있으면 dic[parName] = dic.get(parName) + 1 # value에 1을 추가 else: dic[parName] = 1 # 동명이인이 없으면 1로 통일 for comName in completion: if comName in dic: dic[comName] = dic.get(comName) -1 # 완주한 사람은 value값에 -1 if dic[comName] == 0: del dic[comName] # 0인 완주자는 테이블에서 제외 return list(dic.keys())[0] # value값이 1인 참여자만 남아서 반환participant = [\"leo\",\"leo\", \"kiki\", \"eden\"]completion = [\"leo\",\"eden\", \"kiki\"]print(solution(participant,completion)) 12실행결과leo 이외에 참여자와 완주자의 리스트를 알파벳순으로 정렬해 비교하는 도중 같지않으면 반환하는 방법과 Counter 클래스를 사용하는 방법도 있다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"PYTHON","slug":"PYTHON","permalink":"https://taeyeonkim93.github.io/tags/PYTHON/"},{"name":"HASH","slug":"HASH","permalink":"https://taeyeonkim93.github.io/tags/HASH/"},{"name":"HASH TABLE","slug":"HASH-TABLE","permalink":"https://taeyeonkim93.github.io/tags/HASH-TABLE/"}]},{"title":"[자료구조] HASH 정리","slug":"CS-2019-09-17-hash-algorithm","date":"2019-09-17T11:14:21.000Z","updated":"2019-09-24T08:29:00.701Z","comments":true,"path":"2019/09/17/CS-2019-09-17-hash-algorithm/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/CS-2019-09-17-hash-algorithm/","excerpt":"","text":"HASH특정한 값을, 수많은 값들 사이에서 찾아야 할 때 사용한다. 물론 탐색은 여러가지 방법이 있다. 그중에서 HASH를 사용하는 장단점을 추려보면 장점 평균 case에서 O(1)의 시간복잡도를 가진다 단점 메모리 영역을 일정부분 차지한다 충돌이 발생할 수 있다. 보안적 측면이나 Collision 및 세부내용은 타 블로그를 참조하고여기서는 탐색 알고리즘 문제를 풀기위한 기본개념만 잡는다. HASH란?HASH 란 용어 자체는 [고기와 감자를 잘게 다져 섞어 요리하여 따뜻하게 차려 낸 것] 이란 영단어 뜻에서 시작하면 된다. 어떤 내용물들을 잘 섞어서 특정한 형태로 만든다는 것이다. 짜장면을 두그릇 사서 &#39;똑같은 위치와 힘으로&#39; &#39;왼손으로 5번&#39; &#39;오른손으로 6번&#39; 비비면 두그릇은 완벽히 똑같은 짜장면이 나온다.이때 오른손으로 8번을 비비면 다른 짜장면의 모양새가 된다. 면+소스(입력값) 를 같은 방법으로 섞으면(해시함수) 완전히 같은 짜장면(해시값)이 된다. 문제가 [가장 맛있는 짜장면] 을 탐색하는 것이라면, 면과 소스를 특정한 방법으로(5번,6번) 섞기만 하면 된다. 굳이 왼손으로 1번~5번, 오른손으로 1번~6번을 전부 다 탐색해볼 필요가 없게 된것이다. HASH 사용법HASH 자료구조는 몇가지 용어가 나온다. Hash Function(해시함수) Hash Table(해시 테이블) Hash Value, Hash Code, Hash Checksum… (해시값) 우리가 알고싶은 탐색은 해시테이블을 보면 된다. name phone number John Smith 521-1234 Lisa Smith 521-8976 Sandra Dee 521-9655 이런 입력값을 주고 “Sandra Dee”의 전화번호를 찾으라고 하면, Hash를 사용하지 않을경우 “John Smith”부터 하나하나 찾아가는수밖에 없다. 하지만 이런식으로 테이블을 만들어두면 keys(입력값)이 hash function(해시함수)를 통해 Hash Value(해시값)으로 변환되어 해시값의index(색인) 을 가진 해시테이블이 완성된다. 해시테이블 index(Hash Value) Data 01 (Lisa Smith, 521-8976) 02 (John Smith, 521-1234) … … 14 (Sandra Dee, 521-9655) 이렇게 모두 저장해두면 나중에 ‘Sandra Dee’ 라는 입력값을 찾기위해서는 Sandra Dee를 해시함수에 넣는다 Sandra Dee가 14인 해시값으로 변환된다. 0번주소값에서 14만큼 떨어진 주소로 바로 넘어가서 값을 가져온다 결국 탐색을 단 한번에 끝낼수 있으므로 시간복잡도는 O(1)이다. 예시 : [프로그래머스] 코딩테스트 풀이 - 완주하지 못한 선수","categories":[{"name":"CS","slug":"CS","permalink":"https://taeyeonkim93.github.io/categories/CS/"},{"name":"자료구조","slug":"CS/자료구조","permalink":"https://taeyeonkim93.github.io/categories/CS/자료구조/"}],"tags":[{"name":"DATA STRUCTURE","slug":"DATA-STRUCTURE","permalink":"https://taeyeonkim93.github.io/tags/DATA-STRUCTURE/"},{"name":"HASH","slug":"HASH","permalink":"https://taeyeonkim93.github.io/tags/HASH/"},{"name":"HASH TABLE","slug":"HASH-TABLE","permalink":"https://taeyeonkim93.github.io/tags/HASH-TABLE/"}]},{"title":"[Kotlin] 코틀린 날짜 함수 정리","slug":"Programming-kotlin-2019-09-17-kotlin-calendar-function","date":"2019-09-17T06:59:06.000Z","updated":"2019-09-18T09:56:55.577Z","comments":true,"path":"2019/09/17/Programming-kotlin-2019-09-17-kotlin-calendar-function/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/Programming-kotlin-2019-09-17-kotlin-calendar-function/","excerpt":"","text":"코틀린 날짜 함수프로그래머스 문제를 풀다가 java에서는 Date가 Deprecate 되고 Calendar를 사용한다고 해서 정리해봤다. 전체적으로 정리하기보단 실제로 사용하는 부분에만 중점을 뒀다. 전체 Document는 이곳 참조 java에서는 날짜를 계산하는 내장라이브러리로 Calendar클래스나 java.time 패키지를 주로 사용하지만 일단 사용하기 편한 Calendar 클래스를 보면 Calendar 인스턴스 생성1val calendar:Calendar = Calendar.getInstance() Calendar 클래스는 추상클래스이기 때문에 객체를 직접 생성할 수 없고 getInstance() 함수를 통해 완전히 구현된 클래스의 인스턴스를 얻어야 한다.이 인스턴스를 통해 Calendar 클래스 내부 함수들을 사용할 수 있다. 인스턴스의 내부에는 현재 날짜와 시간정보가 들어있다. 현재 날짜정보 가져오기123456val year = calendar.get(Calendar.YEAR) val mon = calendar.get(Calendar.MONTH) val day = calendar.get(Calendar.DAY_OF_MONTH) val hour = calendar.get(Calendar.HOUR_OF_DAY) val min = calendar.get(Calendar.MINUTE) val sec = calendar.get(Calendar.SECOND) 주의할 점은 calendar.get(Calendar.MONTH) 로 가져오는 월이 1~12이 아니라 0~11 이다.그래서 0이 1월, 11이 12월을 의미한다. 날짜 설정하기 1calendar.set(year,month,date,hour,minute,second) 날짜 일수 계산하기 12calendar.timeInMillis //설정된 시간을 밀리초로 변경 시간을 밀리초로 변환시킨 후SimpleDateFormat()함수를 통해 원하는 Date Format으로 변경한다.자세한 포맷은 정식문서 참조 결과값이 한글로 나올경우 뒤에 Locale.ENGLISH을 붙여 영어로 만든다. 12SimpleDateFormat(\"yyyy.MM.dd G 'at' HH:mm:ss z\",Locale.ENGLISH).format(calendar.timeInMillis) //2001.07.04 AD at 12:08:56 PDT","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"KOTLIN","slug":"KOTLIN","permalink":"https://taeyeonkim93.github.io/tags/KOTLIN/"},{"name":"CALENDAR","slug":"CALENDAR","permalink":"https://taeyeonkim93.github.io/tags/CALENDAR/"},{"name":"LIBRARY","slug":"LIBRARY","permalink":"https://taeyeonkim93.github.io/tags/LIBRARY/"},{"name":"JAVA","slug":"JAVA","permalink":"https://taeyeonkim93.github.io/tags/JAVA/"},{"name":"날짜 함수","slug":"날짜-함수","permalink":"https://taeyeonkim93.github.io/tags/날짜-함수/"},{"name":"내장라이브러리","slug":"내장라이브러리","permalink":"https://taeyeonkim93.github.io/tags/내장라이브러리/"}]},{"title":"[프로그래머스] 코딩테스트 풀이 - 2016년","slug":"Algorithm-2019-09-17-programmers-coding-test-1","date":"2019-09-17T06:34:03.000Z","updated":"2019-09-18T09:55:14.765Z","comments":true,"path":"2019/09/17/Algorithm-2019-09-17-programmers-coding-test-1/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/Algorithm-2019-09-17-programmers-coding-test-1/","excerpt":"","text":"Reference : 프로그래머스 코딩 테스트 연습 문제 설명2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요?두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요.요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT입니다.예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요. 제한 조건2016년은 윤년입니다.2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다) 입출력 예 a b result 5 24 TUE 풀이사용언어 : Kotlin 날짜 구하는 함수를 직접 만들경우 2016년의 모든 달(1월~12월)의 마지막 날을 적는다. 12val month = listOf(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) // 1월~12월의 전체 날짜 수 2016년 1월 1일이 무슨일인지 알아낸다. (금요일) 금요일부터 목요일까지 영어로 적혀있는 배열을 만든다. 12val dayOfWeek = listOf(\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\")// 1월 1일부터 반복되는 요일 영어 1월 1일이라면 (0 + 1 - 1) % 7 = 0 -&gt; FRI3월 6일이라면 (31 + 29 + 6 - 1) % 7 = 2 -&gt; SUN숫자로 계산한 후 dayOfWeek에서 대응하는 날짜를 찾아 변환한다.123456for (i in 0 until a - 1) &#123; total += month[i] // 날짜 계산식&#125; total += (b-1) return dayOfWeek[total%7] // 요일 산출 내장 라이브러리를 사용해서 만들경우 월, 일을 날짜 변수에 넣는다 12val calendar = Calendar.getInstance() calendar.set(2016, a-1, b) 현재 날짜를 밀리초 단위로 변경한 후, 반환값이 날짜 포맷으로 출력되는 함수 SimpleDateFormat을 활용해서 영어단어로 출력한다. 12return SimpleDateFormat(\"EEE\", Locale.ENGLISH).format(calendar.timeInMillis).toUpperCase() // 밀리초단위로 변경 후 SimpleDateFormat으로 요일 출력 해당 내장함수에 대한 설명은 타 포스팅 참조 Kotlin 날짜함수 정리 전체 답안 12345678910import java.text.SimpleDateFormat import java.util.* class Solution &#123; fun solution(a: Int, b: Int): String &#123; val calendar = Calendar.getInstance() calendar.set(2016, a-1, b) return SimpleDateFormat(\"EEE\", Locale.ENGLISH).format(calendar.timeInMillis).toUpperCase() &#125; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","permalink":"https://taeyeonkim93.github.io/categories/Algorithm/프로그래머스/"}],"tags":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"https://taeyeonkim93.github.io/tags/ALGORITHM/"},{"name":"CODING TEST","slug":"CODING-TEST","permalink":"https://taeyeonkim93.github.io/tags/CODING-TEST/"},{"name":"DATE LIBRARY","slug":"DATE-LIBRARY","permalink":"https://taeyeonkim93.github.io/tags/DATE-LIBRARY/"},{"name":"KOTLIN","slug":"KOTLIN","permalink":"https://taeyeonkim93.github.io/tags/KOTLIN/"}]},{"title":"[VCS] Github에서 실수로 Push한 Commit 삭제하기","slug":"etc-2019-09-17-github-commit-remove","date":"2019-09-17T06:18:50.000Z","updated":"2019-09-18T11:07:47.687Z","comments":true,"path":"2019/09/17/etc-2019-09-17-github-commit-remove/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/17/etc-2019-09-17-github-commit-remove/","excerpt":"","text":"Git 작업 시 오타가 났거나 올라가면 안되는 Commit을 Push 했을경우 어떻게 삭제해야 할까? - 지워야 하는 Commit 잘못된 커밋이 몇개나 있으면 가독성을 해치게 된다. 깔끔하게 삭제하고 새롭게 commit 내용을 추가해보자. 지워야하는 해당 폴더에 들어가서 git log로 내역이 잘 나오는지 확인하자. * Hexo를 사용하는 유저는 .deploy_git 폴더에서 작업해야함 - git log 화면 지워야할 내용을 확인했다면 삭제 명령어를 입력하자. 1git reset --hard HEAD~[지울 개수] reset은 현재 진행중인 최신 commit에서부터 아래로 [지울 개수] 만큼 삭제한다. commit 시점 되돌리기 관련 내용은 타 문서를 참고하면 좋다.개발 바보들의 놀이터 - [초보용] Git 되돌리기( Reset, Revert ) - 삭제화면 - 삭제 이후 git log 현재 local의 commit 상태는 그대로 유지되니 올바른 내용의 commit을 한 후에 push를 진행하면 된다. 1git push origin +master // 강제푸시해야함 혹시 reset의 HEAD 숫자를 잘못입력해서 너무 많이 reset했을경우, git reflog를 사용해 몇번째 HEAD로 이동해야 하는지 살펴본다. 이동해야할 HEAD를 확인했으면 1git reset --hard HEAD@&#123;1&#125; 과 같이 강제로 되돌릴수 있다.","categories":[{"name":"etc","slug":"etc","permalink":"https://taeyeonkim93.github.io/categories/etc/"},{"name":"VCS","slug":"etc/VCS","permalink":"https://taeyeonkim93.github.io/categories/etc/VCS/"}],"tags":[{"name":"DOCUMENT","slug":"DOCUMENT","permalink":"https://taeyeonkim93.github.io/tags/DOCUMENT/"},{"name":"GIT","slug":"GIT","permalink":"https://taeyeonkim93.github.io/tags/GIT/"},{"name":"GITHUB","slug":"GITHUB","permalink":"https://taeyeonkim93.github.io/tags/GITHUB/"},{"name":"HEXO","slug":"HEXO","permalink":"https://taeyeonkim93.github.io/tags/HEXO/"},{"name":"RESET","slug":"RESET","permalink":"https://taeyeonkim93.github.io/tags/RESET/"},{"name":"VCS","slug":"VCS","permalink":"https://taeyeonkim93.github.io/tags/VCS/"}]},{"title":"[kotlin] 3. 함수형 프로그래밍","slug":"Programming-kotlin-2019-09-15-kotlin-study-3","date":"2019-09-15T10:29:05.000Z","updated":"2019-09-17T06:15:09.265Z","comments":true,"path":"2019/09/15/Programming-kotlin-2019-09-15-kotlin-study-3/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/15/Programming-kotlin-2019-09-15-kotlin-study-3/","excerpt":"","text":"References: Do it! 코틀린 프로그래밍 함수 구조123456package chap03.section1 fun sum(a: Int, b: Int): Int &#123; // fun 키워드 // 함수 이름 // 매개변수 // 반환자료형 명시 var sum = a + b // 함수 본문 return sum // 반환 &#125; 한줄로 단축도 가능하다 1fun sum(a: Int, b: Int): Int = a + b 코틀린 함수 특성함수는 스택 메모리에 저장된다.스택은 각 함수가 Frame단위로 적재된다.LIFO인 스택 구조상 Main() 함수의 프레임이 가장 바닥에 적재되고, 그위에 max()함수 등 호출되는 순서대로 적재된다. 1234567힙 영역 (낮은 주소) ↓ min()함수 Frame max()함수 Frame main()함수 Frame ↑ 스택 영역(높은 주소) 함수는 스택 영역의 높은 주소부터 거꾸로 자라듯이 채워져 나간다.가장 나중에 호출된 min 함수가 가장 위로 올라가고, 호출이 종료되면 Frame단위로 사라진다.함수 내부의 변수들은 서로 겹치지않으므로 함수 내부의 변수들끼리 계산이 가능하다. Kotlin에서는 함수의 반환값을 생략할 수 있다.단, 함수의 반환값을 생략하고 함수를 작성하면 Unit이라는 특수한 자료형으로 반환된다. 123fun printSum(a: Int, b: Int): Unit &#123; //Unit은 없어도 상관없음 println(\"sum of $a and $b is $&#123;a + b&#125;\") &#125; 함수 내에서 여러개의 매개변수를 받을 때, 가변 인자를 사용하면 된다. 1234567891011fun main() &#123; normalVarargs(1,2,3,4) normalVarargs(4,5,6) &#125; fun normalVarargs(vararg counts: Int) &#123; // 가변인자 vararg for (num in counts) &#123; print(\"$num \") &#125; print(\"\\n\") &#125; 123실행결과1 2 3 4 4 5 6 variable argument, 가변 인자의 약자 vararg를 사용하면 그때그때 변하는 인자의 개수를 전부 매개변수로 받아 사용 할 수 있다. 함수형 프로그래밍 구조코틀린은 함수형 프로그래밍과 객체지향형 프로그래밍을 모두 지원하는 다중 패러다임 언어 이다. 다중 패러다임 언어 : 한가지 구현 규칙에 얽매이지 않고 다양한 문법과 형식을 지원하는 언어 함수형 프로그래밍?함수형 프로그래밍의 정의와 특징 순수 함수를 사용해야 한다. 람다식을 사용할 수 있다. 고차 함수를 사용할 수 있다. 1. 순수함수함수형 프로그래밍은 순수 함수를 작성하여 프로그램의 부작용을 줄이는 프로그래밍 기법을 말한다. 순수 함수의 조건 같은 인자에 대하여 항상 같은 값을 반환하는 함수 함수 외부의 어떤 상태도 바꾸지 않는 함수 1234순수 함수의 예 fun sum(a: Int, b: Int): Int &#123; return a + b &#125; 123456순수 함수를 만족하지 않는 함수의 예 fun check() &#123; val test = User.grade() if (test != null) process(test) // test는 User.grade()의 상태에 따라 달라짐 &#125; 2. 람다식람다식은 다음과 같은 형태로 이루어져있다. { x, y -&gt; x + y } 함수의 이름이 없고, 화살표(-&gt;)가 사용되었다. 함수형 프로그래밍의 람다식은 다음과 같은것을 말한다. 다른 함수의 인자로 넘기는 함수 함수의 결과값으로 반환되는 함수 변수에 저장하는 함수 람다식 예시 1234567891011121314변수에 할당하는 람다식 //// 같은 람다식 //// val multi: (Int, Int) -&gt; Int = &#123;x: Int, y: Int, Int -&gt; x * y&#125; val multi = &#123;x: Int, y: Int -&gt; x * y&#125; val multi: (Int, Int) -&gt; Int = &#123;x, y -&gt; x * y&#125; //// 같은 람다식 //// val multi = &#123;x,y -&gt; x * y&#125; // 이건 오류 (자료형이 없음) val greet: () -&gt; Unit = &#123;println(\"Hello World!\")&#125; // 반환값이 없을때 val square: (Int) -&gt; Int = &#123;x -&gt; x * x&#125; // 매개변수가 하나일때 val nestedLambda: () -&gt; () -&gt; Unit = &#123;&#123;println(\"nested\")&#125;&#125; // 람다식 안에 람다식 사용할경우 함수처럼 multi(x,y)로 사용하면 된다. 3. 일급 객체함수형 프로그래밍에서는 함수를 “일급 객체” 로 생각한다. 일급 객체의 특징은 다음과 같다. 일급 객체는 함수의 인자로 전달할 수 있다. 일급 객체는 함수의 반환값에 사용할 수 있다. 일급 객체는 변수에 담을 수 있다. 함수가 일급 객체면 일급 함수라고 부른다.일급 함수에 이름이 없는 경우 람다식 함수 혹은 람다식이라고 부를 수 있다즉 람다식은 일급 객체의 특징을 가진 이름 없는 함수이다. 4. 고차 함수고차 함수 란 다른 함수를 인자로 사용하거나 함수를 결과값으로 반환하는 함수를 말한다. 인자가 일반 함수인 고차 함수 예시 1234567891011인자가 일반 함수인 고차 함수 fun main() &#123; val res1 = sum(3,2) val res2 = mul(sum(3,3),3) // 인자에 함수 사용 println(\"res1: $res1, res2: $res2\") &#125; fun sum(a:Int, b:Int) = a + b fun mul(a:Int, b:Int) = a * b 12실행 결과 res1: 5, res2: 18 반환값이 일반 함수인 고차 함수 예시 1234567891011반환값이 일반 함수인 고차 함수 fun main() &#123; println(\"funcFunc: $&#123;funcFunc()&#125;\") &#125; fun sum(a:Int, b:Int) = a + b fun funcFunc():Int &#123; return sum(2,2) // 반환값이 함수 &#125; 12실행 결과 funcFunc: 4 람다식을 매개변수에 할당하는 고차함수 예시 123456789101112람다식을 매개변수에 할당하는 고차함수 fun main() &#123; var result: Int result = highOrder(&#123; x, y -&gt; x + y&#125;, 10,20) // 람다식 함수 호출 println(result) &#125; fun highOrder(sum: (Int, Int) -&gt; Int, a: Int, b: Int): Int &#123; // 매개변수에 삽입된 람다식 return sum(a,b) &#125; 12실행 결과 30 인자와 반환값이 없는 람다식 고차함수 예시 123456789인자와 반환값이 없는 람다식 고차함수fun main() &#123; val out: () -&gt; Unit = &#123;println(\"Hello World\")&#125; // -&gt; Unit 생략 가능 out() // 함수처럼 이용가능 val new = out // 다른 변수에 람다식 할당 가능 new() &#125; 123실행 결과 Hello World Hello World","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"do it study","slug":"do-it-study","permalink":"https://taeyeonkim93.github.io/tags/do-it-study/"},{"name":"kotlin","slug":"kotlin","permalink":"https://taeyeonkim93.github.io/tags/kotlin/"}]},{"title":"[kotlin] 2. 코틀린 기초","slug":"Programming-kotlin-2019-09-14-kotlin-study-2","date":"2019-09-14T09:04:45.000Z","updated":"2019-09-16T03:26:20.715Z","comments":true,"path":"2019/09/14/Programming-kotlin-2019-09-14-kotlin-study-2/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/14/Programming-kotlin-2019-09-14-kotlin-study-2/","excerpt":"","text":"References: Do it! 코틀린 프로그래밍 프로젝트, 모듈, 패키지, 파일코틀린은 파일이 모여 패키지가 되고, 패키지가 모여 모듈이 된다.파이썬에서는 모듈이 모여 패키지가 되더니 언어마다 다른건가 싶다. 코틀린 프로젝트 계층 구조 1234# 프로젝트 ## 모듈 ### 패키지 #### 파일 패키지같은 프로젝트 내에서 같은 클래스 이름을 쓰더라도 오류가 나지 않게 패키지 이름으로 분류한다. 같은 프로젝트 내 Person 클래스 2개 -&gt; 충돌 발생 1번 패키지 내 Person 클래스 / 2번 패키지 내 Person 클래스 -&gt; 문제없음 패키지 이름을 선언하지 않고 파일을 만들면 default 패키지 아래로 자동으로 들어간다. - 보이지않는 default 패키지 아래에 존재하는 파일 패키지 명은 .으로 구분한다. 1com.example.edu 기능이나 역할을 뒤에 추가로 넣어주면 좋다. 1com.example.net.upload // 인터넷 업로드 기능을 하는 패키지명 다른 패키지 내 클래스 import 문법 및 클래스 객체로 만들기 123package com.taeyeon93.study.freetest2class Person(val name: String, val age:Int) // 클래스 선언 123456789package com.taeyeon93.study.freetest import com.taeyeon93.study.freetest2.Person // 클래스 import fun main() &#123; val user1 = Person(\"kildong\", 30) // 클래스 객체로 만들기 println(user1.name) println(user1.age)&#125; 123실행결과kildong30 다른 패키지 내의 클래스명과 현재 패키지의 클래스명이 같아서 객체를 만들기 어려울 때 as 별명을 붙여 구분한다. 1234import com.example.edu.Person as User fun main() &#123; val user1 = User(\"kildong\", 30) &#125; 변수/자료형변수변수는 val, var라는 키워드를 이용하여 선언한다. val : 변할 수 없는 상수 선언시 사용 / C,C++ 등에서는 const var : 일반적인 변수 코틀린은 자료형을 지정하지 않아도 자료형을 추론해서 알아서 자료형을 지정 할 수 있다. 12val username = \"Kildong\"// 코틀린이 자료형을 추론하여 username의 자료형을 String으로 결정 단, 자료형을 명시하지 않는 변수는 자료형을 추론할 수 있는 값을 지정해야 한다. 1var username // 자료형이 지정되지 않아 선언불가 변수에 커서를 대고 Ctrl+Shift+P를 누르면 추론된 자료형을 볼 수 있다. 쌍따옴표 내부에서 변수를 사용할때는 $ 특수문자를 붙여야 한다. 123456fun main()&#123; val number = 1234 println(number) println(\"$number\") &#125; 자료형코틀린의 자료형은 참조형 자료형을 사용한다. 기본형 자료형(Primitive Data Type) : int, long, float, double 등 참조형 자료형(Reference Type) : String, Date 등 참조형으로 선언한 변수는 코틀린 컴파일러에서 다시 기본형 자료형으로 대체되기 때문에 굳이 기본형을 신경쓸 필요가 없다. 언더스코어를 사용하면 자릿값을 구분할 수 있다. 123val number = 1_000_000val cardNum = 1234_1234_1234_1234L val hexVal = 0XAB_CD_EF_12 변수를 선언할때는 힙 영역에 실제 데이터를, 스택 영역에 주소값을 넣는다. 문자열 자료형은 동일한 문자열을 선언할 경우, 이미 힙 영역을 사용하고있는 문자열을 참조하는것이 효율적이므로이전에 선언한 힙 영역의 실제 데이터를 참조하는 주소값을 생성한다. 12345678910fun main() &#123; var str1: String = \"Hello\" var str2 = \"World\" var str3 = \"Hello\" // 동일한 Hello 라는 값을 선언한 경우 str1이 갖고있는 값의 주소값을 스택에 넣는다. println(\"str1 === str2: $&#123;str1 === str2&#125;\") println(\"str1 === str3: $&#123;str1 === str3&#125;\") // 주소값이 일치하므로 true&#125; 123실행결과 str1 === str2: falsestr1 === str3: true 코틀린은 아예 변수에 null을 허용하지 않아 NullPointerException 오류가 발생하지 않는다.그래서 코틀린에서 null을 허용하기위해서는 ? 기호를 이용해 선언해야 한다. null을 허용한 변수를 사용하기위해선 세이프 콜과 non-null 단정 기호를 사용해야 한다. 세이프 콜 : String? 과 같은 자료형은 변수 뒤에 ?. 을 붙여야 콜이 가능하다. non-null 단정기호 : 세이프콜과 같은 역할이며 !!. 을 붙여서 콜을 하지만, null에 대한 검증을 거치지 않아 컴파일은 가능하나 빌드중에 NPE 에러를 낸다. 12345fun main() &#123; var str1 : String? = \"Hello Kotlin\" str1 = null println(\"str1: $&#123;str1?.length&#125;\") // 세이프콜&#125; 12실행결과 str1 : null 12345fun main() &#123; var str1 : String? = \"Hello Kotlin\" str1 = null println(\"str1: $&#123;str1!!.length&#125;\") // non-null 단정기호&#125; 1234실행결과Exception in thread \"main\" kotlin.KotlinNullPointerException at chap02.section3.Sec3Kt.main(sec3.kt:6) at chap02.section3.Sec3Kt.main(sec3.kt) 엘비스 연산자를 이용하면 좀 더 안전하고 효율적으로 null을 허용한 변수를 사용할 수 있다.변수에 들어있는 값이 null일경우 반환값을 특정한 값으로 대체할 수 있다. 엘비스 연산자 : [?:] 왼쪽의 값이 null일 경우 오른쪽 값을 반환. 12345fun main() &#123; var str1 : String? = \"Hello Kotlin\" str1 = null println(\"str1: $str1 length: $&#123;str1?.length ?: -1&#125;\") // 엘비스 연산자 사용&#125; 12실행결과 str1: null length: -1 코틀린에서는 서로 다른 자료형의 변수를 비교하거나 연산할 수 없다.서로 다른 변수를 같은 자료형으로 직접 만들어야 연산할 수 있다.형변환은 toByte, toLong, toDouble 등을 통해서 변경한다. 어떤 변수가 정수일수도 있고 실수일 수도 있는 경우, 스마트 캐스트를 활용한다.일반적으로 처음 선언한 자료형은 뒤에 다른 자료형을 대입할 수 없지만, 스마트캐스트를 이용하면 가능하다.스마트캐스트는 Number, Any 등을 써서 다양하게 사용 할 수 있다. 12345678910111213fun main() &#123; var test: Number = 12.2 println(\"$test\") test = 12 println(\"$test\") test = 120L println(\"$test\") test += 12.0f println(\"$test\") &#125; 12345결과값 12.2 12 120 132.0 $변수.javaClass 를 사용하면 변수의 자료형을 얻을 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"do it study","slug":"do-it-study","permalink":"https://taeyeonkim93.github.io/tags/do-it-study/"},{"name":"kotlin","slug":"kotlin","permalink":"https://taeyeonkim93.github.io/tags/kotlin/"}]},{"title":"[kotlin] 1. 코틀린 Hello World","slug":"Programming-kotlin-2019-09-14-kotlin-study-1","date":"2019-09-14T07:04:30.000Z","updated":"2019-09-14T08:57:20.367Z","comments":true,"path":"2019/09/14/Programming-kotlin-2019-09-14-kotlin-study-1/","link":"","permalink":"https://taeyeonkim93.github.io/2019/09/14/Programming-kotlin-2019-09-14-kotlin-study-1/","excerpt":"","text":"References: Do it! 코틀린 프로그래밍 코틀린 공부를 정리하는 포스팅 코틀린 언어의 장점 자료형 오류를 미리 검사한다. NPE(NullPointerException) 예방으로 인한 안정성이 향상된다. 간결하고 효율적이다. 함수형 프로그래밍, 객체지향 프로그래밍 모두 가능하다. 코틀린 환경 세팅 JVM 환경에서 실습을 진행하기위하여 JDK(Java Development Kit) 설치가 필요하므로OpenJDK 설치(안정적인 동작을 위해 Java 8 버전 설치), 환경변수 세팅 InteliJ IDE 설치 Hello World!코틀린 언어의 Hello World 출력법 123fun main(args: Array&lt;String&gt;) &#123; println(\"Hello Kotlin!\") &#125; 12실행결과Hello Kotlin! Ctrl + Shift + F10으로 빌드가 가능하다. 코틀린 코드는 main()메서드가 있는 파일 이름을 기준으로 JVM이 자동으로 클래스를 생성하므로 클래스를 명시하지 않아도 동작한다. 123456789101112내부에서 자동으로 생성된 코틀린의 클래스 (tools &gt; Kotlin &gt; show Kotlin Bytecode 혹은 우측 Kotlin Bytecode 클릭) public final class HelloKotlinKt &#123; // access flags 0x19 public final static main(\\[Ljava/lang/String;)V // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 ... ...","categories":[{"name":"Programming","slug":"Programming","permalink":"https://taeyeonkim93.github.io/categories/Programming/"},{"name":"Kotlin","slug":"Programming/Kotlin","permalink":"https://taeyeonkim93.github.io/categories/Programming/Kotlin/"}],"tags":[{"name":"do it study","slug":"do-it-study","permalink":"https://taeyeonkim93.github.io/tags/do-it-study/"},{"name":"kotlin","slug":"kotlin","permalink":"https://taeyeonkim93.github.io/tags/kotlin/"}]}]}